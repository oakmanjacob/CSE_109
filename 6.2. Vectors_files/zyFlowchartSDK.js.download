define("zyFlowchartSDK", ["exports"], function(exports) {
var module = {};
'use strict';

/* exported FunctionCodeController */

/**
    Abstract class to render and control a function's code, which may be a flowchart or text.
    @class FunctionCodeController
*/

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FunctionCodeController = function () {

    /**
        @constructor
        @param {Object} $containerDOM jQuery reference to the container for the controller.
    */
    function FunctionCodeController($containerDOM) {
        _classCallCheck(this, FunctionCodeController);

        /**
            jQuery reference to the container for the controller.
            @property $containerDOM
            @type {Object}
        */
        this.$containerDOM = $containerDOM;
    }

    /**
        Render the function's code.
        @method render
        @return {void}
    */


    _createClass(FunctionCodeController, [{
        key: 'render',
        value: function render() {
            throw new Error('FunctionCodeController\'s render function should be overridden');
        }

        /**
            Ensure the showing of the node that is next to execute.
            @method showNextToExecuteNode
            @param {FlowchartNode} nextNodeToExecute The next node to execute.
            @return {void}
        */

    }, {
        key: 'showNextToExecuteNode',
        value: function showNextToExecuteNode(nextNodeToExecute) {
            // eslint-disable-line no-unused-vars
            throw new Error('FunctionCodeController\'s showNextToExecuteNode function should be overridden');
        }

        /**
            Put the browser's focus on this function.
            @method focus
            @return {void}
        */

    }, {
        key: 'focus',
        value: function focus() {} // eslint-disable-line no-empty-function

        /**
            Set an error on the controller.
            @method setError
            @param {String} message The error message.
            @param {Integer} lineNumber The line number of the error.
            @return {void}
        */

    }, {
        key: 'setError',
        value: function setError(message, lineNumber) {} // eslint-disable-line

        /**
            Clear an error on the controller.
            @method clearError
            @return {void}
        */

    }, {
        key: 'clearError',
        value: function clearError() {} // eslint-disable-line no-empty-function

    }]);

    return FunctionCodeController;
}();

'use strict';

/* exported ExecutorController */
/* global FunctionController, globalConstants, makeRandomInteger, TextualCodeParser, RestrictedCode, PseudocodeController */

/**
    Control an {Executor}.
    @class ExecutorController
*/

var ExecutorController = function () {

    /**
        @constructor
        @param {Executor} executor The executor to control.
        @param {Object} $containerDOM jQuery reference to the container for the controller.
    */
    function ExecutorController(executor, $containerDOM) {
        _classCallCheck(this, ExecutorController);

        /**
            The executor to control.
            @property executor
            @type {Executor}
        */
        this.executor = executor;

        /**
            jQuery reference to the container for the controller.
            @property $containerDOM
            @type {Object}
        */
        this.$containerDOM = $containerDOM;

        /**
            List of function controllers for each function in the program.
            @property functionControllers
            @type {Array} of {FunctionController}
            @default []
        */
        this.functionControllers = [];

        /**
            Reference to the controller for pseudocode used by this executor.
            @property pseudocodeController
            @type {PseudocodeController}
            @default null
        */
        this.pseudocodeController = null;

        /**
            jQuery reference to the function containers.
            @property $functionContainers
            @type {Object}
            @default null
        */
        this.$functionContainers = null;

        /**
            Whether the executor is in execute mode.
            @property isInExecuteMode
            @type {Boolean}
            @default false
        */
        this.isInExecuteMode = false;

        /**
            The last function on the stack.
            @property lastFunctionOnStack
            @type {ProgramFunction}
            @default null
        */
        this.lastFunctionOnStack = null;

        /**
            The currently shown function index, if one exists.
            @property currentlyShownFunctionIndex
            @type {Integer}
            @default 0
        */
        this.currentlyShownFunctionIndex = 0;

        /**
            Whether to render in compact mode. Compact mode uses |this.maxHeight| and |this.maxWidth|, and uses a segmented controller for multiple functions.
            @property isCompact
            @type {Boolean}
            @default false
        */
        this.isCompact = false;

        /**
            The max height of the executor.
            @property maxHeight
            @type {Integer}
            @default null
        */
        this.maxHeight = null;

        /**
            The max width of the executor.
            @property maxWidth
            @type {Integer}
            @default null
        */
        this.maxWidth = null;

        /**
            Whether to show the function name.
            @property showFunctionName
            @type {Boolean}
            @default true
        */
        this.showFunctionName = true;

        /**
            Whether to make the output editable.
            @property isOutputEditable
            @type {Boolean}
            @default false
        */
        this.isOutputEditable = false;

        /**
            Whether to make the input editable.
            @property isInputEditable
            @type {Boolean}
            @default true
        */
        this.isInputEditable = true;

        /**
            The function call when the output has changed via user input.
            @property outputChangeFunction
            @type {Function}
            @default null
        */
        this.outputChangeFunction = null;

        /**
            The segmented function control used in compact mode when there are multiple functions and flowcharts are shown.
            @property segmentedFunctionControl
            @type {SegmentedControl}
            @default null
        */
        this.segmentedFunctionControl = null;

        /**
            The segmented language control used when both languages are shown, so the user can switch between the languages.
            @property segmentedLanguageControl
            @type {SegmentedControl}
            @default null
        */
        this.segmentedLanguageControl = null;

        /**
            Whether the segmented function control is enabled.
            @property isSegmentedFunctionControlEnabled
            @type {Boolean}
            @default true
        */
        this.isSegmentedFunctionControlEnabled = true;

        /**
            Whether the segmented language control is enabled.
            @property isSegmentedLanguageControlEnabled
            @type {Boolean}
            @default true
        */
        this.isSegmentedLanguageControlEnabled = true;

        /**
            The language(s) to show. Valid values: 'flowchart', 'pseudocode', and 'both'.
            @property languagesToShow
            @type {String}
            @default 'flowchart'
        */
        this.languagesToShow = 'flowchart';

        /**
            Whether pseudocode is currently being shown.
            @property isPseudocodeCurrentlyShown
            @type {Boolean}
            @default false
        */
        this.isPseudocodeCurrentlyShown = false;

        /**
            Whether the pseudocode is editable, which is only applicable when |this.languagesToShow| is 'pseudocode' or 'both'.
            @property isPseudocodeEditable
            @type {Boolean}
            @default false
        */
        this.isPseudocodeEditable = false;

        /**
            Whether the pseudocode is currently editable. Pseudocode is not editable while executing. Pseudocode is only editable if |this.isPseudocodeEditable| is true.
            @property isPseudocodeEditable
            @type {Boolean}
            @default false
        */
        this.isPseudocodeCurrentlyEditable = false;

        /**
            Whether pseudocode editing is restricted to only the placeholder, and the pre and post are not editable.
            @property isPseudocodeEditingRestricted
            @type {Boolean}
            @default false
        */
        this.isPseudocodeEditingRestricted = false;

        /**
            The program's code that is restricted to editing the placeholder, not the pre and post.
            @property restrictedCode
            @type {RestrictedCode}
            @default null
        */
        this.restrictedCode = null;

        /**
            The error message shown to the user.
            @property errorMessage
            @type {String}
            @default null
        */
        this.errorMessage = null;

        /**
            The line number of the line of code with an error.
            @property errorLineNumber
            @type {Integer}
            @default null
        */
        this.errorLineNumber = null;

        /**
            The previously executed node.
            @property previousNodeExecuted
            @type {FlowchartNode}
            @default null
        */
        this.previousNodeExecuted = null;

        /**
            Callback function when a compilation error occurs.
            @property compilationErrorCallback
            @type {Function}
            @default null
        */
        this.compilationErrorCallback = null;
    }

    /**
        Render the functions, and input and output if provided.
        @method render
        @return {void}
    */


    _createClass(ExecutorController, [{
        key: 'render',
        value: function render() {
            var _this = this;

            if (this.executor.input) {
                this.executor.input.clearRegisteredControllers();
            }
            if (this.executor.output) {
                this.executor.output.clearRegisteredControllers();
            }
            if (this.pseudocodeController) {
                this.pseudocodeController.detach();
            }

            // Store scrolling amount for each function's code.
            var formerFunctionScroll = this.functionControllers.map(function (controller) {
                return controller.makeFunctionAndCodeScrollAmount();
            });

            // Generate a random integer to use in each segmented controller ID.
            var segmentedFunctionControlId = 'segmented-function-control-' + makeRandomInteger();
            var segmentedLanguageControlId = 'segmented-language-control-' + makeRandomInteger();

            // Render the functions.
            var functions = this.makeFunctionsToRender();
            var isUsingBothLanguages = this.languagesToShow === 'both';

            this.$containerDOM.html(globalConstants.templates.executor({
                errorMessage: this.errorMessage,
                functions: functions, isUsingBothLanguages: isUsingBothLanguages, segmentedFunctionControlId: segmentedFunctionControlId, segmentedLanguageControlId: segmentedLanguageControlId
            }));
            this.$functionContainers = this.$containerDOM.find('.function-container');
            this.functionControllers = functions.map(function (programFunction, index) {
                return new FunctionController(programFunction, _this.executor.code, _this.$functionContainers.eq(index), _this.executor.input, _this.executor.output);
            });
            this.functionControllers.forEach(function (controller) {
                controller.setIsPseudocodeCurrentlyShown(_this.isPseudocodeCurrentlyShown, _this.pseudocodeController);
                controller.setIsPseudocodeEditable(_this.isPseudocodeCurrentlyEditable);
                controller.setIsPseudocodeEditingRestricted(_this.isPseudocodeEditingRestricted, _this.restrictedCode);
                controller.setShowFunctionName(_this.showFunctionName);
                controller.setIsOutputEditable(_this.isOutputEditable, _this.outputChangeFunction);
                controller.setIsInputEditable(_this.isInputEditable);
                controller.setIsInExecuteMode(_this.isInExecuteMode);
                controller.render();

                if (_this.errorMessage) {
                    controller.setError(_this.errorMessage, _this.errorLineNumber);
                } else {
                    controller.clearError();
                }
            });

            // Compact mode limits the height and width of the rendering.
            if (this.isCompact) {
                this.renderCompactMode(isUsingBothLanguages, segmentedFunctionControlId, segmentedLanguageControlId, formerFunctionScroll);
            }

            // Make each variable and IO container, then make each function container the same height/width.
            else {
                    this.$functionContainers.each(function (index, functionContainer) {
                        $(functionContainer).find('.function-container').height('auto').width('auto');
                    });
                }

            this.updateShownFunction();
        }

        /**
            Render the compact mode, which limits the height and width of the rendering.
            @method renderCompactMode
            @param {Boolean} isUsingBothLanguages Whether both languages are being used.
            @param {String} segmentedFunctionControlId The unique ID for the segmented function controller.
            @param {String} segmentedLanguageControlId The unique ID for the segmented language controller.
            @param {Array} formerFunctionScroll Array of {FunctionAndFlowchartScrollAmount}. List of previous function scrolling amounts.
            @return {void}
        */

    }, {
        key: 'renderCompactMode',
        value: function renderCompactMode(isUsingBothLanguages, segmentedFunctionControlId, segmentedLanguageControlId, formerFunctionScroll) {
            var _this2 = this;

            var segmentedControllerHeights = 0;

            // Add a segmented control if pseudocode is not shown and there are multiple functions.
            if (!this.isPseudocodeCurrentlyShown && this.executor.program.functions.length > 1) {
                this.renderFunctionSegmentedController(segmentedFunctionControlId);
                segmentedControllerHeights += $('#' + segmentedFunctionControlId).outerHeight(true);
            }

            // Add another segmented control if both languages are shown.
            if (isUsingBothLanguages) {
                this.renderLanguageSegmentedController(segmentedLanguageControlId);
                segmentedControllerHeights += $('#' + segmentedLanguageControlId).outerHeight(true);
            }

            this.functionControllers.forEach(function (controller) {
                return controller.hideFunctionCode();
            });

            // Compute the padding, border, and margin that the program adds to the overall width.
            var $program = this.$containerDOM.find('.flowchart-program');
            var programPaddingBorderAndMarginWidth = $program.outerWidth(true) - $program.width();

            // Find the largest width of the variables. The IO will auto-scale via CSS.
            var maxVariableAndIOWidth = Math.max.apply(Math, _toConsumableArray(this.functionControllers.map(function (controller) {
                return controller.getVariableWidth();
            })));
            var minVariableAndIOWidth = 275;
            var variableAndIOWidthToUse = Math.max(maxVariableAndIOWidth, minVariableAndIOWidth);

            // Update the variable and IO containers width.
            this.functionControllers.forEach(function (controller) {
                return controller.setVariableAndIOWidth(variableAndIOWidthToUse);
            });

            // Find the largest height of any variable and IO container, after the width update.
            var maxVariableAndIOHeight = Math.max.apply(Math, _toConsumableArray(this.functionControllers.map(function (controller) {
                return controller.getVariableAndIOHeight();
            })));

            // Update the variable and IO containers height.
            this.functionControllers.forEach(function (controller) {
                return controller.setVariableAndIOHeight(maxVariableAndIOHeight);
            });

            var variableAndIOWidth = this.functionControllers[0].$containerDOM.find('.variables-and-IO-container').outerWidth(true);
            var maxAllowedFunctionWidth = this.maxWidth - variableAndIOWidth - programPaddingBorderAndMarginWidth;
            var maxCodeWidth = 500;

            if (this.isPseudocodeCurrentlyShown) {
                var functionWidthToUse = Math.min(maxCodeWidth, maxAllowedFunctionWidth);

                this.$functionContainers.each(function (index, functionContainer) {
                    $(functionContainer).find('.function-container').width(functionWidthToUse).height(maxVariableAndIOHeight);
                });

                // Force re-render of the editor because we just changed the height and width.
                this.functionControllers.forEach(function (controller) {
                    controller.showFunctionCode();
                    controller.functionCodeController.forceEditorReRender();
                });
            } else {

                // Find the largest height/width of any function code.
                this.functionControllers.forEach(function (controller) {
                    return controller.showFunctionCode();
                });
                var functionCodeHeights = this.functionControllers.map(function (controller) {
                    return controller.getFunctionCodeHeight();
                });
                var functionCodeWidths = this.functionControllers.map(function (controller) {
                    return controller.getFunctionCodeWidth();
                });
                var offset = 1;
                var maxFunctionCodeHeight = Math.max.apply(Math, _toConsumableArray(functionCodeHeights)) + offset;
                var maxFunctionCodeWidth = Math.max.apply(Math, _toConsumableArray(functionCodeWidths)) + offset;

                // Compute the height and width to use for the function code.
                var _functionWidthToUse = Math.min(maxFunctionCodeWidth, maxAllowedFunctionWidth);

                if (this.languagesToShow === 'both') {
                    _functionWidthToUse = Math.max(_functionWidthToUse, maxCodeWidth);
                }

                var maxHeightMinusSegmentedControl = this.maxHeight - segmentedControllerHeights;
                var functionHeightToUse = Math.min(maxHeightMinusSegmentedControl, maxFunctionCodeHeight);

                this.$functionContainers.each(function (index, functionContainer) {
                    var alignItems = functionCodeHeights[index] < functionHeightToUse ? 'center' : 'stretch';
                    var justifyContent = functionCodeWidths[index] < _functionWidthToUse ? 'center' : 'flex-start';

                    $(functionContainer).find('.function-container').height(functionHeightToUse).width(_functionWidthToUse).css('align-items', alignItems).css('justify-content', justifyContent);
                });
            }

            // For previously existing functions, apply the former scrolling amount.
            this.functionControllers.forEach(function (controller) {
                var associatedFormer = formerFunctionScroll.find(function (former) {
                    return former.programFunction === controller.programFunction;
                });

                if (associatedFormer) {
                    controller.setFunctionCodeScrollAmount(associatedFormer);
                }
            });

            var topOfStack = this.getTopOfStack();
            var nextNodeToExecute = topOfStack && topOfStack.node || null;

            this.functionControllers.forEach(function (controller) {
                return controller.showNextToExecuteNode(nextNodeToExecute, _this2.previousNodeExecuted);
            });
            this.previousNodeExecuted = nextNodeToExecute;
        }

        /**
            Return the list of functions to render.
            @method makeFunctionsToRender
            @return {Array} of {Function} The list of functions to render.
        */

    }, {
        key: 'makeFunctionsToRender',
        value: function makeFunctionsToRender() {
            var functions = [];

            // For pseudocode, show exactly 1 function.
            if (this.isPseudocodeCurrentlyShown) {

                // The default function to show is a Main function w/o any variables.
                var parser = new TextualCodeParser();
                var program = parser.parse('');
                var functionToShow = program.functions[0];

                // Either the function at top of stack or the last shown function.
                if (this.isInExecuteMode) {
                    functionToShow = this.executor.stack.length ? this.getTopOfStack().function : this.lastFunctionOnStack;
                }

                functions.push(functionToShow);
            }

            // For flowchart, show an instance of each function.
            else if (this.isInExecuteMode) {

                    /*
                        Build the list of functions, starting from the top of the stack. Ex:
                        A program has four functions, ordered as follows when not executing: Main, Function1, Function2, Function3.
                        The stack has (from bottom to top): Main, Function2 (first instance), Function1, Function2 (second instance).
                        So, we want the instances of each function closest to the top of the stack.
                        And, if the function isn't in the stack, then we'll render the function from non-execute mode.
                        That is: Main, Function1, Function2 (second instance), and Function3 (non-execute mode instance).
                    */
                    var functionMapToHighestOnStack = {};

                    if (this.executor.stack.length) {
                        this.executor.stack.reverse().forEach(function (element) {
                            if (!(element.function.name in functionMapToHighestOnStack)) {
                                functionMapToHighestOnStack[element.function.name] = element.function;
                            }
                        });

                        // Un-reverse the stack.
                        this.executor.stack.reverse();
                    }

                    // Special case: Stack is empty, so we've finished execution and want to show the last function on the stack.
                    else {
                            functionMapToHighestOnStack[this.lastFunctionOnStack.name] = this.lastFunctionOnStack;
                        }

                    functions.push.apply(functions, _toConsumableArray(this.executor.program.functions.map(function (programFunction) {
                        var functionToUse = programFunction;

                        if (programFunction.name in functionMapToHighestOnStack) {
                            functionToUse = functionMapToHighestOnStack[programFunction.name];
                        }

                        return functionToUse;
                    })));
                } else {
                    functions.push.apply(functions, _toConsumableArray(this.executor.program.functions));
                }

            return functions;
        }

        /**
            Render a segmented controller used to control which function to show.
            @method renderFunctionSegmentedController
            @param {String} segmentedFunctionControlId The segmented function controller's ID.
            @return {void}
        */

    }, {
        key: 'renderFunctionSegmentedController',
        value: function renderFunctionSegmentedController(segmentedFunctionControlId) {
            var _this3 = this;

            var functionNames = this.executor.program.functions.map(function (programFunction) {
                return programFunction.name;
            });

            this.segmentedFunctionControl = require('segmentedControl').create();
            this.segmentedFunctionControl.init(functionNames, segmentedFunctionControlId);
            this.segmentedFunctionControl.selectSegmentByIndex(this.currentlyShownFunctionIndex);
            this.segmentedFunctionControl.segmentSelectedCallback = function (index) {
                if (_this3.currentlyShownFunctionIndex === index) {
                    _this3.setFunctionIndexToShow(index);
                } else {
                    var transitionTime = 100;

                    _this3.$functionContainers.animate({ opacity: 0 }, transitionTime, function () {
                        _this3.setFunctionIndexToShow(index);
                        _this3.$functionContainers.animate({ opacity: 1 }, transitionTime);
                    });
                }
            };

            if (!this.isSegmentedFunctionControlEnabled) {
                this.segmentedFunctionControl.disable();
            }
        }

        /**
            Render a segmented controller used to control which language to show.
            @method renderLanguageSegmentedController
            @param {String} segmentedLanguageControlId The segmented controller's ID.
            @return {void}
        */

    }, {
        key: 'renderLanguageSegmentedController',
        value: function renderLanguageSegmentedController(segmentedLanguageControlId) {
            var _this4 = this;

            this.segmentedLanguageControl = require('segmentedControl').create();
            this.segmentedLanguageControl.init(['Code', 'Flowchart'], segmentedLanguageControlId);
            this.segmentedLanguageControl.selectSegmentByIndex(this.getIndexOfLanguageSegmentedControl());
            this.segmentedLanguageControl.segmentSelectedCallback = function (index) {

                // If the index changed, then re-render.
                if (index !== _this4.getIndexOfLanguageSegmentedControl()) {
                    _this4.isPseudocodeCurrentlyShown = index === 0;

                    // Switching from pseudocode to flowchart, so compile the pseudocode.
                    if (index === 1 && _this4.hadErrorCompiling()) {
                        _this4.segmentedLanguageControl.selectSegmentByIndex(0);
                        return;
                    }
                    _this4.render();
                    if (!_this4.focusCursorOnOutputIfOutputIsEditable()) {
                        _this4.focusOnFunction();
                    }
                }
            };

            if (!this.isSegmentedLanguageControlEnabled) {
                this.segmentedLanguageControl.disable();
            }
        }

        /**
            Return the index of the segmented control based on the currently shown language.
            @method getIndexOfLanguageSegmentedControl
            @return {Integer} The index of the segmented control based on the currently shown language.
        */

    }, {
        key: 'getIndexOfLanguageSegmentedControl',
        value: function getIndexOfLanguageSegmentedControl() {
            return this.isPseudocodeCurrentlyShown ? 0 : 1;
        }

        /**
            Show a specific function if one is defined.
            @method updateShownFunction
            @return {void}
        */

    }, {
        key: 'updateShownFunction',
        value: function updateShownFunction() {
            if (this.currentlyShownFunctionIndex !== null && this.$functionContainers && !this.isPseudocodeCurrentlyShown) {
                this.$functionContainers.hide().eq(this.currentlyShownFunctionIndex).show();
            }
        }

        /**
            Set the index of the function to show.
            @method setFunctionIndexToShow
            @param {Integer} index The index of the function to show.
            @return {void}
        */

    }, {
        key: 'setFunctionIndexToShow',
        value: function setFunctionIndexToShow(index) {
            this.currentlyShownFunctionIndex = index;
            this.updateShownFunction();
            this.focusCursorOnOutputIfOutputIsEditable();
        }

        /**
            Focus the cursor on the output if the output is editable.
            @method focusCursorOnOutputIfOutputIsEditable
            @return {Boolean} Whether the output was editable.
        */

    }, {
        key: 'focusCursorOnOutputIfOutputIsEditable',
        value: function focusCursorOnOutputIfOutputIsEditable() {
            if (this.isOutputEditable) {
                var functionIndexToFocus = this.isPseudocodeCurrentlyShown ? 0 : this.currentlyShownFunctionIndex;

                this.$functionContainers.eq(functionIndexToFocus).find('.console').focus();
            }

            return this.isOutputEditable;
        }

        /**
            Enter the execution.
            @method enterExecution
            @return {Boolean} Whether the execution was able to be entered.
        */

    }, {
        key: 'enterExecution',
        value: function enterExecution() {
            var hadErrorCompiling = this.hadErrorCompiling();

            if (!hadErrorCompiling) {
                this.isInExecuteMode = true;
                this.isPseudocodeCurrentlyEditable = false;
                this.isSegmentedFunctionControlEnabled = false;
                this.executor.enterExecution();
                this.getTopOfStack().node.isNextToExecute = true;
                this.currentlyShownFunctionIndex = 0;
            }
            this.render();

            return !hadErrorCompiling;
        }

        /**
            Exit the execution.
            @method exitExecution
            @return {void}
        */

    }, {
        key: 'exitExecution',
        value: function exitExecution() {
            this.isInExecuteMode = false;
            this.isPseudocodeCurrentlyEditable = this.isPseudocodeEditable;
            this.isSegmentedFunctionControlEnabled = true;
            this.lastFunctionOnStack = null;
            this.executor.exitExecution();
            this.render();
        }

        /**
            Start the execution from the beginning.
            @method restartExecution
            @return {void}
        */

    }, {
        key: 'restartExecution',
        value: function restartExecution() {
            this.exitExecution();
            this.enterExecution();
        }

        /**
            Execute the next node.
            @method executeOnce
            @param {Boolean} [doNotRerender=false] Do not re-render the program.
            @return {void}
        */

    }, {
        key: 'executeOnce',
        value: function executeOnce() {
            var doNotRerender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            this.getTopOfStack().node.isNextToExecute = false;
            this.lastFunctionOnStack = this.executor.execute() || this.lastFunctionOnStack;

            if (this.isExecutionDone()) {
                this.currentlyShownFunctionIndex = 0;
            }

            // If there is a next node, then mark it as such.
            else {
                    var topOfStack = this.getTopOfStack();
                    var functionNames = this.executor.program.functions.map(function (programFunction) {
                        return programFunction.name;
                    });

                    topOfStack.node.isNextToExecute = true;
                    this.currentlyShownFunctionIndex = functionNames.indexOf(topOfStack.function.name);
                }

            if (!doNotRerender) {
                this.render();
            }
        }

        /**
            Return whether there was an error compiling the pseudocode.
            @method hadErrorCompiling
            @return {Boolean} Whether there was an error compiling the pseudocode.
        */

    }, {
        key: 'hadErrorCompiling',
        value: function hadErrorCompiling() {
            var updatedCode = this.getPseudocode();

            // Update the restricted code if applicable to keep the executor's code and restricted code in sync.
            if (this.isPseudocodeEditingRestricted) {
                var firstIndexOfPlaceholder = this.restrictedCode.pre.length;
                var firstIndexOfPost = updatedCode.length - this.restrictedCode.post.length;

                this.restrictedCode.placeholder = updatedCode.substring(firstIndexOfPlaceholder, firstIndexOfPost);
            }

            this.errorMessage = null;
            this.errorLineNumber = null;

            try {
                this.executor.setProgramAndCodeFromCode(updatedCode);
            } catch (error) {
                if (this.compilationErrorCallback) {
                    this.compilationErrorCallback(error.message);
                }

                // Since there's an error in the pseudocode, show the error message and stay in pseudocode.
                this.errorMessage = error.message;
                this.errorLineNumber = error.lineNumber;
                return true;
            }

            return false;
        }

        /**
            Return the element at the top of the execution stack.
            @method getTopOfStack
            @return {ExecutionStackElement} The element at the top of the execution stack.
        */

    }, {
        key: 'getTopOfStack',
        value: function getTopOfStack() {
            return this.executor.stack[this.executor.stack.length - 1];
        }

        /**
            Get the latest pseudocode.
            @method getPseudocode
            @return {String} The latest pseudocode.
        */

    }, {
        key: 'getPseudocode',
        value: function getPseudocode() {

            // If controllers have been built, then get the code from the controllers. Otherwise, get the code from the executor.
            return this.functionControllers.length ? this.functionControllers[0].getPseudocode() : this.executor.code;
        }

        /**
            Return whether there are any nodes left to execute.
            @method isExecutionDone
            @return {Boolean} Whether there are any nodes left to execute.
        */

    }, {
        key: 'isExecutionDone',
        value: function isExecutionDone() {
            return this.executor.isExecutionDone();
        }

        /**
            Set whether to render in compact mode.
            @method setIsCompact
            @param {Boolean} isCompact Whether to use compact mode.
            @param {Number} [maxHeight=null] The max height to set. Required in compact mode.
            @param {Number} [maxWidth=null] The max width to set. Required in compact mode.
            @return {void}
        */

    }, {
        key: 'setIsCompact',
        value: function setIsCompact(isCompact) {
            var maxHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            this.isCompact = isCompact;
            this.showFunctionName = !isCompact;
            this.maxHeight = maxHeight;
            this.maxWidth = maxWidth;
        }

        /**
            Set whether to make the output editable.
            @method setIsOutputEditable
            @param {Boolean} isOutputEditable Whether to make the output editable.
            @param {Function} [outputChangeFunction=null] A function to call when the output changes.
            @return {void}
        */

    }, {
        key: 'setIsOutputEditable',
        value: function setIsOutputEditable(isOutputEditable) {
            var outputChangeFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            this.isOutputEditable = isOutputEditable;
            this.outputChangeFunction = outputChangeFunction;
        }

        /**
            Set whether to make the input editable.
            @method setIsInputEditable
            @param {Boolean} isInputEditable Whether to make the input editable.
            @return {void}
        */

    }, {
        key: 'setIsInputEditable',
        value: function setIsInputEditable(isInputEditable) {
            this.isInputEditable = isInputEditable;
        }

        /**
            Set the value of |this.languagesToShow|.
            @method setLanguagesToShow
            @param {String} languagesToShow The value to set.
            @return {void}
        */

    }, {
        key: 'setLanguagesToShow',
        value: function setLanguagesToShow(languagesToShow) {
            this.languagesToShow = languagesToShow;

            var isPseudocodeIncluded = ['pseudocode', 'both'].indexOf(this.languagesToShow) !== -1;

            this.isPseudocodeCurrentlyShown = isPseudocodeIncluded;

            // Make a reference to a PseudocodeController that will be used for this executor.
            if (isPseudocodeIncluded && !this.pseudocodeController) {
                this.pseudocodeController = new PseudocodeController(this.executor.code);
            }
        }

        /**
            Set whether the pseudocode should be editable.
            @method setIsPseudocodeEditable
            @param {Boolean} isPseudocodeEditable Whether the pseudocode should be editable.
            @return {void}
        */

    }, {
        key: 'setIsPseudocodeEditable',
        value: function setIsPseudocodeEditable(isPseudocodeEditable) {
            var _this5 = this;

            this.isPseudocodeEditable = isPseudocodeEditable;
            this.isPseudocodeCurrentlyEditable = this.isPseudocodeEditable && !this.isInExecuteMode;
            this.functionControllers.forEach(function (controller) {
                return controller.setIsPseudocodeEditable(_this5.isPseudocodeCurrentlyEditable);
            });
        }

        /**
            Set whether the pseudocode editing should be restricted.
            @method setIsPseudocodeEditingRestricted
            @param {Boolean} isPseudocodeEditingRestricted Whether the pseudocode editing should be restricted.
            @param {String} [pre=null] The uneditable code before the placeholder code.
            @param {String} [placeholder=null] The editable code.
            @param {String} [post=null] The uneditable code after the placeholder code.
            @return {void}
        */

    }, {
        key: 'setIsPseudocodeEditingRestricted',
        value: function setIsPseudocodeEditingRestricted(isPseudocodeEditingRestricted) {
            var pre = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var placeholder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var post = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

            this.isPseudocodeEditingRestricted = isPseudocodeEditingRestricted;
            this.restrictedCode = isPseudocodeEditingRestricted ? new RestrictedCode(pre, placeholder, post) : null;
        }

        /**
            Set whether to make the segmented language control enabled.
            @method setIsSegmentedLanguageControlEnabled
            @param {Boolean} isSegmentedLanguageControlEnabled Whether to make the segmented language control enabled.
            @return {void}
        */

    }, {
        key: 'setIsSegmentedLanguageControlEnabled',
        value: function setIsSegmentedLanguageControlEnabled(isSegmentedLanguageControlEnabled) {
            this.isSegmentedLanguageControlEnabled = isSegmentedLanguageControlEnabled;

            // Update the segmented control if it exists.
            if (this.segmentedLanguageControl) {
                if (isSegmentedLanguageControlEnabled) {
                    this.segmentedLanguageControl.enable();
                } else {
                    this.segmentedLanguageControl.disable();
                }
            }
        }

        /**
            Set the function to call when a compilation error occurs.
            @method setCompilationErrorCallback
            @param {Function} compilationErrorCallback The function to call when a compilation error occurs.
            @return {void}
        */

    }, {
        key: 'setCompilationErrorCallback',
        value: function setCompilationErrorCallback(compilationErrorCallback) {
            this.compilationErrorCallback = compilationErrorCallback;
        }

        /**
            Put the browser's focus on the currently shown function.
            @method focusOnFunction
            @return {void}
        */

    }, {
        key: 'focusOnFunction',
        value: function focusOnFunction() {
            if (this.functionControllers.length) {
                var indexToFocus = this.isPseudocodeCurrentlyShown ? 0 : this.currentlyShownFunctionIndex;

                this.functionControllers[indexToFocus].focus();
            }
        }
    }]);

    return ExecutorController;
}();

'use strict';

/* exported FlowchartController */
/* global Raphael, StraightVerticalEdgeController, SelfLoopEdgeController,
          NodeBackToLoopEdgeController, FirstChildOfIfElseFalseBranchEdgeController, RenderingIndicatorFactory,
          PointController, RenderingIndicatorAndControllerPair, StraightHorizontalEdgeController,
          MergeTrueToMergeFalseEdgeController, PointToNodeEdgeController, PointToPointEdgeController,
          MergeFalseToMergeFalseEdgeController, LoopNodeToPointEdgeController, BackToLoopToMergeFalseEdgeController,
          PointBackToLoopNodeEdgeController, NodeControllerFactory, globalConstants, FunctionCodeController */

/**
    Render and control a flowchart.
    @class FlowchartController
    @extends FunctionCodeController
*/

var FlowchartController = function (_FunctionCodeControll) {
    _inherits(FlowchartController, _FunctionCodeControll);

    /**
        @constructor
        @param {Flowchart} flowchart The flowchart to render and control.
        @param {Object} $containerDOM jQuery reference to the container for the controller.
    */
    function FlowchartController(flowchart, $containerDOM) {
        _classCallCheck(this, FlowchartController);

        /**
            The flowchart to render and control.
            @property flowchart
            @type {Flowchart}
        */
        var _this6 = _possibleConstructorReturn(this, (FlowchartController.__proto__ || Object.getPrototypeOf(FlowchartController)).call(this, $containerDOM));

        _this6.flowchart = flowchart;

        /**
            List of node and point controllers in this flowchart paired with the respective indicator.
            @property renderingIndicatorAndControllerPairs
            @type {Array} of {RenderingIndicatorAndControllerPair}
            @default []
        */
        _this6.renderingIndicatorAndControllerPairs = [];

        /**
            List of edge controllers in this flowchart.
            @property edgeControllers
            @type {Array} of {FlowchartEdgeController}
            @default []
        */
        _this6.edgeControllers = [];

        /**
            The canvas on which the flowchart is drawn.
            @property canvas
            @type {Raphael}
            @default null
        */
        _this6.canvas = null;
        return _this6;
    }

    /**
        Render the flowchart.
        @method render
        @return {void}
    */


    _createClass(FlowchartController, [{
        key: 'render',
        value: function render() {
            var _this7 = this;

            // Build the flowchart canvas.
            this.$containerDOM.html(globalConstants.templates.flowchart());

            var container = this.$containerDOM.children('.flowchart-canvas').get(0);

            this.canvas = Raphael(container, 0, 0); // eslint-disable-line new-cap

            // Build the rendering indicator list.
            var renderingIndicatorFactory = new RenderingIndicatorFactory();
            var renderingIndicators = renderingIndicatorFactory.make(this.flowchart);

            // Create the node and point controllers.
            renderingIndicators.forEach(function (indicator) {
                var controller = null;

                switch (indicator.getName()) {
                    case 'NodeRenderingIndicator':
                        {
                            var nodeControllerFactory = new NodeControllerFactory();

                            controller = nodeControllerFactory.make(indicator.node, _this7.canvas);
                            break;
                        }

                    // From a MergeTrue, use the point indicator.
                    case 'MergeTrueRenderingIndicator':
                        controller = new PointController(_this7.canvas, indicator);
                        break;

                    // Do nothing for MergeFalse and BackToLoop.
                    case 'MergeFalseRenderingIndicator':
                    case 'BackToLoopRenderingIndicator':
                        break;

                    default:
                        throw new Error('FlowchartController\'s render function has unrecognized rendering indicator');
                }

                if (controller) {
                    _this7.renderingIndicatorAndControllerPairs.push(new RenderingIndicatorAndControllerPair(indicator, controller));
                }
            });

            // Render each node and point.
            this.renderingIndicatorAndControllerPairs.forEach(function (pair) {
                pair.controller.render();
            });

            // Move each node and point into x position by column.
            var maxColumnIndex = Math.max.apply(Math, _toConsumableArray(this.renderingIndicatorAndControllerPairs.map(function (pair) {
                return pair.indicator.column;
            })));
            var columnIndices = require('utilities').createArrayOfSizeN(maxColumnIndex + 1).map(function (value, index) {
                return index;
            });
            var columnStartX = 0;

            columnIndices.forEach(function (columnIndex) {

                // Find the largest width of the controllers for this column.
                var controllersThisColumn = _this7.renderingIndicatorAndControllerPairs.filter(function (pair) {
                    return pair.indicator.column === columnIndex;
                }).map(function (pair) {
                    return pair.controller;
                });
                var widestWidth = Math.max.apply(Math, _toConsumableArray(controllersThisColumn.map(function (controller) {
                    return controller.getWidth();
                })));

                // Move drawings into place.
                controllersThisColumn.forEach(function (controller) {
                    var xCoordinate = Math.max((widestWidth - controller.getWidth()) / 2, 1); // eslint-disable-line no-magic-numbers

                    controller.drawing.translate(columnStartX + xCoordinate, 0);
                });

                // Calculate the start x of the next column.
                columnStartX = columnStartX + widestWidth + globalConstants.spaceBetweenColumns;
            });

            // Move each node and point into y position by row.
            var maxRowIndex = Math.max.apply(Math, _toConsumableArray(this.renderingIndicatorAndControllerPairs.map(function (pair) {
                return pair.indicator.row;
            })));
            var rowIndices = require('utilities').createArrayOfSizeN(maxRowIndex + 1).map(function (value, index) {
                return index;
            });
            var rowStartY = 0;

            rowIndices.forEach(function (rowIndex) {

                // Find the largest height of the controllers for this row.
                var controllersThisRow = _this7.renderingIndicatorAndControllerPairs.filter(function (pair) {
                    return pair.indicator.row === rowIndex;
                }).map(function (pair) {
                    return pair.controller;
                });
                var largestHeight = Math.max.apply(Math, _toConsumableArray(controllersThisRow.map(function (controller) {
                    return controller.getHeight();
                })).concat([0]));

                // Move drawings into place.
                controllersThisRow.forEach(function (controller) {
                    var yCoordinate = Math.max((largestHeight - controller.getHeight()) / 2, 1); // eslint-disable-line no-magic-numbers

                    controller.drawing.translate(0, rowStartY + yCoordinate);
                });

                // Calculate the start y of the next row.
                rowStartY = rowStartY + largestHeight + globalConstants.spaceBetweenRows;
            });

            // Add edges between nodes.
            renderingIndicators.forEach(function (indicator, index) {
                var previousIndicator = renderingIndicators[index - 1];

                if (previousIndicator) {
                    var indicatorTypeToMakeFunction = {
                        NodeRenderingIndicator: _this7.makeEdgeControllerForNodeRenderingIndicator,
                        BackToLoopRenderingIndicator: _this7.makeEdgeControllerForBackToLoopIndicator,
                        MergeTrueRenderingIndicator: _this7.makeEdgeControllerForMergeTrueIndicator,
                        MergeFalseRenderingIndicator: _this7.makeEdgeControllerForMergeFalseIndicator
                    };
                    var previousIndicatorType = previousIndicator.getName();
                    var edgeController = indicatorTypeToMakeFunction[previousIndicatorType].call(_this7, previousIndicator, indicator, _this7.canvas, renderingIndicators);

                    if (edgeController) {
                        edgeController.render();
                        _this7.edgeControllers.push(edgeController);
                    }
                }
            });

            // Find right-position of the controller that goes right-most.
            var maxEdgeRight = this.edgeControllers.map(function (edgeController) {
                return edgeController.getRight();
            });
            var maxIndicatorRight = this.renderingIndicatorAndControllerPairs.map(function (pair) {
                return pair.controller.getRight();
            });
            var width = Math.max.apply(Math, _toConsumableArray(maxEdgeRight).concat(_toConsumableArray(maxIndicatorRight))) + 1;

            // Find bottom-position of the controller that goes bottom-most.
            var maxEdgeBottom = this.edgeControllers.map(function (edgeController) {
                return edgeController.getBottom();
            });
            var maxIndicatorBottom = this.renderingIndicatorAndControllerPairs.map(function (pair) {
                return pair.controller.getBottom();
            });
            var height = Math.max.apply(Math, _toConsumableArray(maxEdgeBottom).concat(_toConsumableArray(maxIndicatorBottom))) + 1;

            // Update flowchart canvas with actual height and width.
            this.canvas.setSize(width, height);
        }

        /**
            Ensure the showing of the node that is next to execute.
            @method showNextToExecuteNode
            @param {FlowchartNode} nextNodeToExecute The next node to execute.
            @return {void}
        */

    }, {
        key: 'showNextToExecuteNode',
        value: function showNextToExecuteNode(nextNodeToExecute) {
            var nodePairs = this.renderingIndicatorAndControllerPairs.filter(function (pair) {
                return pair.controller.node;
            });
            var nextNodePair = nodePairs.find(function (pair) {
                return pair.controller.node === nextNodeToExecute;
            });

            if (nextNodePair) {
                var nextNodeRow = nextNodePair.indicator.row;
                var nextNodeColumn = nextNodePair.indicator.column;
                var maxNodeRow = Math.max.apply(Math, _toConsumableArray(nodePairs.map(function (pair) {
                    return pair.indicator.row;
                })));
                var maxNodeColumn = Math.max.apply(Math, _toConsumableArray(nodePairs.map(function (pair) {
                    return pair.indicator.column;
                })));
                var $container = this.$containerDOM.children('.flowchart-canvas');
                var offset = 5;
                var scrollLeft = $container.scrollLeft();
                var scrollTop = $container.scrollTop();

                // If the node is in the first column, then scroll all the way left.
                if (nextNodeColumn === 0) {
                    scrollLeft = 0;
                }

                // If the node is in the last column, then scroll all the way right.
                else if (nextNodeColumn === maxNodeColumn) {
                        scrollLeft = $container.width();
                    }

                    // Otherwise, scroll the least amount to ensure the node is fully visible horizontally.
                    else {

                            // Find nodes in same column.
                            var controllersInSameColumn = this.renderingIndicatorAndControllerPairs.filter(function (pair) {
                                return pair.indicator.column === nextNodeColumn;
                            }).map(function (pair) {
                                return pair.controller;
                            });

                            var nodeLeft = Math.min.apply(Math, _toConsumableArray(controllersInSameColumn.map(function (controller) {
                                return controller.getLeft();
                            }))) - offset;
                            var nodeRight = Math.max.apply(Math, _toConsumableArray(controllersInSameColumn.map(function (controller) {
                                return controller.getRight();
                            }))) + offset;
                            var containerLeft = $container.scrollLeft();
                            var containerRight = containerLeft + $container.width();

                            // Determine the amount needed to scroll left, so that the node is shown.
                            if (nodeLeft < containerLeft) {
                                scrollLeft = nodeLeft;
                            }

                            // Determine the amount needed to scroll right, so that the node is shown.
                            else if (nodeRight > containerRight) {
                                    scrollLeft = containerLeft + (nodeRight - containerRight);
                                }
                        }

                // If the node is in the first row, then scroll all the way up.
                if (nextNodeRow === 0) {
                    scrollTop = 0;
                }

                // If the node is in the last row, then scroll all the way down.
                else if (nextNodeRow === maxNodeRow) {
                        scrollTop = $container.height();
                    }

                    // Otherwise, scroll the least amount to ensure the node is fully visible vertically.
                    else {

                            // Find nodes in same row.
                            var controllersInSameRow = this.renderingIndicatorAndControllerPairs.filter(function (pair) {
                                return pair.indicator.row === nextNodeRow;
                            }).map(function (pair) {
                                return pair.controller;
                            });

                            // Compute the node and container top and bottom properties.
                            var nodeTop = Math.min.apply(Math, _toConsumableArray(controllersInSameRow.map(function (controller) {
                                return controller.getTop();
                            }))) - offset;
                            var nodeBottom = Math.max.apply(Math, _toConsumableArray(controllersInSameRow.map(function (controller) {
                                return controller.getBottom();
                            }))) + offset;
                            var containerTop = $container.scrollTop();
                            var containerBottom = containerTop + $container.height();

                            // Determine the amount needed to scroll up, so that the node is shown.
                            if (nodeTop < containerTop) {
                                scrollTop = nodeTop;
                            }

                            // Determine the amount needed to scroll down, so that the node is shown.
                            else if (nodeBottom > containerBottom) {
                                    scrollTop = containerTop + (nodeBottom - containerBottom);
                                }
                        }

                // Animate scrolling.
                $container.stop().animate({ scrollTop: scrollTop, scrollLeft: scrollLeft });
            }
        }

        /**
            Return the amount of horizontal scroll of the flowchart in the function container.
            @method getHorizontalScroll
            @return {Number} The amount of horizontal scroll of the flowchart in the function container.
        */

    }, {
        key: 'getHorizontalScroll',
        value: function getHorizontalScroll() {
            return this.$containerDOM.children('.flowchart-canvas').scrollLeft();
        }

        /**
            Return the amount of vertical scroll of the flowchart in the function container.
            @method getVerticalScroll
            @return {Number} The amount of vertical scroll of the flowchart in the function container.
        */

    }, {
        key: 'getVerticalScroll',
        value: function getVerticalScroll() {
            return this.$containerDOM.children('.flowchart-canvas').scrollTop();
        }

        /**
            Set the amount of horizontal scroll of the flowchart.
            @method setHorizontalScroll
            @param {Number} amount The amount to set.
            @return {void}
        */

    }, {
        key: 'setHorizontalScroll',
        value: function setHorizontalScroll(amount) {
            this.$containerDOM.children('.flowchart-canvas').scrollLeft(amount);
        }

        /**
            Set the amount of vertical scroll of the flowchart.
            @method setVerticalScroll
            @param {Number} amount The amount to set.
            @return {void}
        */

    }, {
        key: 'setVerticalScroll',
        value: function setVerticalScroll(amount) {
            this.$containerDOM.children('.flowchart-canvas').scrollTop(amount);
        }

        /**
            Get the height of this function's code.
            @method getHeight
            @return {Number} The height of the function's code.
        */

    }, {
        key: 'getHeight',
        value: function getHeight() {
            return this.canvas.canvas.getBoundingClientRect().height;
        }

        /**
            Get the width of this function's code.
            @method getWidth
            @return {Number} The width of the function's code.
        */

    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this.canvas.canvas.getBoundingClientRect().width;
        }

        /**
            Make an edge controller based on the previous indicator being a node indicator.
            @param {BackToLoopRenderingIndicator} previousIndicator The indicator saying to create an edge to a node.
            @param {RenderingIndicator} indicator The indicator after |previousIndicator|.
            @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
            @return {void}
        */

    }, {
        key: 'makeEdgeControllerForNodeRenderingIndicator',
        value: function makeEdgeControllerForNodeRenderingIndicator(previousIndicator, indicator, canvas) {
            var previousNodeController = this.findNodeControllerFromNode(previousIndicator.node);
            var edgeController = null;

            /*
                Each edge is documented in the table in: zyFlowchartSDK/FlowchartRenderingEngine_README.md
                Each "Between #" below is associated with the respective "Between #" in the table.
            */
            switch (indicator.getName()) {
                case 'NodeRenderingIndicator':
                    {
                        var indicatorNodeController = this.findNodeControllerFromNode(indicator.node);

                        // Between #1.
                        if (['LoopNode', 'IfNode', 'ElseIfNode'].indexOf(previousIndicator.node.getName()) >= 0) {
                            edgeController = new StraightHorizontalEdgeController(canvas, previousNodeController, indicatorNodeController, 'true');
                        }

                        // Between #2.
                        else {
                                edgeController = new StraightVerticalEdgeController(canvas, previousNodeController, indicatorNodeController);
                            }
                        break;
                    }

                case 'BackToLoopRenderingIndicator':
                    {

                        // Between #3.
                        if (previousIndicator.node.getName() === 'LoopNode') {
                            edgeController = new SelfLoopEdgeController(canvas, previousNodeController);
                        }

                        // Between #4.
                        else {
                                var loopNodeController = this.findNodeControllerFromNode(indicator.loopNode);

                                edgeController = new NodeBackToLoopEdgeController(canvas, previousNodeController, loopNodeController);
                            }
                        break;
                    }

                // Between #5-7.
                case 'MergeTrueRenderingIndicator':
                case 'MergeFalseRenderingIndicator':
                    {
                        var isIndicatorMergeTrue = indicator.getName() === 'MergeTrueRenderingIndicator';
                        var isPreviousIfElseIf = ['IfNode', 'ElseIfNode'].indexOf(previousIndicator.node.getName()) !== -1;
                        var edgeText = isIndicatorMergeTrue && isPreviousIfElseIf ? 'true' : '';
                        var pointController = this.findPointControllerFromIndicator(indicator);

                        edgeController = new StraightHorizontalEdgeController(canvas, previousNodeController, pointController, edgeText);
                        break;
                    }

                default:
                    throw new Error('Undefined indicator when trying to create edge controller in makeEdgeControllerForNodeRenderingIndicator');
            }

            return edgeController;
        }

        /**
            Create an edge controller for a back to loop indicator.
            @method makeEdgeControllerForBackToLoopIndicator
            @param {BackToLoopRenderingIndicator} previousIndicator The indicator saying to create an edge back to a loop node.
            @param {RenderingIndicator} indicator The indicator after |previousIndicator|.
            @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
            @param {Array} renderingIndicators Array of {RenderingIndicator}. The list of rendering indicators.
            @return {void}
        */

    }, {
        key: 'makeEdgeControllerForBackToLoopIndicator',
        value: function makeEdgeControllerForBackToLoopIndicator(previousIndicator, indicator, canvas, renderingIndicators) {
            var previousLoopNodeController = this.findNodeControllerFromNode(previousIndicator.loopNode);
            var edgeController = null;

            /*
                Each edge is documented in the table in: zyFlowchartSDK/FlowchartRenderingEngine_README.md
                Each "Between #" below is associated with the respective "Between #" in the table.
            */
            switch (indicator.getName()) {

                // Between #8.
                case 'NodeRenderingIndicator':
                    {
                        var indicatorNodeController = this.findNodeControllerFromNode(indicator.node);

                        edgeController = new StraightVerticalEdgeController(canvas, previousLoopNodeController, indicatorNodeController, 'false');
                        break;
                    }

                // Between #9.
                case 'BackToLoopRenderingIndicator':
                    {
                        var loopNodeController = this.findNodeControllerFromNode(indicator.loopNode);

                        edgeController = new NodeBackToLoopEdgeController(canvas, previousLoopNodeController, loopNodeController, 'false');
                        break;
                    }

                // Between #10.
                case 'MergeTrueRenderingIndicator':
                    {
                        var pointerController = this.findPointControllerFromIndicator(indicator);

                        edgeController = new LoopNodeToPointEdgeController(canvas, previousLoopNodeController, pointerController);
                        break;
                    }

                // Between #11.
                case 'MergeFalseRenderingIndicator':
                    {
                        var pointController = this.findPointControllerFromIndicator(indicator);

                        // Get the largest bottom of existing edges, so this edge goes downward enough.
                        var largestBottomYOfPreviousEdges = Math.max.apply(Math, _toConsumableArray(this.edgeControllers.map(function (controller) {
                            return controller.getBottom();
                        })));
                        var pointY = this.computeNextPointY(indicator, renderingIndicators);

                        edgeController = new BackToLoopToMergeFalseEdgeController(canvas, previousLoopNodeController, pointController, largestBottomYOfPreviousEdges, pointY);
                        break;
                    }

                default:
                    throw new Error('Undefined indicator when trying to create edge controller in makeEdgeControllerForBackToLoopIndicator');
            }

            return edgeController;
        }

        /**
            Create an edge controller for a merge true rendering indicator.
            @method makeEdgeControllerForMergeTrueIndicator
            @param {BackToLoopRenderingIndicator} previousIndicator The indicator saying a merge true just happened.
            @param {RenderingIndicator} indicator The indicator after |previousIndicator|.
            @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
            @param {Array} renderingIndicators Array of {RenderingIndicator}. The list of rendering indicators.
            @return {void}
        */

    }, {
        key: 'makeEdgeControllerForMergeTrueIndicator',
        value: function makeEdgeControllerForMergeTrueIndicator(previousIndicator, indicator, canvas, renderingIndicators) {
            var edgeController = null;

            /*
                Each edge is documented in the table in: zyFlowchartSDK/FlowchartRenderingEngine_README.md
                Each "Between #" below is associated with the respective "Between #" in the table.
            */
            switch (indicator.getName()) {
                case 'NodeRenderingIndicator':
                    {
                        var ifElseController = this.findNodeControllerFromNode(previousIndicator.ifElseIfNode);
                        var indicatorNodeController = this.findNodeControllerFromNode(indicator.node);

                        // Between #12.
                        if (indicator.node.getName() === 'ElseIfNode') {
                            edgeController = new StraightVerticalEdgeController(canvas, ifElseController, indicatorNodeController, 'false');
                        }

                        // Between #13.
                        else {
                                edgeController = new FirstChildOfIfElseFalseBranchEdgeController(canvas, ifElseController, indicatorNodeController);
                            }
                        break;
                    }

                // Between #14. Since this ordering is not possible, throw an error.
                case 'BackToLoopRenderingIndicator':
                    throw new Error('Invalid indicator ordering: MergeTrue -> BackToLoop');

                // Between #15. Since this ordering is not possible, throw an error.
                case 'MergeTrueRenderingIndicator':
                    throw new Error('Invalid indicator ordering: MergeTrue -> MergeTrue');

                // Between #16.
                case 'MergeFalseRenderingIndicator':
                    {
                        var _ifElseController = this.findNodeControllerFromNode(previousIndicator.ifElseIfNode);
                        var pointController = this.findPointControllerFromIndicator(indicator);
                        var allControllersWithSameRowIndex = this.renderingIndicatorAndControllerPairs.filter(function (pair) {
                            return pair.indicator.row === previousIndicator.row;
                        }).map(function (pair) {
                            return pair.controller;
                        });
                        var largestBottomOfRow = Math.max.apply(Math, _toConsumableArray(allControllersWithSameRowIndex.map(function (controller) {
                            return controller.getBottom();
                        })));
                        var pointY = this.computeNextPointY(indicator, renderingIndicators);

                        edgeController = new MergeTrueToMergeFalseEdgeController(canvas, _ifElseController, pointController, largestBottomOfRow, pointY);
                        break;
                    }

                default:
                    throw new Error('Undefined indicator when trying to create edge controller in makeEdgeControllerForMergeTrueIndicator');
            }

            return edgeController;
        }

        /**
            Create an edge controller for a merge false rendering indicator.
            @method makeEdgeControllerForMergeFalseIndicator
            @param {BackToLoopRenderingIndicator} previousIndicator The indicator saying a merge false just happened.
            @param {RenderingIndicator} indicator The indicator after |previousIndicator|.
            @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
            @return {void}
        */

    }, {
        key: 'makeEdgeControllerForMergeFalseIndicator',
        value: function makeEdgeControllerForMergeFalseIndicator(previousIndicator, indicator, canvas) {
            var edgeController = null;

            /*
                Each edge is documented in the table in: zyFlowchartSDK/FlowchartRenderingEngine_README.md
                Each "Between #" below is associated with the respective "Between #" in the table.
            */
            switch (indicator.getName()) {
                case 'NodeRenderingIndicator':
                    {

                        // Between #17.
                        if (previousIndicator.ifElseIfNode.getName() === 'IfNode') {
                            var pointController = this.findPointControllerFromIndicator(previousIndicator);
                            var nodeController = this.findNodeControllerFromNode(indicator.node);

                            edgeController = new PointToNodeEdgeController(canvas, pointController, nodeController);
                        }

                        // Between #18.
                        else {

                                // Do nothing.
                            }
                        break;
                    }

                case 'BackToLoopRenderingIndicator':
                    {

                        // Between #19.
                        if (previousIndicator.ifElseIfNode.getName() === 'IfNode') {
                            var _pointController = this.findPointControllerFromIndicator(previousIndicator);
                            var loopNodeController = this.findNodeControllerFromNode(indicator.loopNode);
                            var nodeBeforeLoopController = this.findNodeControllerFromNode(indicator.nodeBeforeLoopNode);
                            var previousEdgeController = this.edgeControllers[this.edgeControllers.length - 1];

                            edgeController = new PointBackToLoopNodeEdgeController(canvas, _pointController, loopNodeController, nodeBeforeLoopController, previousEdgeController);
                        }

                        // Between #20.
                        else {

                                // Do nothing.
                            }
                        break;
                    }

                case 'MergeTrueRenderingIndicator':
                    {

                        // Between #21. Since this ordering is not possible, throw an error.
                        if (previousIndicator.ifElseIfNode === indicator.ifElseIfNode) {
                            throw new Error('Invalid indicator ordering: MergeFalse -> MergeTrue for the same node');
                        }

                        // Between #22.
                        else if (previousIndicator.ifElseIfNode.getName() === 'IfNode') {
                                var startPointerController = this.findPointControllerFromIndicator(previousIndicator);
                                var endPointController = this.findPointControllerFromIndicator(indicator);

                                edgeController = new PointToPointEdgeController(canvas, startPointerController, endPointController);
                            }

                            // Between #23. Since this ordering is not possible, throw an error.
                            else {
                                    throw new Error('Invalid indicator ordering: MergeFalse (elseif) -> MergeTrue');
                                }
                        break;
                    }

                case 'MergeFalseRenderingIndicator':
                    {

                        // Between #24.
                        if (previousIndicator.ifElseIfNode.getName() === 'IfNode') {
                            var _startPointerController = this.findPointControllerFromIndicator(previousIndicator);
                            var _endPointController = this.findPointControllerFromIndicator(indicator);

                            // Get the bottom of the previous edge, so this edge goes downward enough.
                            var _previousEdgeController = this.edgeControllers[this.edgeControllers.length - 1];
                            var bottomYOfPreviousEdge = _previousEdgeController.getBottom();

                            edgeController = new MergeFalseToMergeFalseEdgeController(canvas, _startPointerController, _endPointController, bottomYOfPreviousEdge);
                        }

                        // Between #25.
                        else {

                                // Do nothing.
                            }
                        break;
                    }

                default:
                    throw new Error('Undefined indicator when trying to create edge controller in makeEdgeControllerForMergeFalseIndicator');
            }

            return edgeController;
        }

        /**
            Get the y-axis location of the next point, if it exists. Else, return null.
            @method computeNextPointY
            @param {RenderingIndicator} indicator The indicator after |previousIndicator|.
            @param {Array} renderingIndicators Array of {RenderingIndicator}. The list of rendering indicators.
            @return {Number} The y-axis location of the next point, if it exists.
        */

    }, {
        key: 'computeNextPointY',
        value: function computeNextPointY(indicator, renderingIndicators) {
            var indexAfterMergeFalse = renderingIndicators.indexOf(indicator) + 1;
            var indicatorAfterMergeFalse = renderingIndicators[indexAfterMergeFalse];
            var isNextIndicatorMergeTrue = indicatorAfterMergeFalse && indicatorAfterMergeFalse.getName() === 'MergeTrueRenderingIndicator';

            return isNextIndicatorMergeTrue ? this.findPointControllerFromIndicator(indicatorAfterMergeFalse).getVerticalCenter() : null;
        }

        /**
            Return the node controller for the given node.
            @method findNodeControllerFromNode
            @param {FlowchartNode} node The node's controller to find.
            @return {FlowchartNodeController} The node controller for the given node.
        */

    }, {
        key: 'findNodeControllerFromNode',
        value: function findNodeControllerFromNode(node) {
            return this.renderingIndicatorAndControllerPairs.find(function (pair) {
                return pair.controller.node === node;
            }).controller;
        }

        /**
            Return the point controller for the given merge indicator.
            Point controller are associated with a MergeTrue indicator.
            The given |mergeIndicator| may be a MergeFalse, so match on |ifElseIfNode| to find the associated MergeTrue.
            @method findPointControllerFromIndicator
            @param {MergeRenderingIndicator} mergeIndicator The indicator's controller to find.
            @return {PointController} The point controller for the given merge indicator.
        */

    }, {
        key: 'findPointControllerFromIndicator',
        value: function findPointControllerFromIndicator(mergeIndicator) {
            return this.renderingIndicatorAndControllerPairs.find(function (pair) {
                return pair.indicator.ifElseIfNode === mergeIndicator.ifElseIfNode;
            }).controller;
        }
    }]);

    return FlowchartController;
}(FunctionCodeController);

'use strict';

/* exported FlowchartElementController */

/**
    Abstract controller for an element of the flowchart.
    @class FlowchartElementController
*/

var FlowchartElementController = function () {

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function FlowchartElementController(canvas) {
        _classCallCheck(this, FlowchartElementController);

        /**
            Reference to the Raphael.js instance used to draw the flowchart.
            @property canvas
            @type {Object}
        */
        this.canvas = canvas;

        /**
            Reference to the drawing of the element on the canvas.
            @property drawing
            @type {Raphael.Set}
            @default []
        */
        this.drawing = canvas.set();
    }

    /**
        Render the element.
        @method render
        @return {void}
    */


    _createClass(FlowchartElementController, [{
        key: 'render',
        value: function render() {
            throw new Error('FlowchartElementController\'s render function should be overridden');
        }

        /**
            Return the y-position of the bottom of the element.
            @method getBottom
            @return {Number} The y-position of the bottom of the element.
        */

    }, {
        key: 'getBottom',
        value: function getBottom() {
            return Math.max.apply(Math, _toConsumableArray(this.drawing.items.map(function (item) {
                return item.getBBox().y + item.getBBox().height;
            }))); // eslint-disable-line id-length
        }

        /**
            Return the y-position of the top of the element.
            @method getTop
            @return {Number} The y-position of the top of the element.
        */

    }, {
        key: 'getTop',
        value: function getTop() {
            return Math.min.apply(Math, _toConsumableArray(this.drawing.items.map(function (item) {
                return item.getBBox().y;
            })));
        }

        /**
            Return the x-position of the left of the element.
            @method getLeft
            @return {Number} The x-position of the left of the element.
        */

    }, {
        key: 'getLeft',
        value: function getLeft() {
            return Math.min.apply(Math, _toConsumableArray(this.drawing.items.map(function (item) {
                return item.getBBox().x;
            })));
        }

        /**
            Return the x-position of the right of the element.
            @method getRight
            @return {Number} The x-position of the right of the element.
        */

    }, {
        key: 'getRight',
        value: function getRight() {
            return Math.max.apply(Math, _toConsumableArray(this.drawing.items.map(function (item) {
                return item.getBBox().x + item.getBBox().width;
            }))); // eslint-disable-line id-length
        }

        /**
            Return the x-position of the left of the element at vertical-center.
            Input and output nodes override this b/c the left-side wall is angled.
            @method getLeftAtVerticalCenter
            @return {Number} The x-position of the left of the element at vertical-center.
        */

    }, {
        key: 'getLeftAtVerticalCenter',
        value: function getLeftAtVerticalCenter() {
            return this.getLeft();
        }

        /**
            Return the x-position of the right of the element at vertical-center.
            Input and output nodes override this b/c the right-side wall is angled.
            @method getRightAtVerticalCenter
            @return {Number} The x-position of the right of the element at vertical-center.
        */

    }, {
        key: 'getRightAtVerticalCenter',
        value: function getRightAtVerticalCenter() {
            return this.getRight();
        }

        /**
            Return the center x-position of the element.
            @method getHorizontalCenter
            @return {Number} The center x-position of the element.
        */

    }, {
        key: 'getHorizontalCenter',
        value: function getHorizontalCenter() {

            /*
                Want halfway point between left-most x (leftX) and right-most x (rightX).
                That is, we want to go (rightX - leftX) / 2 beyond leftX, which is:
                leftX + ((rightX - leftX) / 2)
                (rightX / 2) + (leftX - (leftX / 2))
                (rightX / 2) + (leftX / 2)
                (rightX + leftX) / 2
            */
            return (this.getRight() + this.getLeft()) / 2; // eslint-disable-line no-magic-numbers
        }

        /**
            Return the center y-position of the element.
            @method getVerticalCenter
            @return {Number} The center x-position of the element.
        */

    }, {
        key: 'getVerticalCenter',
        value: function getVerticalCenter() {

            /*
                Want halfway point between top-most y (topY) and bottom-most y (bottomY).
                That is, we want to go (bottomY - topY) / 2 beyond topY, which is:
                topY + ((bottomY - topY) / 2)
                (bottomY / 2) +(topY - (topY / 2))
                (bottomY / 2) + (topY / 2)
                (bottomY + topY) / 2
            */
            return (this.getBottom() + this.getTop()) / 2; // eslint-disable-line no-magic-numbers
        }

        /**
            Get the width of the element.
            @method getWidth
            @return {Number} The width of the element.
        */

    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this.getRight() - this.getLeft();
        }

        /**
            Get the height of the element.
            @method getHeight
            @return {Number} The height of the element.
        */

    }, {
        key: 'getHeight',
        value: function getHeight() {
            return this.getBottom() - this.getTop();
        }
    }]);

    return FlowchartElementController;
}();

'use strict';

/* exported FunctionAndFlowchartScrollAmount */

/**
    An object storing a function and the associated flowchart's scroll amount.
    @class FunctionAndFlowchartScrollAmount
*/

var FunctionAndFlowchartScrollAmount =

/**
    @constructor
    @param {ProgramFunction} programFunction The function to control.
    @param {Number} horizontalScroll The amount of horizontal scroll.
    @param {Number} verticalScroll The amount of vertical scroll.
*/
function FunctionAndFlowchartScrollAmount(programFunction, horizontalScroll, verticalScroll) {
    _classCallCheck(this, FunctionAndFlowchartScrollAmount);

    /**
        The function to store.
        @property programFunction
        @type {ProgramFunction}
    */
    this.programFunction = programFunction;

    /**
        The amount of horizontal scroll.
        @property horizontalScroll
        @type {Number}
    */
    this.horizontalScroll = horizontalScroll;

    /**
        The amount of vertical scroll.
        @property verticalScroll
        @type {Number}
    */
    this.verticalScroll = verticalScroll;
};

'use strict';

/* exported FunctionController */
/* global FlowchartController, VariablesController globalConstants, NumericalInputComponentController, NumericalOutputComponentController,
   FunctionAndFlowchartScrollAmount */

/**
    Control a {ProgramFunction}. Optionally, also control the program's input and output.
    @class FunctionController
*/

var FunctionController = function () {

    /**
        @constructor
        @param {ProgramFunction} programFunction The function to control.
        @param {String} programCode The program's code.
        @param {Object} $containerDOM jQuery reference to the container for the controller.
        @param {NumericalInputComponent} input A numerical input component to render along with the function.
        @param {NumericalOutputComponent} output A numerical input component to render along with the function.
    */
    function FunctionController(programFunction, programCode, $containerDOM, input, output) {
        _classCallCheck(this, FunctionController);

        /**
            The function to control.
            @property programFunction
            @type {ProgramFunction}
        */
        this.programFunction = programFunction;

        /**
            The program's code, displayed when pseudocode is used.
            @property programCode
            @type {String}
        */
        this.programCode = programCode;

        /**
            jQuery reference to the container for the controller.
            @property $containerDOM
            @type {Object}
        */
        this.$containerDOM = $containerDOM;

        /**
            A numerical input component to render along with the function.
            @property input
            @type {NumericalInputComponent}
        */
        this.input = input;

        /**
            A numerical output component to render along with the function.
            @property output
            @type {NumericalOutputComponent}
        */
        this.output = output;

        /**
            The flowchart controller for this function.
            @property functionCodeController
            @type {FunctionCodeController}
            @default null
        */
        this.functionCodeController = null;

        /**
            The parameters controller for this function.
            @property parametersController
            @type {VariablesController}
            @default null
        */
        this.parametersController = null;

        /**
            The local variables controller for this function.
            @property localsController
            @type {VariablesController}
            @default null
        */
        this.localsController = null;

        /**
            The return variable controller for this function.
            @property returnController
            @type {VariablesController}
            @default null
        */
        this.returnController = null;

        /**
            An input controller which is optionally used.
            @property inputController
            @type {NumericalInputComponentController}
            @default null
        */
        this.inputController = null;

        /**
            An input controller which is optionally used.
            @property outputController
            @type {NumericalOutputComponentController}
            @default null
        */
        this.outputController = null;

        /**
            Whether to show the function name.
            @property showFunctionName
            @type {Boolean}
            @default false
        */
        this.showFunctionName = false;

        /**
            Whether to make the output editable.
            @property isOutputEditable
            @type {Boolean}
            @default false
        */
        this.isOutputEditable = false;

        /**
            Whether to make the input editable.
            @property isInputEditable
            @type {Boolean}
            @default false
        */
        this.isInputEditable = false;

        /**
            The function call when the output has changed via user input.
            @property outputChangeFunction
            @type {Function}
            @default null
        */
        this.outputChangeFunction = null;

        /**
            Whether the pseudocode is currently shown.
            @property isPseudocodeCurrentlyShown
            @type {Boolean}
            @default false
        */
        this.isPseudocodeCurrentlyShown = false;

        /**
            Whether the pseudocode is editable.
            @property isPseudocodeEditable
            @type {Boolean}
            @default false
        */
        this.isPseudocodeEditable = false;

        /**
            Whether pseudocode editing is restricted to only the placeholder, and the pre and post are not editable.
            @property isPseudocodeEditingRestricted
            @type {Boolean}
            @default false
        */
        this.isPseudocodeEditingRestricted = false;

        /**
            The program's code that is restricted to editing the placeholder, not the pre and post.
            @property restrictedCode
            @type {RestrictedCode}
            @default null
        */
        this.restrictedCode = null;

        /**
            Whether the executor is in execute mode.
            @property isInExecuteMode
            @type {Boolean}
            @default false
        */
        this.isInExecuteMode = false;
    }

    /**
        Render the program function.
        @method render
        @return {void}
    */


    _createClass(FunctionController, [{
        key: 'render',
        value: function render() {
            this.$containerDOM.html(globalConstants.templates.function({
                hasInputOrOutput: this.input || this.output,
                hasVariables: this.programFunction.parameters.length || this.programFunction.locals.length || this.programFunction.return.length,
                functionName: this.programFunction.name,
                isPseudocodeCurrentlyShown: this.isPseudocodeCurrentlyShown,
                showVariablesNotShownMessage: !this.isInExecuteMode && this.isPseudocodeCurrentlyShown,
                showFunctionName: this.showFunctionName
            }));

            // Create and render the function's code.
            if (this.isPseudocodeCurrentlyShown) {
                this.functionCodeController.setContainerDOM(this.$containerDOM.find('.function-container'));
                this.functionCodeController.setIsPseudocodeEditable(this.isPseudocodeEditable);
                this.functionCodeController.setIsPseudocodeEditingRestricted(this.isPseudocodeEditingRestricted, this.restrictedCode);
            } else {
                this.functionCodeController = new FlowchartController(this.programFunction.flowchart, this.$containerDOM.find('.function-container'));
            }
            this.functionCodeController.render();

            // Create and render the applicable variables.
            if (this.programFunction.parameters.length) {
                this.parametersController = new VariablesController(this.programFunction.parameters, this.$containerDOM.find('.parameter-variables-container'));
                this.parametersController.render();
            }
            if (this.programFunction.locals.length) {
                this.localsController = new VariablesController(this.programFunction.locals, this.$containerDOM.find('.local-variables-container'));
                this.localsController.render();
            }
            if (this.programFunction.return.length) {
                this.returnController = new VariablesController(this.programFunction.return, this.$containerDOM.find('.return-variable-container'));
                this.returnController.render();
            }

            // Create and render the applicable input and output.
            if (this.input) {
                this.inputController = new NumericalInputComponentController(this.input, this.$containerDOM.find('.input-container'));
                this.inputController.setIsEditable(this.isInputEditable);
                this.inputController.render();
            }
            if (this.output) {
                this.outputController = new NumericalOutputComponentController(this.output, this.$containerDOM.find('.output-container'));
                this.outputController.setIsEditable(this.isOutputEditable, this.outputChangeFunction);
                this.outputController.render();
            }
        }

        /**
            Ensure the showing of the node that is next to execute.
            @method showNextToExecuteNode
            @param {FlowchartNode} nextNodeToExecute The next node to execute.
            @param {FlowchartNode} previousNodeExecuted The previously executed node.
            @return {void}
        */

    }, {
        key: 'showNextToExecuteNode',
        value: function showNextToExecuteNode(nextNodeToExecute, previousNodeExecuted) {
            this.functionCodeController.showNextToExecuteNode(nextNodeToExecute, previousNodeExecuted);
        }

        /**
            Make an object storing a function and the associated code's scroll amount.
            @method makeFunctionAndCodeScrollAmount
            @return {FunctionAndFlowchartScrollAmount} The function and associated code's scroll amount.
        */

    }, {
        key: 'makeFunctionAndCodeScrollAmount',
        value: function makeFunctionAndCodeScrollAmount() {
            var horizontalScroll = 0;
            var verticalScroll = 0;

            // Only flowchart stores scrolling.
            if (!this.isPseudocodeCurrentlyShown) {
                horizontalScroll = this.functionCodeController.getHorizontalScroll();
                verticalScroll = this.functionCodeController.getVerticalScroll();
            }

            return new FunctionAndFlowchartScrollAmount(this.programFunction, horizontalScroll, verticalScroll);
        }

        /**
            Set the function code's scroll amount.
            @method setFunctionCodeScrollAmount
            @param {FunctionAndFlowchartScrollAmount} amountToSet The amount of scroll to set.
            @return {void}
        */

    }, {
        key: 'setFunctionCodeScrollAmount',
        value: function setFunctionCodeScrollAmount(amountToSet) {

            // Only flowchart sets scrolling.
            if (!this.isPseudocodeCurrentlyShown) {
                this.functionCodeController.setHorizontalScroll(amountToSet.horizontalScroll);
                this.functionCodeController.setVerticalScroll(amountToSet.verticalScroll);
            }
        }

        /**
            Get the height of this function's code.
            @method getFunctionCodeHeight
            @return {Number} The height of the function's code.
        */

    }, {
        key: 'getFunctionCodeHeight',
        value: function getFunctionCodeHeight() {
            return this.functionCodeController.getHeight();
        }

        /**
            Get the width of this function's code.
            @method getFunctionCodeWidth
            @return {Number} The width of the function's code.
        */

    }, {
        key: 'getFunctionCodeWidth',
        value: function getFunctionCodeWidth() {
            return this.functionCodeController.getWidth();
        }

        /**
            Get the height of this function's variables and IO.
            @method getVariableAndIOHeight
            @return {Number} The height of the function's variables and IO.
        */

    }, {
        key: 'getVariableAndIOHeight',
        value: function getVariableAndIOHeight() {
            return this.$containerDOM.find('.variables-and-IO-container').height();
        }

        /**
            Get the width of this function's variables.
            @method getVariableWidth
            @return {Number} The width of the function's variables.
        */

    }, {
        key: 'getVariableWidth',
        value: function getVariableWidth() {
            var variableWidth = 0;
            var $functionVariables = this.$containerDOM.find('.function-variables-container');

            // If there are function variables, then measure the width of the variables.
            if ($functionVariables.length) {
                var $inputOutputContainer = this.$containerDOM.find('.input-output-container');

                $inputOutputContainer.hide();
                variableWidth = $functionVariables.width();
                $inputOutputContainer.show();
            }

            return variableWidth;
        }

        /**
            Set the height of this function's variables and IO.
            @method setVariableAndIOHeight
            @param {Number} height The height to set.
            @return {void}
        */

    }, {
        key: 'setVariableAndIOHeight',
        value: function setVariableAndIOHeight(height) {
            var propertyToUse = this.isOutputEditable ? 'min-height' : 'height';

            this.$containerDOM.find('.variables-and-IO-container').css(propertyToUse, height);
        }

        /**
            Set the width of this function's variables and IO.
            @method setVariableAndIOWidth
            @param {Number} width The width to set.
            @return {void}
        */

    }, {
        key: 'setVariableAndIOWidth',
        value: function setVariableAndIOWidth(width) {
            var propertyToUse = this.isOutputEditable ? 'min-width' : 'width';

            this.$containerDOM.find('.variables-and-IO-container').css(propertyToUse, width);
        }

        /**
            Set whether to show the function name.
            @method setShowFunctionName
            @param {Boolean} showFunctionName Whether to show the function name.
            @return {void}
        */

    }, {
        key: 'setShowFunctionName',
        value: function setShowFunctionName(showFunctionName) {
            this.showFunctionName = showFunctionName;
        }

        /**
            Hide the function's code.
            @method hideFunctionCode
            @return {void}
        */

    }, {
        key: 'hideFunctionCode',
        value: function hideFunctionCode() {
            this.$containerDOM.find('.function-container').hide();
        }

        /**
            Show the flowchart.
            @method showFunctionCode
            @return {void}
        */

    }, {
        key: 'showFunctionCode',
        value: function showFunctionCode() {
            this.$containerDOM.find('.function-container').show();
        }

        /**
            Set whether to make the output editable.
            @method setIsOutputEditable
            @param {Boolean} isOutputEditable Whether to make the output editable.
            @param {Function} [outputChangeFunction=null] A function to call when the output changes.
            @return {void}
        */

    }, {
        key: 'setIsOutputEditable',
        value: function setIsOutputEditable(isOutputEditable) {
            var outputChangeFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            this.isOutputEditable = isOutputEditable;
            this.outputChangeFunction = outputChangeFunction;
        }

        /**
            Set whether to make the input editable.
            @method setIsInputEditable
            @param {Boolean} isInputEditable Whether to make the input editable.
            @return {void}
        */

    }, {
        key: 'setIsInputEditable',
        value: function setIsInputEditable(isInputEditable) {
            this.isInputEditable = isInputEditable;
        }

        /**
            Set whether pseudocode is currently being shown.
            @method setIsPseudocodeCurrentlyShown
            @param {String} isPseudocodeCurrentlyShown Whether pseudocode is currently being shown.
            @param {PseudocodeController} pseudocodeController The pseudocode controller to use.
            @return {void}
        */

    }, {
        key: 'setIsPseudocodeCurrentlyShown',
        value: function setIsPseudocodeCurrentlyShown(isPseudocodeCurrentlyShown, pseudocodeController) {
            this.isPseudocodeCurrentlyShown = isPseudocodeCurrentlyShown;

            if (isPseudocodeCurrentlyShown) {
                this.functionCodeController = pseudocodeController;
            }
        }

        /**
            Set whether the pseudocode is editable.
            @method setIsPseudocodeEditable
            @param {Boolean} isPseudocodeEditable Whether the pseudocode is editable.
            @return {void}
        */

    }, {
        key: 'setIsPseudocodeEditable',
        value: function setIsPseudocodeEditable(isPseudocodeEditable) {
            this.isPseudocodeEditable = isPseudocodeEditable;

            if (this.functionCodeController && this.functionCodeController.setIsPseudocodeEditable) {
                this.functionCodeController.setIsPseudocodeEditable(this.isPseudocodeEditable);
            }
        }

        /**
            Set whether the pseudocode editing should be restricted.
            @method setIsPseudocodeEditingRestricted
            @param {Boolean} isPseudocodeEditingRestricted Whether the pseudocode editing should be restricted.
            @param {RestrictedCode} restrictedCode The program's code that is restricted to editing the placeholder, not the pre and post.
            @return {void}
        */

    }, {
        key: 'setIsPseudocodeEditingRestricted',
        value: function setIsPseudocodeEditingRestricted(isPseudocodeEditingRestricted, restrictedCode) {
            this.isPseudocodeEditingRestricted = isPseudocodeEditingRestricted;
            this.restrictedCode = restrictedCode;
        }

        /**
            Set whether the executor is in execute mode.
            @method setIsInExecuteMode
            @param {Boolean} isInExecuteMode Whether the executor is in execute mode.
            @return {void}
        */

    }, {
        key: 'setIsInExecuteMode',
        value: function setIsInExecuteMode(isInExecuteMode) {
            this.isInExecuteMode = isInExecuteMode;
        }

        /**
            Set the error message and line number.
            @method setError
            @param {String} message The error message.
            @param {Integer} lineNumber The line number of the error.
            @return {void}
        */

    }, {
        key: 'setError',
        value: function setError(message, lineNumber) {
            this.functionCodeController.setError(message, lineNumber);
        }

        /**
            Clear the error message and line number.
            @method clearError
            @return {void}
        */

    }, {
        key: 'clearError',
        value: function clearError() {
            this.functionCodeController.clearError();
        }

        /**
            Return the pseudocode stored by this function.
            @method getPseudocode
            @return {String} The code stored by this function.
        */

    }, {
        key: 'getPseudocode',
        value: function getPseudocode() {
            return this.functionCodeController && this.functionCodeController.getPseudocode ? this.functionCodeController.getPseudocode() : this.programCode;
        }

        /**
            Put the browser's focus on this function.
            @method focus
            @return {void}
        */

    }, {
        key: 'focus',
        value: function focus() {
            if (this.functionCodeController) {
                this.functionCodeController.focus();
            }
        }
    }]);

    return FunctionController;
}();

'use strict';

/* exported NumericalInputComponentController */
/* global globalConstants */

/**
    Control a numerical input component.
    @class NumericalInputComponentController
*/

var NumericalInputComponentController = function () {

    /**
        @constructor
        @param {NumericalInputComponent} input The numerical input component to control.
        @param {Object} $containerDOM jQuery reference to the container for the controller.
    */
    function NumericalInputComponentController(input, $containerDOM) {
        _classCallCheck(this, NumericalInputComponentController);

        /**
            The numerical input component to control.
            @property input
            @type {NumericalInputComponent}
        */
        this.input = input;

        /**
            jQuery reference to the container for the controller.
            @property $containerDOM
            @type {Object}
        */
        this.$containerDOM = $containerDOM;

        /**
            Whether the input is editable.
            @property isEditable
            @type {Boolean}
            @default false
        */
        this.isEditable = false;

        // Register this controller with the input component so this controller gets updates when the input's value changes.
        this.input.registerController(this);
    }

    /**
        Render the numerical input component.
        @method render
        @return {void}
    */


    _createClass(NumericalInputComponentController, [{
        key: 'render',
        value: function render() {
            var _this8 = this;

            var isEditable = this.isEditable && this.input.isEditable ? 'true' : 'false';

            this.$containerDOM.html(globalConstants.templates.input({ isEditable: isEditable }));
            this.updatedInputString();

            // Inform the other registered input controllers that the input string may have changed.
            if (this.input.isEditable) {
                var $input = this.$containerDOM.find('.numerical-input');

                $input.blur(function () {
                    _this8.input.userInput = $input.get(0).innerText;
                    _this8.input.registeredControllers.forEach(function (controller) {
                        controller.updatedInputString();
                    });
                });
            }
        }

        /**
            Inform this controller that the input string has changed.
            @method updatedInputString
            @return {void}
        */

    }, {
        key: 'updatedInputString',
        value: function updatedInputString() {
            var $input = this.$containerDOM.find('.numerical-input');

            if (this.input.isEditable) {
                $input.get(0).innerText = this.input.userInput;
            } else {
                var numberOfConsumed = this.input.initialInputs.length - this.input.inputs.length;
                var consumedInputs = this.input.initialInputs.slice(0, numberOfConsumed);
                var consumedInputsHTML = consumedInputs.map(function (input) {
                    return '<span class=\'consumed\'>' + input + '</span>';
                });
                var inputsHTML = consumedInputsHTML.concat(this.input.inputs).join(' ');

                $input.html(inputsHTML);
            }
        }

        /**
            Set whether the input is editable.
            @method setIsEditable
            @param {Boolean} isEditable Whether the input is editable.
            @return {void}
        */

    }, {
        key: 'setIsEditable',
        value: function setIsEditable(isEditable) {
            this.isEditable = isEditable;
        }
    }]);

    return NumericalInputComponentController;
}();

'use strict';

/* exported NumericalOutputComponentController */
/* global globalConstants */

/**
    Control a numerical output component.
    @class NumericalOutputComponentController
*/

var NumericalOutputComponentController = function () {

    /**
        @constructor
        @param {NumericalOutputComponent} output The numerical output component to control.
        @param {Object} $containerDOM jQuery reference to the container for the controller.
    */
    function NumericalOutputComponentController(output, $containerDOM) {
        _classCallCheck(this, NumericalOutputComponentController);

        /**
            The numerical output component to control.
            @property output
            @type {NumericalOutputComponent}
        */
        this.output = output;

        /**
            jQuery reference to the container for the controller.
            @property $containerDOM
            @type {Object}
        */
        this.$containerDOM = $containerDOM;

        /**
            Whether the output is editable.
            @property isEditable
            @type {Boolean}
            @default false
        */
        this.isEditable = false;

        /**
            Function to call when the user change's the output.
            @property onChangeFunction
            @type {Function}
            @default null
        */
        this.onChangeFunction = null;

        // Register this controller with the output component so this controller gets updates when the output changes.
        this.output.registerController(this);
    }

    /**
        Render the numerical output component.
        @method render
        @return {void}
    */


    _createClass(NumericalOutputComponentController, [{
        key: 'render',
        value: function render() {
            var _this9 = this;

            this.$containerDOM.html(globalConstants.templates.output({ isEditable: this.isEditable }));
            this.updatedOutput();

            if (this.isEditable) {
                var $console = this.$containerDOM.find('.console');

                $console.on('input', function () {
                    _this9.output.setOutputOfOtherControllers(_this9, $console.val());
                    if (_this9.onChangeFunction) {
                        _this9.onChangeFunction();
                    }
                });
            }
        }

        /**
            Inform this controller that the output has changed.
            @method updatedOutput
            @return {void}
        */

    }, {
        key: 'updatedOutput',
        value: function updatedOutput() {
            var $console = this.$containerDOM.find('.console');

            if (this.isEditable) {
                $console.val(this.output.output);
                if (this.onChangeFunction) {
                    this.onChangeFunction();
                }
            } else {
                this.$containerDOM.find('.numerical-output').text(this.output.output + '_');

                // Scroll to the last output entry automatically.
                $console.scrollTop($console.prop('scrollHeight'));
            }
        }

        /**
            Set whether the output is editable.
            @method setIsEditable
            @param {Boolean} isEditable Whether the output is editable.
            @param {Function} [onChangeFunction=null] A function to call when the output changes.
            @return {void}
        */

    }, {
        key: 'setIsEditable',
        value: function setIsEditable(isEditable) {
            var onChangeFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            this.isEditable = isEditable;
            this.onChangeFunction = onChangeFunction;
        }
    }]);

    return NumericalOutputComponentController;
}();

'use strict';

/* exported PointController */
/* global FlowchartElementController */

/**
    Control a rendering point, which is used to draw edges.
    @class PointController
    @extends FlowchartElementController
*/

var PointController = function (_FlowchartElementCont) {
    _inherits(PointController, _FlowchartElementCont);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {MergeTrueRenderingIndicator} point A point to render on the canvas.
    */
    function PointController(canvas, point) {
        _classCallCheck(this, PointController);

        /**
            A point to render on the canvas.
            @property point
            @type {MergeTrueRenderingIndicator}
        */
        var _this10 = _possibleConstructorReturn(this, (PointController.__proto__ || Object.getPrototypeOf(PointController)).call(this, canvas));

        _this10.point = point;
        return _this10;
    }

    /**
        Render the point.
        @method render
        @return {void}
    */


    _createClass(PointController, [{
        key: 'render',
        value: function render() {
            var point = this.canvas.circle(0, 0, 0);

            point.attr('stroke', '#888');

            this.drawing.push(point);
        }
    }]);

    return PointController;
}(FlowchartElementController);

'use strict';

/* exported PseudocodeController */
/* global FunctionCodeController, makeRandomInteger, globalConstants, ace */

/**
    Render and control a function's pseudocode.
    @class PseudocodeController
    @extends FunctionCodeController
*/

var PseudocodeController = function (_FunctionCodeControll2) {
    _inherits(PseudocodeController, _FunctionCodeControll2);

    /**
        @constructor
        @param {String} programCode The program's code.
    */
    function PseudocodeController(programCode) {
        _classCallCheck(this, PseudocodeController);

        /**
            The program's code.
            @property programCode
            @type {String}
        */
        var _this11 = _possibleConstructorReturn(this, (PseudocodeController.__proto__ || Object.getPrototypeOf(PseudocodeController)).call(this, null));

        _this11.programCode = programCode;

        /**
            Reference to the ACE editor instance.
            @property editor;
            @type {ACEEditor}
            @default null
        */
        _this11.editor = null;

        /**
            Whether the pseudocode is editable.
            @property isPseudocodeEditable
            @type {Boolean}
            @default false
        */
        _this11.isPseudocodeEditable = false;

        /**
            Whether pseudocode editing is restricted to only the placeholder, and the pre and post are not editable.
            @property isPseudocodeEditingRestricted
            @type {Boolean}
            @default false
        */
        _this11.isPseudocodeEditingRestricted = false;

        /**
            The program's code that is restricted to editing the placeholder, not the pre and post.
            @property restrictedCode
            @type {RestrictedCode}
            @default null
        */
        _this11.restrictedCode = null;

        /**
            The editor used for restricting code editing.
            @property restrictedEditor
            @type {restrictedEditor}
            @default null
        */
        _this11.restrictedEditor = null;

        /**
            Whether the controller has rendered before.
            @property hasRendered
            @type {Boolean}
            @default false
        */
        _this11.hasRendered = false;
        return _this11;
    }

    /**
        Render the function's code.
        @method render
        @return {void}
    */


    _createClass(PseudocodeController, [{
        key: 'render',
        value: function render() {
            var _this12 = this;

            if (this.hasRendered) {
                var $editor = $(this.editor.container);

                this.$containerDOM.append($editor);
            } else {

                // Generate a random integer to use in the code editor.
                var randomId = makeRandomInteger();
                var codeEditorID = 'code-editor-' + randomId;

                this.$containerDOM.html(globalConstants.templates.pseudocode({ codeEditorID: codeEditorID }));
                this.editor = ace.edit(codeEditorID);

                require('utilities').aceBaseSettings(this.editor, 'zyFlowchart');
                this.editor.setValue(this.programCode, 1);

                if (this.isPseudocodeEditingRestricted) {
                    this.restrictedEditor = require('restrictedEditor').create();
                    this.restrictedEditor.init(this.editor, function () {
                        _this12.displayNonEditableAreaErrorMessage();
                    });
                    this.restrictedEditor.initializeNonEditableAreas(this.restrictedCode.pre, this.restrictedCode.post, this.restrictedCode.placeholder);

                    var positionForCursor = this.editor.session.doc.indexToPosition(this.restrictedCode.pre.length);

                    this.editor.moveCursorToPosition(positionForCursor);
                } else {
                    this.restrictedEditor = null;
                    this.editor.moveCursorToPosition({ column: 0, row: 0 });
                }

                this.hasRendered = true;
            }

            this.updateEditability();
        }

        /**
            Flash the highlighted gutter region until a valid command is used.
            @method displayNonEditableAreaErrorMessage
            @return {void}
        */

    }, {
        key: 'displayNonEditableAreaErrorMessage',
        value: function displayNonEditableAreaErrorMessage() {

            // Animate in the gutter highlight.
            var $highlightedGutterRange = this.$containerDOM.find('.gutter-highlight');

            $highlightedGutterRange.removeClass('gutter-highlight-flash');

            var timeout = 50;

            /*
                Wait 50 milliseconds before adding the |gutter-highlight-flash| class back
                so that the respective animation occurs.
            */
            setTimeout(function () {
                $highlightedGutterRange.addClass('gutter-highlight-flash');
            }, timeout);
        }

        /**
            Ensure the showing of the node that is next to execute.
            @method showNextToExecuteNode
            @param {FlowchartNode} nextNodeToExecute The next node to execute.
            @param {FlowchartNode} previousNodeExecuted The previously executed node.
            @return {void}
        */

    }, {
        key: 'showNextToExecuteNode',
        value: function showNextToExecuteNode(nextNodeToExecute, previousNodeExecuted) {
            this.removeLineNumberHighlighter();

            var lineNumber = nextNodeToExecute && nextNodeToExecute.line && nextNodeToExecute.line.lineNumber;

            // For end node's, highlight the previous node's line.
            if (nextNodeToExecute && nextNodeToExecute.getName() === 'EndNode' && previousNodeExecuted) {
                lineNumber = previousNodeExecuted.line.lineNumber;
            }

            if ($.isNumeric(lineNumber)) {
                var lineIndex = lineNumber - 1;

                this.editor.session.setBreakpoint(lineIndex);
                this.ensureLineNumberInView(lineNumber);

                var startIndexToHighlight = nextNodeToExecute.line.startIndexOfSegment;
                var endIndex = nextNodeToExecute.line.endIndexOfSegment;

                // Highlight the next non-built-in function to be called.
                if (nextNodeToExecute.nonBuiltInFunctionCalls.length) {
                    startIndexToHighlight = nextNodeToExecute.nonBuiltInFunctionCalls[0].startIndexToHighlight;
                    endIndex = nextNodeToExecute.nonBuiltInFunctionCalls[0].endIndexToHighlight;
                }

                var endIndexToUse = endIndex ? endIndex + 1 : 0;
                var currentRange = this.editor.selection.getRange();

                currentRange.setStart(lineIndex, startIndexToHighlight);
                currentRange.setEnd(lineIndex, endIndexToUse);
                this.editor.selection.setSelectionRange(currentRange);
            }
        }

        /**
            Set whether the pseudocode is editable.
            @method setIsPseudocodeEditable
            @param {Boolean} isPseudocodeEditable Whether the pseudocode is editable.
            @return {void}
        */

    }, {
        key: 'setIsPseudocodeEditable',
        value: function setIsPseudocodeEditable(isPseudocodeEditable) {
            this.isPseudocodeEditable = isPseudocodeEditable;
            this.updateEditability();
        }

        /**
            Set whether the pseudocode editing should be restricted.
            @method setIsPseudocodeEditingRestricted
            @param {Boolean} isPseudocodeEditingRestricted Whether the pseudocode editing should be restricted.
            @param {RestrictedCode} restrictedCode The program's code that is restricted to editing the placeholder, not the pre and post.
            @return {void}
        */

    }, {
        key: 'setIsPseudocodeEditingRestricted',
        value: function setIsPseudocodeEditingRestricted(isPseudocodeEditingRestricted, restrictedCode) {
            this.isPseudocodeEditingRestricted = isPseudocodeEditingRestricted;
            this.restrictedCode = restrictedCode;
        }

        /**
            Set the container DOM for this controller.
            @method setContainerDOM
            @param {Object} $containerDOM jQuery reference to the container for the controller.
            @return {void}
        */

    }, {
        key: 'setContainerDOM',
        value: function setContainerDOM($containerDOM) {
            this.$containerDOM = $containerDOM;
        }

        /**
            Update whether the code is editable.
            @method updateEditability
            @return {void}
        */

    }, {
        key: 'updateEditability',
        value: function updateEditability() {
            if (this.isPseudocodeEditable) {
                this.enable();
            } else {
                this.disable();
            }
        }

        /**
            Enables the student to write code in the editor. Removes transparency.
            @method enable
            @return {void}
        */

    }, {
        key: 'enable',
        value: function enable() {
            if (this.editor) {
                var $cursor = $(this.editor.renderer.$cursorLayer.element);

                $cursor.show();
                this.$containerDOM.removeClass('disabled');
                this.editor.setOptions({
                    readOnly: false,
                    highlightActiveLine: true,
                    highlightGutterLine: true
                });
                this.removeLineNumberHighlighter();
            }
        }

        /**
            Disables the student from being able to write code in the editor. Sets transparency.
            @method disable
            @return {void}
        */

    }, {
        key: 'disable',
        value: function disable() {
            if (this.editor) {
                var $cursor = $(this.editor.renderer.$cursorLayer.element);

                $cursor.hide();
                this.$containerDOM.addClass('disabled');
                this.editor.setOptions({
                    readOnly: true,
                    highlightActiveLine: false,
                    highlightGutterLine: false
                });
                this.editor.blur();
            }
        }

        /**
            Force the editor to re-render itself.
            @method forceEditorReRender
            @return {void}
        */

    }, {
        key: 'forceEditorReRender',
        value: function forceEditorReRender() {
            this.editor.resize(true);
        }

        /**
            Remove the line number pointer on all gutter cells.
            @method removeLineNumberHighlighter
            @return {void}
        */

    }, {
        key: 'removeLineNumberHighlighter',
        value: function removeLineNumberHighlighter() {
            this.editor.session.clearBreakpoints();
        }

        /**
            Return the pseudocode stored by this function.
            @method getPseudocode
            @return {String} The code stored by this function.
        */

    }, {
        key: 'getPseudocode',
        value: function getPseudocode() {
            return this.editor.getValue();
        }

        /**
            Set the error message and line number.
            @method setError
            @param {String} message The error message.
            @param {Integer} lineNumber The line number of the error.
            @return {void}
        */

    }, {
        key: 'setError',
        value: function setError(message, lineNumber) {

            // Add error markers on line with error.
            var column = 0;
            var row = lineNumber - 1;

            this.editor.getSession().setAnnotations([{ column: column, row: row, text: message, type: 'error' }]);
            this.ensureLineNumberInView(lineNumber);

            // Move cursor to line with error.
            this.editor.moveCursorToPosition({ column: column, row: row });
            this.editor.selection.clearSelection();
            this.focus();
        }

        /**
            Clear an error on the controller.
            @method clearError
            @return {void}
        */

    }, {
        key: 'clearError',
        value: function clearError() {
            this.editor.getSession().clearAnnotations();
        }

        /**
            Ensure the given line number is in view.
            @method ensureLineNumberInView
            @param {Integer} lineNumber The line number to ensure is in view.
            @return {void}
        */

    }, {
        key: 'ensureLineNumberInView',
        value: function ensureLineNumberInView(lineNumber) {
            var lineNumberIndex = lineNumber - 1;

            // Determine whether the line is visible. Note: The last row is off by 2.
            var firstOffset = 1;
            var isAboveFirstVisibleRow = lineNumberIndex >= this.editor.getFirstVisibleRow() + firstOffset;
            var lastOffset = 2;
            var isBelowLastVisibleRow = lineNumberIndex <= this.editor.getLastVisibleRow() - lastOffset;
            var isRowVisible = isAboveFirstVisibleRow && isBelowLastVisibleRow;

            // If the line is not visible, then scroll the line onto screen.
            if (!isRowVisible) {
                this.editor.scrollToLine(lineNumber, true);
            }
        }

        /**
            Put the browser's focus on this function.
            @method focus
            @return {void}
        */

    }, {
        key: 'focus',
        value: function focus() {
            this.editor.focus();
        }

        /**
            Detach the editor from the DOM for later use.
            @method detach
            @return {void}
        */

    }, {
        key: 'detach',
        value: function detach() {
            if (this.hasRendered) {
                var $editor = $(this.editor.container);

                $editor.detach();
            }
        }
    }]);

    return PseudocodeController;
}(FunctionCodeController);

'use strict';

/* exported RenderingIndicatorAndControllerPair */

/**
    Store a rendering indicator and the associated controller.
    @class RenderingIndicatorAndControllerPair
*/

var RenderingIndicatorAndControllerPair =

/**
    @constructor
    @param {RenderingIndicator} indicator The rendering indicator to store.
    @param {FlowchartController} controller The associated controller.
*/
function RenderingIndicatorAndControllerPair(indicator, controller) {
    _classCallCheck(this, RenderingIndicatorAndControllerPair);

    /**
        The rendering indicator to store.
        @property indicator
        @type {RenderingIndicator}
    */
    this.indicator = indicator;

    /**
        The associated controller.
        @property controller
        @type {FlowchartController}
    */
    this.controller = controller;
};

'use strict';

/* exported VariablesController */
/* global SingleMemoryCellVariableRender, ArraySizeRender, ArrayElementRender, ArraySizeComment, globalConstants */

/**
    Control a {Variables}
    @class VariablesController
*/

var VariablesController = function () {

    /**
        @constructor
        @param {Variables} variables The variables to control.
        @param {Object} $containerDOM jQuery reference to the container for the controller.
    */
    function VariablesController(variables, $containerDOM) {
        _classCallCheck(this, VariablesController);

        /**
            The variables to control.
            @property variables
            @type {Variables}
        */
        this.variables = variables;

        /**
            jQuery reference to the container for the controller.
            @property $containerDOM
            @type {Object}
        */
        this.$containerDOM = $containerDOM;
    }

    /**
        Render the variables.
        @method render
        @return {void}
    */


    _createClass(VariablesController, [{
        key: 'render',
        value: function render() {
            var variableRenderList = [];
            var hasArray = false;

            this.variables.forEach(function (variable) {
                var isArray = variable.isArray();

                hasArray = hasArray || isArray;

                if (isArray) {
                    var sizeElement = new ArraySizeRender(variable);
                    var arrayElements = [];

                    if (sizeElement.value === '0') {
                        arrayElements.push(new ArraySizeComment('empty'));
                    } else if (sizeElement.value === '?') {
                        arrayElements.push(new ArraySizeComment('not set'));
                    } else {
                        arrayElements.push.apply(arrayElements, _toConsumableArray(variable.arrayCells.map(function (memoryCell) {
                            return new ArrayElementRender(memoryCell, variable.name);
                        })));
                    }

                    variableRenderList.push.apply(variableRenderList, [sizeElement].concat(arrayElements));
                } else {
                    variableRenderList.push(new SingleMemoryCellVariableRender(variable.cell));
                }
            });

            this.$containerDOM.html(globalConstants.templates.variables({
                hasArray: hasArray,
                variablesName: this.variables.name,
                variableRenderList: variableRenderList
            }));
        }

        /**
            Hide the variables.
            @method hide
            @return {void}
        */

    }, {
        key: 'hide',
        value: function hide() {
            this.$containerDOM.hide();
        }

        /**
            Show the variables.
            @method show
            @return {void}
        */

    }, {
        key: 'show',
        value: function show() {
            this.$containerDOM.show();
        }
    }]);

    return VariablesController;
}();

'use strict';

/* exported FlowchartEdgeController */
/* global FlowchartElementController */

/**
    Abstract control of a flowchart edge.
    @class FlowchartEdgeController
    @extends FlowchartElementController
*/

var FlowchartEdgeController = function (_FlowchartElementCont2) {
    _inherits(FlowchartEdgeController, _FlowchartElementCont2);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {String} [labelText=''] The label's text for the edge.
    */
    function FlowchartEdgeController(canvas) {
        var labelText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        _classCallCheck(this, FlowchartEdgeController);

        /**
            The label's text for the edge.
            @property labelText
            @type {String}
            @default ''
        */
        var _this13 = _possibleConstructorReturn(this, (FlowchartEdgeController.__proto__ || Object.getPrototypeOf(FlowchartEdgeController)).call(this, canvas));

        _this13.labelText = labelText;
        return _this13;
    }

    /**
        Render the edge.
        @method render
        @return {void}
    */


    _createClass(FlowchartEdgeController, [{
        key: 'render',
        value: function render() {
            var edge = this.makeEdge();
            var gray = '#999';

            edge.attr({
                'arrow-end': 'classic-wide-long',
                stroke: gray,
                'stroke-width': 2
            });
            this.drawing.push(edge);

            if (this.labelText) {
                var label = this.canvas.text(0, 0, this.labelText);

                label.attr({
                    fill: gray,
                    'font-family': '\'Roboto\', sans-serif',
                    'font-size': '11px'
                });
                label.node.setAttribute('class', 'edge-label');
                this.moveLabelIntoPosition(label);
                this.drawing.push(label);
            }
        }

        /**
            Make the edge. Inheriting controllers must override.
            @method makeEdge
            @return {Object} Reference to a Raphael shape.
        */

    }, {
        key: 'makeEdge',
        value: function makeEdge() {
            throw new Error('FlowchartEdgeController\'s makeEdge function should be overridden');
        }

        /**
            Move the label into position. Inheriting controllers must override.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            // eslint-disable-line no-unused-vars
            throw new Error('FlowchartEdgeController\'s moveLabelIntoPosition function should be overridden');
        }
    }]);

    return FlowchartEdgeController;
}(FlowchartElementController);

'use strict';

/* exported TrueBranchEdgeController */
/* global FlowchartEdgeController, moveLabelInTrueBranchIntoPosition */

/**
    Abstract controller for the true-branch edge from a decision node.
    @class TrueBranchEdgeController
    @extends FlowchartEdgeController
*/

var TrueBranchEdgeController = function (_FlowchartEdgeControl) {
    _inherits(TrueBranchEdgeController, _FlowchartEdgeControl);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {FlowchartNodeController} loopNodeController The controller of the node from which the edge starts and ends.
    */
    function TrueBranchEdgeController(canvas, loopNodeController) {
        _classCallCheck(this, TrueBranchEdgeController);

        /**
            The controller of the node from which the edge starts and ends.
            @property startNodeController
            @type {FlowchartNodeController}
        */
        var _this14 = _possibleConstructorReturn(this, (TrueBranchEdgeController.__proto__ || Object.getPrototypeOf(TrueBranchEdgeController)).call(this, canvas, 'true'));

        _this14.loopNodeController = loopNodeController;
        return _this14;
    }

    /**
        Move the label into position.
        @method moveLabelIntoPosition
        @param {Object} label Reference to the label.
        @return {void}
    */


    _createClass(TrueBranchEdgeController, [{
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            moveLabelInTrueBranchIntoPosition(label, this.loopNodeController);
        }
    }]);

    return TrueBranchEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported BackToLoopToMergeFalseEdgeController */
/* global FlowchartEdgeController, moveLabelInFalseBranchIntoPosition, globalConstants */

/**
    Control an edge that goes from a BackToLoop to a MergeFalse.
    @class BackToLoopToMergeFalseEdgeController
    @extends FlowchartEdgeController
*/

var BackToLoopToMergeFalseEdgeController = function (_FlowchartEdgeControl2) {
    _inherits(BackToLoopToMergeFalseEdgeController, _FlowchartEdgeControl2);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {LoopNodeController} loopNodeController The controller of the loop node from which the edge starts.
        @param {PointController} pointController The controller of the point from which the edge ends.
        @param {Number} largestBottomYOfPreviousEdges The largest bottom of previous edges.
        @param {Number} pointY The y-axis location of the next point.
    */
    function BackToLoopToMergeFalseEdgeController(canvas, loopNodeController, pointController, largestBottomYOfPreviousEdges, pointY) {
        _classCallCheck(this, BackToLoopToMergeFalseEdgeController);

        /**
            The controller of the loop node from which the edge starts.
            @property loopNodeController
            @type {LoopNodeController}
        */
        var _this15 = _possibleConstructorReturn(this, (BackToLoopToMergeFalseEdgeController.__proto__ || Object.getPrototypeOf(BackToLoopToMergeFalseEdgeController)).call(this, canvas, 'false'));

        _this15.loopNodeController = loopNodeController;

        /**
            The controller of the pointer from which the edge ends.
            @property pointController
            @type {PointController}
        */
        _this15.pointController = pointController;

        /**
            The largest bottom of previous edges.
            @property largestBottomYOfPreviousEdges
            @type {Number}
        */
        _this15.largestBottomYOfPreviousEdges = largestBottomYOfPreviousEdges;

        /**
            The y-axis location of the next point.
            @property pointY
            @type {Number}
        */
        _this15.pointY = pointY;
        return _this15;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(BackToLoopToMergeFalseEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var startX = this.loopNodeController.getHorizontalCenter();
            var startY = this.loopNodeController.getBottom();
            var endX = this.pointController.getLeft();
            var bottomOffset = globalConstants.spaceBetweenRows / 2; // eslint-disable-line no-magic-numbers
            var endY = Math.max(startY, this.largestBottomYOfPreviousEdges) + bottomOffset;

            if (this.pointY) {
                endY = this.pointY;
            }

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to.
            return this.canvas.path('M ' + startX + ', ' + startY + ' V ' + endY + ' H ' + endX);
        }

        /**
            Move the label into position.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            var horizontalOffset = 5;
            var verticalOffset = -4;

            moveLabelInFalseBranchIntoPosition(label, this.loopNodeController, horizontalOffset, verticalOffset);
        }
    }]);

    return BackToLoopToMergeFalseEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported FirstChildOfIfElseFalseBranchEdgeController */
/* global FlowchartEdgeController, moveLabelInFalseBranchIntoPosition */

/**
    Controller for the false-branch edge from an if-else node to the first child of the false-branch.
    @class FirstChildOfIfElseFalseBranchEdgeController
    @extends FlowchartEdgeController
*/

var FirstChildOfIfElseFalseBranchEdgeController = function (_FlowchartEdgeControl3) {
    _inherits(FirstChildOfIfElseFalseBranchEdgeController, _FlowchartEdgeControl3);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {IfNodeController} ifNodeController The controller of the node from which the edge starts.
        @param {FlowchartNodeController} childNodeController The child of the if-else node.
    */
    function FirstChildOfIfElseFalseBranchEdgeController(canvas, ifNodeController, childNodeController) {
        _classCallCheck(this, FirstChildOfIfElseFalseBranchEdgeController);

        /**
            The controller of the node from which the edge starts.
            @property startNodeController
            @type {IfNodeController}
        */
        var _this16 = _possibleConstructorReturn(this, (FirstChildOfIfElseFalseBranchEdgeController.__proto__ || Object.getPrototypeOf(FirstChildOfIfElseFalseBranchEdgeController)).call(this, canvas, 'false'));

        _this16.ifNodeController = ifNodeController;

        /**
            The child of the if-else node.
            @property childNodeController
            @type {FlowchartNodeController}
        */
        _this16.childNodeController = childNodeController;
        return _this16;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(FirstChildOfIfElseFalseBranchEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var top = this.ifNodeController.getBottom();
            var xCoordinate = this.ifNodeController.getHorizontalCenter();
            var yCoordinate = this.childNodeController.getVerticalCenter();
            var left = this.childNodeController.getLeftAtVerticalCenter();

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to.
            return this.canvas.path('M ' + xCoordinate + ', ' + top + ' V ' + yCoordinate + ' H ' + left);
        }

        /**
            Move the label into position.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            moveLabelInFalseBranchIntoPosition(label, this.ifNodeController);
        }
    }]);

    return FirstChildOfIfElseFalseBranchEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported LoopNodeToPointEdgeController */
/* global FlowchartEdgeController, moveLabelInFalseBranchIntoPosition */

/**
    Control an edge from a loop node to a point.
    @class LoopNodeToPointEdgeController
    @extends FlowchartEdgeController
*/

var LoopNodeToPointEdgeController = function (_FlowchartEdgeControl4) {
    _inherits(LoopNodeToPointEdgeController, _FlowchartEdgeControl4);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {LoopNodeController} loopNodeController The controller of the loop node from which the edge starts.
        @param {PointController} pointNodeController The controller of the point from which the edge ends.
    */
    function LoopNodeToPointEdgeController(canvas, loopNodeController, pointNodeController) {
        _classCallCheck(this, LoopNodeToPointEdgeController);

        /**
            The controller of the loop node from which the edge starts.
            @property loopNodeController
            @type {LoopNodeController}
        */
        var _this17 = _possibleConstructorReturn(this, (LoopNodeToPointEdgeController.__proto__ || Object.getPrototypeOf(LoopNodeToPointEdgeController)).call(this, canvas, 'false'));

        _this17.loopNodeController = loopNodeController;

        /**
            The controller of the point from which the edge ends.
            @property pointNodeController
            @type {PointController}
        */
        _this17.pointNodeController = pointNodeController;
        return _this17;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(LoopNodeToPointEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var startX = this.loopNodeController.getHorizontalCenter();
            var startY = this.loopNodeController.getBottom();
            var endX = this.pointNodeController.getLeftAtVerticalCenter();
            var endY = this.pointNodeController.getVerticalCenter();

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to.
            return this.canvas.path('M ' + startX + ', ' + startY + ' V ' + endY + ' H ' + endX);
        }

        /**
            Move the label into position.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            moveLabelInFalseBranchIntoPosition(label, this.loopNodeController);
        }
    }]);

    return LoopNodeToPointEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported MergeFalseToMergeFalseEdgeController */
/* global FlowchartEdgeController */

/**
    Control an edge that goes from one MergeFalse to another.
    @class MergeFalseToMergeFalseEdgeController
    @extends FlowchartEdgeController
*/

var MergeFalseToMergeFalseEdgeController = function (_FlowchartEdgeControl5) {
    _inherits(MergeFalseToMergeFalseEdgeController, _FlowchartEdgeControl5);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {PointController} startPointerController The controller of the pointer from which the edge starts.
        @param {PointController} endPointerController The controller of the pointer from which the edge ends.
        @param {Number} endYOfPreviousEdge The end of the previous edge's y-position.
    */
    function MergeFalseToMergeFalseEdgeController(canvas, startPointerController, endPointerController, endYOfPreviousEdge) {
        _classCallCheck(this, MergeFalseToMergeFalseEdgeController);

        /**
            The controller of the pointer from which the edge starts.
            @property startPointerController
            @type {PointController}
        */
        var _this18 = _possibleConstructorReturn(this, (MergeFalseToMergeFalseEdgeController.__proto__ || Object.getPrototypeOf(MergeFalseToMergeFalseEdgeController)).call(this, canvas));

        _this18.startPointerController = startPointerController;

        /**
            The controller of the pointer from which the edge ends.
            @property endPointerController
            @type {PointController}
        */
        _this18.endPointerController = endPointerController;

        /**
            The end of the previous edge's y-position.
            @property endYOfPreviousEdge
            @type {Number}
        */
        _this18.endYOfPreviousEdge = endYOfPreviousEdge;
        return _this18;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(MergeFalseToMergeFalseEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var startX = this.startPointerController.getHorizontalCenter();
            var startY = this.startPointerController.getBottom();
            var endX = this.endPointerController.getLeft();
            var endY = this.endYOfPreviousEdge;

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to.
            return this.canvas.path('M ' + startX + ', ' + startY + ' V ' + endY + ' H ' + endX);
        }
    }]);

    return MergeFalseToMergeFalseEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported MergeTrueToMergeFalseEdgeController */
/* global FlowchartEdgeController, moveLabelInFalseBranchIntoPosition, globalConstants */

/**
    Control an edge from a merge true to a merge false.
    @class MergeTrueToMergeFalseEdgeController
    @extends FlowchartEdgeController
*/

var MergeTrueToMergeFalseEdgeController = function (_FlowchartEdgeControl6) {
    _inherits(MergeTrueToMergeFalseEdgeController, _FlowchartEdgeControl6);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {IfNodeController} ifNodeController The controller of the node from which the edge starts.
        @param {PointerController} pointController The controller of the node from which the edge ends.
        @param {Number} verticalOffset The bottom of the node before the merge true to ensure the edge goes downward enough.
        @param {Number} pointY The y-axis location of the next point.
    */
    function MergeTrueToMergeFalseEdgeController(canvas, ifNodeController, pointController, verticalOffset, pointY) {
        _classCallCheck(this, MergeTrueToMergeFalseEdgeController);

        /**
            The controller of the node from which the edge starts.
            @property ifNodeController
            @type {IfNodeController}
        */
        var _this19 = _possibleConstructorReturn(this, (MergeTrueToMergeFalseEdgeController.__proto__ || Object.getPrototypeOf(MergeTrueToMergeFalseEdgeController)).call(this, canvas, 'false'));

        _this19.ifNodeController = ifNodeController;

        /**
            The controller of the node from which the edge ends.
            @property pointController
            @type {PointController}
        */
        _this19.pointController = pointController;

        /**
            The bottom of the node before the merge true to ensure the edge goes downward enough.
            @property verticalOffset
            @type {Number}
        */
        _this19.verticalOffset = verticalOffset;

        /**
            The y-axis location of the next point.
            @property pointY
            @type {Number}
        */
        _this19.pointY = pointY;
        return _this19;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(MergeTrueToMergeFalseEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var startY = this.ifNodeController.getBottom();
            var startX = this.ifNodeController.getHorizontalCenter();
            var totalVerticalOffset = this.verticalOffset + globalConstants.spaceBetweenRows / 2; // eslint-disable-line no-magic-numbers
            var belowPointByHalfSpaceBetweenRows = this.pointController.getBottom() + globalConstants.spaceBetweenRows / 2; // eslint-disable-line no-magic-numbers
            var endY = Math.max(totalVerticalOffset, belowPointByHalfSpaceBetweenRows, this.pointY);
            var endX = this.pointController.getLeft();

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to.
            return this.canvas.path('M ' + startX + ', ' + startY + ' V ' + endY + ' H ' + endX);
        }

        /**
            Move the label into position.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            var horizontalOffset = 7;
            var verticalOffset = -6;

            moveLabelInFalseBranchIntoPosition(label, this.ifNodeController, horizontalOffset, verticalOffset);
        }
    }]);

    return MergeTrueToMergeFalseEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported NodeBackToLoopEdgeController */
/* global FlowchartEdgeController, moveLabelInFalseBranchIntoPosition, globalConstants */

/**
    Control the edge from a node inside a loop back to the loop node.
    @class NodeBackToLoopEdgeController
    @extends FlowchartEdgeController
*/

var NodeBackToLoopEdgeController = function (_FlowchartEdgeControl7) {
    _inherits(NodeBackToLoopEdgeController, _FlowchartEdgeControl7);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {FlowchartNodeController} startNodeController The controller of the node from which the edge starts.
        @param {FlowchartNodeController} loopNodeController The controller of the node from which the edge ends, which is a loop node.
        @param {String} [labelText=''] The label's text for the edge.
    */
    function NodeBackToLoopEdgeController(canvas, startNodeController, loopNodeController) {
        var labelText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

        _classCallCheck(this, NodeBackToLoopEdgeController);

        /**
            The controller of the node from which the edge starts.
            @property startNodeController
            @type {FlowchartNodeController}
        */
        var _this20 = _possibleConstructorReturn(this, (NodeBackToLoopEdgeController.__proto__ || Object.getPrototypeOf(NodeBackToLoopEdgeController)).call(this, canvas, labelText));

        _this20.startNodeController = startNodeController;

        /**
            The controller of the node from which the edge ends, which is a loop node.
            @property loopNodeController
            @type {FlowchartNodeController}
        */
        _this20.loopNodeController = loopNodeController;
        return _this20;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(NodeBackToLoopEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var bottomOfNode = this.startNodeController.getBottom();
            var horizontalCenterOfNode = this.startNodeController.getHorizontalCenter();
            var startPosition = horizontalCenterOfNode + ', ' + bottomOfNode;
            var downwardEdgeLength = globalConstants.spaceBetweenRows / 2; // eslint-disable-line no-magic-numbers
            var loopNodeRight = this.loopNodeController.getRight() + globalConstants.spaceBetweenColumns / 2; // eslint-disable-line no-magic-numbers
            var bottomOfText = this.loopNodeController.getVerticalHalfwayBetweenRightAndBottomCorners();
            var rightOfText = this.loopNodeController.getHorizontalHalfwayBetweenRightAndBottomCorners();
            var endPosition = rightOfText + ', ' + bottomOfText;

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to. (L)ine to.
            return this.canvas.path('M ' + startPosition + ' V ' + (bottomOfNode + downwardEdgeLength) + ' H ' + loopNodeRight + ' L ' + endPosition);
        }

        /**
            Move the label into position.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            moveLabelInFalseBranchIntoPosition(label, this.startNodeController);
        }
    }]);

    return NodeBackToLoopEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported PointBackToLoopNodeEdgeController */
/* global FlowchartEdgeController, globalConstants */

/**
    Control an edge that goes from a MergeFalse to BackToLoop.
    @class PointBackToLoopNodeEdgeController
    @extends FlowchartEdgeController
*/

var PointBackToLoopNodeEdgeController = function (_FlowchartEdgeControl8) {
    _inherits(PointBackToLoopNodeEdgeController, _FlowchartEdgeControl8);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {PointController} pointController The controller of the point from which the edge starts.
        @param {LoopNodeController} loopNodeController The controller of the loop node from which the edge ends.
        @param {NodeController} nodeBeforeLoopController The last node in the loop, so this edge goes downward enough.
        @param {EdgeController} previousEdgeController The edge controller before this edge controller.
    */
    function PointBackToLoopNodeEdgeController(canvas, pointController, loopNodeController, nodeBeforeLoopController, previousEdgeController) {
        _classCallCheck(this, PointBackToLoopNodeEdgeController);

        /**
            The controller of the pointer from which the edge starts.
            @property pointController
            @type {PointController}
        */
        var _this21 = _possibleConstructorReturn(this, (PointBackToLoopNodeEdgeController.__proto__ || Object.getPrototypeOf(PointBackToLoopNodeEdgeController)).call(this, canvas));

        _this21.pointController = pointController;

        /**
            The controller of the loop node from which the edge ends.
            @property loopNodeController
            @type {LoopNodeController}
        */
        _this21.loopNodeController = loopNodeController;

        /**
            The last node in the loop, so this edge goes downward enough.
            @property nodeBeforeLoopController
            @type {NodeController}
        */
        _this21.nodeBeforeLoopController = nodeBeforeLoopController;

        /**
            The edge controller before this edge controller.
            @property previousEdgeController
            @type {EdgeController}
        */
        _this21.previousEdgeController = previousEdgeController;
        return _this21;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(PointBackToLoopNodeEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var startX = this.pointController.getHorizontalCenter();
            var startY = this.pointController.getBottom();
            var largestY = Math.max(this.nodeBeforeLoopController.getBottom(), this.previousEdgeController.getBottom());
            var largestYWithOffset = largestY + 3 * globalConstants.spaceBetweenRows / 4; // eslint-disable-line no-magic-numbers
            var loopRight = this.loopNodeController.getRight() + globalConstants.spaceBetweenColumns / 2; // eslint-disable-line no-magic-numbers
            var endX = this.loopNodeController.getHorizontalHalfwayBetweenRightAndBottomCorners();
            var endY = this.loopNodeController.getVerticalHalfwayBetweenRightAndBottomCorners();

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to. (L)ine to.
            return this.canvas.path('M ' + startX + ', ' + startY + ' V ' + largestYWithOffset + ' H ' + loopRight + ' L ' + endX + ', ' + endY);
        }
    }]);

    return PointBackToLoopNodeEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported PointToNodeEdgeController */
/* global FlowchartEdgeController, globalConstants */

/**
    Control the edge from a point to a node.
    @class PointToNodeEdgeController
    @extends FlowchartEdgeController
*/

var PointToNodeEdgeController = function (_FlowchartEdgeControl9) {
    _inherits(PointToNodeEdgeController, _FlowchartEdgeControl9);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {PointController} pointController The controller of the point from which the edge starts.
        @param {FlowchartNodeController} nodeController The controller of the node from which the edge ends.
    */
    function PointToNodeEdgeController(canvas, pointController, nodeController) {
        _classCallCheck(this, PointToNodeEdgeController);

        /**
            The controller of the point from which the edge starts.
            @property pointController
            @type {PointController}
        */
        var _this22 = _possibleConstructorReturn(this, (PointToNodeEdgeController.__proto__ || Object.getPrototypeOf(PointToNodeEdgeController)).call(this, canvas));

        _this22.pointController = pointController;

        /**
            The controller of the node from which the edge ends.
            @property nodeController
            @type {FlowchartNodeController}
        */
        _this22.nodeController = nodeController;
        return _this22;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(PointToNodeEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var startX = this.pointController.getHorizontalCenter();
            var startY = this.pointController.getBottom();
            var endX = this.nodeController.getHorizontalCenter();
            var endY = this.nodeController.getTop();

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to.
            return this.canvas.path('M ' + startX + ', ' + startY + ' V ' + (endY - globalConstants.spaceBetweenRows) + ' H ' + endX + ' V ' + endY);
        }
    }]);

    return PointToNodeEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported PointToPointEdgeController */
/* global FlowchartEdgeController */

/**
    Control an edge that goes from a point to another.
    @class PointToPointEdgeController
    @extends FlowchartEdgeController
*/

var PointToPointEdgeController = function (_FlowchartEdgeControl10) {
    _inherits(PointToPointEdgeController, _FlowchartEdgeControl10);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {PointController} startPointerController The controller of the pointer from which the edge starts.
        @param {PointController} endPointerController The controller of the pointer from which the edge ends.
    */
    function PointToPointEdgeController(canvas, startPointerController, endPointerController) {
        _classCallCheck(this, PointToPointEdgeController);

        /**
            The controller of the pointer from which the edge starts.
            @property startPointerController
            @type {PointController}
        */
        var _this23 = _possibleConstructorReturn(this, (PointToPointEdgeController.__proto__ || Object.getPrototypeOf(PointToPointEdgeController)).call(this, canvas));

        _this23.startPointerController = startPointerController;

        /**
            The controller of the pointer from which the edge ends.
            @property endPointerController
            @type {PointController}
        */
        _this23.endPointerController = endPointerController;
        return _this23;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(PointToPointEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var startX = this.startPointerController.getHorizontalCenter();
            var startY = this.startPointerController.getBottom();
            var endX = this.endPointerController.getLeft();
            var endY = this.endPointerController.getVerticalCenter();

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to.
            return this.canvas.path('M ' + startX + ', ' + startY + ' V ' + endY + ' H ' + endX);
        }
    }]);

    return PointToPointEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported SelfLoopEdgeController */
/* global TrueBranchEdgeController */

/**
    Control a self-loop edge for a loop node.
    @class SelfLoopEdgeController
    @extends TrueBranchEdgeController
*/

var SelfLoopEdgeController = function (_TrueBranchEdgeContro) {
    _inherits(SelfLoopEdgeController, _TrueBranchEdgeContro);

    function SelfLoopEdgeController() {
        _classCallCheck(this, SelfLoopEdgeController);

        return _possibleConstructorReturn(this, (SelfLoopEdgeController.__proto__ || Object.getPrototypeOf(SelfLoopEdgeController)).apply(this, arguments));
    }

    _createClass(SelfLoopEdgeController, [{
        key: 'makeEdge',


        /**
            Make the edge.
            @method makeEdge
            @return {Object} Reference to a Raphael shape.
        */
        value: function makeEdge() {
            var rightOfDiamond = this.loopNodeController.getRightAtVerticalCenter();
            var verticalCenterOfDiamond = this.loopNodeController.getVerticalCenter();
            var bottomOfText = this.loopNodeController.getVerticalHalfwayBetweenRightAndBottomCorners();
            var rightOfText = this.loopNodeController.getHorizontalHalfwayBetweenRightAndBottomCorners();
            var startPosition = rightOfDiamond + ', ' + verticalCenterOfDiamond;
            var horizontalLineLength = 30;
            var horizontalEdge = rightOfDiamond + horizontalLineLength;
            var verticalEdge = this.loopNodeController.getBottom();
            var endPosition = rightOfText + ', ' + bottomOfText;

            // Notation meanings: (M)ove to. (V)ertical line to. (H)orizontal line to. (V)ertical line to. (L)ine to.
            return this.canvas.path('M' + startPosition + ' H' + horizontalEdge + ' V' + verticalEdge + ' H' + rightOfDiamond + ' L' + endPosition);
        }
    }]);

    return SelfLoopEdgeController;
}(TrueBranchEdgeController);

'use strict';

/* exported StraightHorizontalEdgeController */
/* global FlowchartEdgeController, moveLabelInTrueBranchIntoPosition */

/**
    Control a straight, horizontal edge.
    @class StraightHorizontalEdgeController
    @extends FlowchartEdgeController
*/

var StraightHorizontalEdgeController = function (_FlowchartEdgeControl11) {
    _inherits(StraightHorizontalEdgeController, _FlowchartEdgeControl11);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {FlowchartNodeController} nodeController The controller of the node from which the edge starts.
        @param {FlowchartElementController} flowchartElementController The controller of the element from which the edge ends.
        @param {String} [labelText=''] The label's text for the edge.
    */
    function StraightHorizontalEdgeController(canvas, nodeController, flowchartElementController) {
        var labelText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

        _classCallCheck(this, StraightHorizontalEdgeController);

        /**
            The controller of the node from which the edge starts.
            @property nodeController
            @type {FlowchartNodeController}
        */
        var _this25 = _possibleConstructorReturn(this, (StraightHorizontalEdgeController.__proto__ || Object.getPrototypeOf(StraightHorizontalEdgeController)).call(this, canvas, labelText));

        _this25.nodeController = nodeController;

        /**
            The controller of the element from which the edge ends.
            @property flowchartElementController
            @type {FlowchartElementController}
        */
        _this25.flowchartElementController = flowchartElementController;
        return _this25;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(StraightHorizontalEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var xCoordinate = this.nodeController.getRightAtVerticalCenter();
            var yCoordinate = this.nodeController.getVerticalCenter();
            var elementX = this.flowchartElementController.getLeftAtVerticalCenter();

            // Notation meanings: (M)ove to. (H)orizontal line to.
            return this.canvas.path('M ' + xCoordinate + ', ' + yCoordinate + ' H ' + elementX);
        }

        /**
            Move the label into position.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            var verticalOffset = 9;

            moveLabelInTrueBranchIntoPosition(label, this.nodeController, verticalOffset);
        }
    }]);

    return StraightHorizontalEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported StraightVerticalEdgeController */
/* global FlowchartEdgeController, moveLabelInFalseBranchIntoPosition */

/**
    Control a straight, vertical edge.
    @class StraightVerticalEdgeController
    @extends FlowchartEdgeController
*/

var StraightVerticalEdgeController = function (_FlowchartEdgeControl12) {
    _inherits(StraightVerticalEdgeController, _FlowchartEdgeControl12);

    /**
        @constructor
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
        @param {FlowchartNodeController} startNodeController The controller of the node from which the edge starts.
        @param {FlowchartNodeController} endNodeController The controller of the node from which the edge ends.
        @param {String} [labelText=''] The label's text for the edge.
    */
    function StraightVerticalEdgeController(canvas, startNodeController, endNodeController) {
        var labelText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

        _classCallCheck(this, StraightVerticalEdgeController);

        /**
            The controller of the node from which the edge starts.
            @property startNodeController
            @type {FlowchartNodeController}
        */
        var _this26 = _possibleConstructorReturn(this, (StraightVerticalEdgeController.__proto__ || Object.getPrototypeOf(StraightVerticalEdgeController)).call(this, canvas, labelText));

        _this26.startNodeController = startNodeController;

        /**
            The controller of the node from which the edge ends.
            @property endNodeController
            @type {FlowchartNodeController}
        */
        _this26.endNodeController = endNodeController;
        return _this26;
    }

    /**
        Make the edge.
        @method makeEdge
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(StraightVerticalEdgeController, [{
        key: 'makeEdge',
        value: function makeEdge() {
            var top = this.startNodeController.getBottom();
            var xCoordinate = this.startNodeController.getHorizontalCenter();
            var bottom = this.endNodeController.getTop();

            // Notation meanings: (M)ove to. (V)ertical line to.
            return this.canvas.path('M ' + xCoordinate + ', ' + top + ' V ' + bottom);
        }

        /**
            Move the label into position.
            @method moveLabelIntoPosition
            @param {Object} label Reference to the label.
            @return {void}
        */

    }, {
        key: 'moveLabelIntoPosition',
        value: function moveLabelIntoPosition(label) {
            moveLabelInFalseBranchIntoPosition(label, this.startNodeController);
        }
    }]);

    return StraightVerticalEdgeController;
}(FlowchartEdgeController);

'use strict';

/* exported moveLabelInFalseBranchIntoPosition, moveLabelInTrueBranchIntoPosition */

/**
    Move the given label to be just below the given node, and slightly off-center to the left.
    @method moveLabelInFalseBranchIntoPosition
    @param {Object} label Reference to the label.
    @param {FlowchartNodeController} nodeController Controller of the node from which to position the label.
    @param {Integer} [horizontalOffset=3] The horizontal offset for the text location.
    @param {Integer} [verticalOffset=1] The vertical offset for the text location.
    @return {void}
*/
function moveLabelInFalseBranchIntoPosition(label, nodeController) {
    var horizontalOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
    var verticalOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    // eslint-disable-line no-magic-numbers
    var horizontalCenter = nodeController.getHorizontalCenter();
    var bottom = nodeController.getBottom();
    var labelBBox = label.getBBox();

    label.attr({
        x: horizontalCenter + labelBBox.width / 2 + horizontalOffset, // eslint-disable-line
        y: bottom + labelBBox.height / 2 + verticalOffset // eslint-disable-line
    });
}

/**
    Move the given label to be right of the given node, and slightly off-center to the top.
    @method moveLabelInTrueBranchIntoPosition
    @param {Object} label Reference to the label.
    @param {FlowchartNodeController} nodeController Controller of the node from which to position the label.
    @param {Integer} [verticalOffset=8] The vertical offset for the text location.
    @return {void}
*/
function moveLabelInTrueBranchIntoPosition(label, nodeController) {
    var verticalOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
    // eslint-disable-line no-magic-numbers
    var verticalCenterOfDiamond = nodeController.getVerticalCenter();
    var labelBBox = label.getBBox();
    var rightOfDiamond = nodeController.getRight();
    var horizontalOffset = 2;

    label.attr({
        x: rightOfDiamond + labelBBox.width / 2 - horizontalOffset, // eslint-disable-line
        y: verticalCenterOfDiamond - verticalOffset // eslint-disable-line id-length
    });
}

'use strict';

/* exported FlowchartNodeController */
/* global FlowchartElementController */

/**
    Abstract controller for a node.
    @class FlowchartNodeController
    @extends FlowchartElementController
*/

var FlowchartNodeController = function (_FlowchartElementCont3) {
    _inherits(FlowchartNodeController, _FlowchartElementCont3);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function FlowchartNodeController(node, canvas) {
        _classCallCheck(this, FlowchartNodeController);

        /**
            The node to control.
            @property node
            @type {FlowchartNode}
        */
        var _this27 = _possibleConstructorReturn(this, (FlowchartNodeController.__proto__ || Object.getPrototypeOf(FlowchartNodeController)).call(this, canvas));

        _this27.node = node;

        /**
            The code to print on the node.
            @property nodeCode
            @type {String}
            @default ''
        */
        _this27.nodeCode = node.userExpression;

        /**
            The node's comment as a single string.
            @property nodeComment
            @type {String}
        */
        _this27.nodeComment = node.comments.join('\n');

        /**
            The amount of padding around the text.
            @property textPadding
            @type {Integer}
            @default 12
        */
        _this27.textPadding = 12;
        return _this27;
    }

    /**
        Render the start node.
        @method render
        @return {void}
    */


    _createClass(FlowchartNodeController, [{
        key: 'render',
        value: function render() {
            var comment = this.canvas.text(0, 0, this.nodeComment);
            var code = this.canvas.text(0, 0, this.nodeCode);
            var fontOptions = {
                'font-family': '\'Roboto\', sans-serif',
                'font-size': '12px'
            };

            comment.attr(fontOptions).attr('fill', '#999');
            code.attr(fontOptions).attr('fill', require('utilities').zyanteGray);

            var heightOfCommentAndText = comment.getBBox().height + code.getBBox().height;
            var widthOfCommentAndText = Math.max(comment.getBBox().width, code.getBBox().width);
            var heightWithPadding = heightOfCommentAndText + this.textPadding;
            var widthWithPadding = widthOfCommentAndText + this.textPadding;
            var shape = this.makeNodeShape(widthWithPadding, heightWithPadding);
            var zyAnimatorOrange = 'rgb(217, 133, 80)';
            var zyAnimatorLightOrange = 'rgb(249, 216, 188)';
            var zyAnimatorBlue = 'rgb(94, 129, 213)';
            var fill = this.node.isNextToExecute ? zyAnimatorLightOrange : 'white';
            var stroke = this.node.isNextToExecute ? zyAnimatorOrange : zyAnimatorBlue;
            var strokeWidth = 2;

            shape.toBack();
            shape.attr({
                fill: fill,
                stroke: stroke,
                'stroke-width': strokeWidth
            });

            // Find the center of the shape.
            var shapeCenterX = shape.getBBox().width / 2; // eslint-disable-line no-magic-numbers
            var shapeCenterY = shape.getBBox().height / 2; // eslint-disable-line no-magic-numbers

            /*
                The shape contains the comment and code, with the comment directly above the code.
                The x and y coordinates that are being set are to the center of the comment.
                We want the comment and code to be horizontally centered within the box, so their y is the shape's horizontal center.
                We want the comment to be directly above the code, so from the vertical center, subtract the code's height / 2.
                 Node shape has height 30.
                _____________________
                |___________________| Comment has 10 height
                |                   |
                |___________________| Code has 20 height
                 Node's vertical center is 15.
                Comment's vertical center is 5, computed by: node's vertical center - code's height / 2 = 15 - (20 / 2) = 5
                Code's vertical center is 20, computed by: node's vertical center + comment's height / 2 = 15 + (10 / 2) = 20
            */
            comment.attr({
                x: shapeCenterX, // eslint-disable-line id-length
                y: shapeCenterY - code.getBBox().height / 2 // eslint-disable-line
            });

            code.attr({
                x: shapeCenterX, // eslint-disable-line id-length
                y: shapeCenterY + comment.getBBox().height / 2 // eslint-disable-line
            });

            this.drawing.push(shape, code, comment);

            var nodeContentBackground = this.makeNodeContentBackground(comment, code, shape, widthOfCommentAndText, heightOfCommentAndText);

            if (nodeContentBackground) {
                comment.toFront();
                code.toFront();
                this.drawing.push(nodeContentBackground);
            }
        }

        /**
            Make a background for the node content. Most nodes don't have one. Decision nodes do.
            @method makeNodeContentBackground
            @param {Object} comment Reference to the Raphael shape for the comment.
            @param {Object} code Reference to the Raphael shape for the code.
            @param {Object} shape Reference to the Raphael shape for the node.
            @param {Number} widthOfCommentAndText The width of the comment and text in the node.
            @param {Number} heightOfCommentAndText The height of the comment and text in the node.
            @return {Object} Reference to a Raphael shape.
        */

    }, {
        key: 'makeNodeContentBackground',
        value: function makeNodeContentBackground(comment, code, shape, widthOfCommentAndText, heightOfCommentAndText) {
            // eslint-disable-line no-unused-vars
            return null;
        }

        /**
            Return a reference to a Raphael shape. Inheriting controllers must override.
            @method makeNodeShape
            @param {Number} textWidth The width of the text.
            @param {Number} textHeight The height of the text.
            @return {Object} Reference to a Raphael shape.
        */

    }, {
        key: 'makeNodeShape',
        value: function makeNodeShape(textWidth, textHeight) {
            // eslint-disable-line no-unused-vars
            throw new Error('FlowchartNodeController\'s makeNodeShape function should be overridden');
        }
    }]);

    return FlowchartNodeController;
}(FlowchartElementController);

'use strict';

/* exported ProcessNodeController */
/* global FlowchartNodeController */

/**
    Controller for rendering and controlling a process node.
    @class ProcessNodeController
    @extends FlowchartNodeController
*/

var ProcessNodeController = function (_FlowchartNodeControl) {
    _inherits(ProcessNodeController, _FlowchartNodeControl);

    function ProcessNodeController() {
        _classCallCheck(this, ProcessNodeController);

        return _possibleConstructorReturn(this, (ProcessNodeController.__proto__ || Object.getPrototypeOf(ProcessNodeController)).apply(this, arguments));
    }

    _createClass(ProcessNodeController, [{
        key: 'makeNodeShape',


        /**
            Return a reference to a Raphael shape.
            @method makeNodeShape
            @param {Number} textWidth The width of the text.
            @param {Number} textHeight The height of the text.
            @return {Object} Reference to a Raphael shape.
        */
        value: function makeNodeShape(textWidth, textHeight) {
            return this.canvas.rect(0, 0, textWidth, textHeight);
        }
    }]);

    return ProcessNodeController;
}(FlowchartNodeController);

'use strict';

/* exported FlowchartFirstOrLastNodeController */
/* global FlowchartNodeController */

/**
    Abstract controller for rendering and controlling a first or last node in a flowchart.
    @class FlowchartFirstOrLastNodeController
    @extends FlowchartNodeController
*/

var FlowchartFirstOrLastNodeController = function (_FlowchartNodeControl2) {
    _inherits(FlowchartFirstOrLastNodeController, _FlowchartNodeControl2);

    function FlowchartFirstOrLastNodeController() {
        _classCallCheck(this, FlowchartFirstOrLastNodeController);

        return _possibleConstructorReturn(this, (FlowchartFirstOrLastNodeController.__proto__ || Object.getPrototypeOf(FlowchartFirstOrLastNodeController)).apply(this, arguments));
    }

    _createClass(FlowchartFirstOrLastNodeController, [{
        key: 'makeNodeShape',


        /**
            Return a reference to a Raphael shape.
            @method makeNodeShape
            @param {Number} textWidth The width of the text.
            @param {Number} textHeight The height of the text.
            @return {Object} Reference to a Raphael shape.
        */
        value: function makeNodeShape(textWidth, textHeight) {
            var radius = textWidth;

            return this.canvas.rect(0, 0, textWidth, textHeight, radius);
        }
    }]);

    return FlowchartFirstOrLastNodeController;
}(FlowchartNodeController);

'use strict';

/* exported InputOrOutputNodeController */
/* global FlowchartNodeController */

/**
    Abstract controller for rendering and controlling an input or output node.
    @class InputOrOutputNodeController
    @extends FlowchartNodeController
*/

var InputOrOutputNodeController = function (_FlowchartNodeControl3) {
    _inherits(InputOrOutputNodeController, _FlowchartNodeControl3);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function InputOrOutputNodeController(node, canvas) {
        _classCallCheck(this, InputOrOutputNodeController);

        /**
            The width of the parallelogram's angle.
            @property parallelogramAngleWidth
            @type {Number}
            @default null
        */
        var _this30 = _possibleConstructorReturn(this, (InputOrOutputNodeController.__proto__ || Object.getPrototypeOf(InputOrOutputNodeController)).call(this, node, canvas));

        _this30.parallelogramAngleWidth = null;
        return _this30;
    }

    /**
        Return a reference to a Raphael shape.
        @method makeNodeShape
        @param {Number} textWidth The width of the text.
        @param {Number} textHeight The height of the text.
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(InputOrOutputNodeController, [{
        key: 'makeNodeShape',
        value: function makeNodeShape(textWidth, textHeight) {
            var parallelogramAngleRadians = 1.2;

            this.parallelogramAngleWidth = textHeight / Math.tan(parallelogramAngleRadians);

            var bottomLeft = '0, ' + textHeight;
            var topLeft = this.parallelogramAngleWidth + ', 0';
            var topRight = 2 * this.parallelogramAngleWidth + textWidth + ', 0'; // eslint-disable-line no-magic-numbers
            var bottomRight = this.parallelogramAngleWidth + textWidth + ', ' + textHeight;

            // Notation meanings: (M)ove to. (L)ine to. Z means close path.
            return this.canvas.path('M ' + bottomLeft + ' L ' + topLeft + ' L ' + topRight + ' L ' + bottomRight + ' Z');
        }

        /**
            Return the x-position of the left of the element at vertical-center.
            @method getLeftAtVerticalCenter
            @return {Number} The x-position of the left of the element at vertical-center.
        */

    }, {
        key: 'getLeftAtVerticalCenter',
        value: function getLeftAtVerticalCenter() {
            return this.getLeft() + this.parallelogramAngleWidth / 2; // eslint-disable-line no-magic-numbers
        }

        /**
            Return the x-position of the right of the element at vertical-center.
            @method getRightAtVerticalCenter
            @return {Number} The x-position of the right of the element at vertical-center.
        */

    }, {
        key: 'getRightAtVerticalCenter',
        value: function getRightAtVerticalCenter() {
            return this.getRight() - this.parallelogramAngleWidth / 2; // eslint-disable-line no-magic-numbers
        }
    }]);

    return InputOrOutputNodeController;
}(FlowchartNodeController);

'use strict';

/* exported AssignmentNodeController */
/* global ProcessNodeController */

/**
    Controller for rendering and controlling an assignment node.
    @class AssignmentNodeController
    @extends ProcessNodeController
*/

var AssignmentNodeController = function (_ProcessNodeControlle) {
    _inherits(AssignmentNodeController, _ProcessNodeControlle);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function AssignmentNodeController(node, canvas) {
        _classCallCheck(this, AssignmentNodeController);

        var _this31 = _possibleConstructorReturn(this, (AssignmentNodeController.__proto__ || Object.getPrototypeOf(AssignmentNodeController)).call(this, node, canvas));

        _this31.nodeCode = node.userAssignedExpression + ' = ' + node.userExpression;
        return _this31;
    }

    return AssignmentNodeController;
}(ProcessNodeController);

'use strict';

/* exported DecisionNodeController */
/* global FlowchartNodeController */

/**
    Controller for rendering and controlling a decision node.
    @class DecisionNodeController
    @extends FlowchartNodeController
*/

var DecisionNodeController = function (_FlowchartNodeControl4) {
    _inherits(DecisionNodeController, _FlowchartNodeControl4);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function DecisionNodeController(node, canvas) {
        _classCallCheck(this, DecisionNodeController);

        /**
            The padding around the node content background.
            @property nodeContentBackgroundPadding
            @type {Number}
            @default 4
        */
        var _this32 = _possibleConstructorReturn(this, (DecisionNodeController.__proto__ || Object.getPrototypeOf(DecisionNodeController)).call(this, node, canvas));

        _this32.nodeContentBackgroundPadding = 4;

        // The text padding needs to account for the node content background padding.
        _this32.textPadding += _this32.nodeContentBackgroundPadding;
        return _this32;
    }

    /**
        Return a reference to a Raphael shape.
        @method makeNodeShape
        @param {Number} textWidth The width of the text.
        @param {Number} textHeight The height of the text.
        @return {Object} Reference to a Raphael shape.
    */


    _createClass(DecisionNodeController, [{
        key: 'makeNodeShape',
        value: function makeNodeShape(textWidth, textHeight) {
            var minHeight = 55;
            var minWidth = 120;
            var height = Math.max(textHeight, minHeight);
            var width = Math.max(textWidth, minWidth);
            var halfHeight = height / 2; // eslint-disable-line no-magic-numbers
            var halfWidth = width / 2; // eslint-disable-line no-magic-numbers
            var leftCorner = '0, ' + halfHeight;
            var topCorner = halfWidth + ', 0';
            var rightCorner = width + ', ' + halfHeight;
            var bottomCorner = halfWidth + ', ' + height;

            // Notation meanings: (M)ove to. (L)ine to. Z means close path.
            return this.canvas.path('M ' + leftCorner + ' L ' + topCorner + ' L ' + rightCorner + ' L ' + bottomCorner + ' Z');
        }

        /**
            Make a background for the node content. Most nodes don't have one. Decision nodes do.
            @method makeNodeContentBackground
            @param {Object} comment Reference to the Raphael shape for the comment.
            @param {Object} code Reference to the Raphael shape for the code.
            @param {Object} shape Reference to the Raphael shape for the node.
            @param {Number} widthOfCommentAndText The width of the comment and text in the node.
            @param {Number} heightOfCommentAndText The height of the comment and text in the node.
            @return {Object} Reference to a Raphael shape.
        */

    }, {
        key: 'makeNodeContentBackground',
        value: function makeNodeContentBackground(comment, code, shape, widthOfCommentAndText, heightOfCommentAndText) {
            var nodeContentBackground = null;

            /*
                Don't draw background if node content fits inside the node. To determine:
                1. Note that node content is centered in the node, so only need to check if one corner of the node content is outside the node.
                2. Determine the line of the top-left edge of the node, which has coordinates: (0, height / 2) and (width / 2, 0)
                    See makeNodeShape function for the left-corner and top-corner.
                    So, given those coordinates, solve for y = mx + b.
                    b is the y-intercept, which is: height / 2
                    m is the slope, which is: (0 - (height / 2)) / ((width / 2) - 0) = -(height / 2) / (width / 2) = -height / width
                3. Determine whether the top-left corner of the node content it outside that node. That is:
                    if top-most < ((m * left-most) + b), then the content is outside the node.
                    Note that top-most and left-most are the values nearest the coordinate origin (0, 0).
            */
            var leftMostContent = this.nodeComment ? Math.min(comment.getBBox().x, code.getBBox().x) : code.getBBox().x;
            var topMostContent = this.nodeComment ? comment.getBBox().y : code.getBBox().y;
            var yIntercept = shape.getBBox().height / 2; // eslint-disable-line no-magic-numbers
            var slope = -1 * shape.getBBox().height / shape.getBBox().width;
            var yValueOfLeftMost = slope * leftMostContent + yIntercept;

            if (topMostContent < yValueOfLeftMost) {
                var halfPadding = this.nodeContentBackgroundPadding / 2; // eslint-disable-line no-magic-numbers

                nodeContentBackground = this.canvas.rect(leftMostContent - halfPadding, topMostContent - halfPadding, widthOfCommentAndText + this.nodeContentBackgroundPadding, heightOfCommentAndText + this.nodeContentBackgroundPadding);

                nodeContentBackground.attr({
                    fill: 'white',
                    stroke: '#ddd',
                    'stroke-width': 1
                });
            }

            return nodeContentBackground;
        }

        /**
            Return the vertical-halfway point between the right and bottom corners.
            @method getVerticalHalfwayBetweenRightAndBottomCorners
            @return {String} The vertical-halfway point between the right and bottom corners.
        */

    }, {
        key: 'getVerticalHalfwayBetweenRightAndBottomCorners',
        value: function getVerticalHalfwayBetweenRightAndBottomCorners() {

            /*
                Want halfway point between center y (centerY) and bottom-most y (bottomY).
                That is, we want to go (bottomY - centerY) / 2 beyond centerY, which is:
                centerY + ((bottomY - centerY) / 2)
                (centerY - (centerY / 2)) + (bottomY / 2)
                (centerY / 2) + (bottomY / 2)
                (centerY + bottomY) / 2
            */
            return (this.getVerticalCenter() + this.getBottom()) / 2; // eslint-disable-line no-magic-numbers
        }

        /**
            Return the vertical-halfway point between the right and bottom corners.
            @method getHorizontalHalfwayBetweenRightAndBottomCorners
            @return {String} The vertical-halfway point between the right and bottom corners.
        */

    }, {
        key: 'getHorizontalHalfwayBetweenRightAndBottomCorners',
        value: function getHorizontalHalfwayBetweenRightAndBottomCorners() {

            /*
                Want halfway point between center x (centerX) and right-most x (rightX).
                That is, we want to go (rightX - centerX) / 2 beyond centerX, which is:
                centerX + ((rightX - centerX) / 2)
                (centerX - (centerX / 2)) + (rightX / 2)
                (centerX / 2) + (rightX / 2)
                (centerX + rightX) / 2
            */
            return (this.getHorizontalCenter() + this.getRight()) / 2; // eslint-disable-line no-magic-numbers
        }
    }]);

    return DecisionNodeController;
}(FlowchartNodeController);

'use strict';

/* exported ElseIfNodeController */
/* global DecisionNodeController */

/**
    Controller for rendering and controlling an elseif node.
    @class ElseIfNodeController
    @extends DecisionNodeController
*/

var ElseIfNodeController = function (_DecisionNodeControll) {
    _inherits(ElseIfNodeController, _DecisionNodeControll);

    function ElseIfNodeController() {
        _classCallCheck(this, ElseIfNodeController);

        return _possibleConstructorReturn(this, (ElseIfNodeController.__proto__ || Object.getPrototypeOf(ElseIfNodeController)).apply(this, arguments));
    }

    return ElseIfNodeController;
}(DecisionNodeController);

'use strict';

/* exported EndNodeController */
/* global FlowchartFirstOrLastNodeController */

/**
    Render and control an end node.
    @class EndNodeController
    @extends FlowchartFirstOrLastNodeController
*/

var EndNodeController = function (_FlowchartFirstOrLast) {
    _inherits(EndNodeController, _FlowchartFirstOrLast);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function EndNodeController(node, canvas) {
        _classCallCheck(this, EndNodeController);

        var _this34 = _possibleConstructorReturn(this, (EndNodeController.__proto__ || Object.getPrototypeOf(EndNodeController)).call(this, node, canvas));

        _this34.nodeCode = 'End';
        return _this34;
    }

    return EndNodeController;
}(FlowchartFirstOrLastNodeController);

'use strict';

/* exported FunctionCallNodeController */
/* global ProcessNodeController */

/**
    Controller for rendering and controlling a function call node.
    @class FunctionCallNodeController
    @extends ProcessNodeController
*/

var FunctionCallNodeController = function (_ProcessNodeControlle2) {
    _inherits(FunctionCallNodeController, _ProcessNodeControlle2);

    function FunctionCallNodeController() {
        _classCallCheck(this, FunctionCallNodeController);

        return _possibleConstructorReturn(this, (FunctionCallNodeController.__proto__ || Object.getPrototypeOf(FunctionCallNodeController)).apply(this, arguments));
    }

    return FunctionCallNodeController;
}(ProcessNodeController);

'use strict';

/* exported IfNodeController */
/* global DecisionNodeController */

/**
    Controller for rendering and controlling an if node.
    @class IfNodeController
    @extends DecisionNodeController
*/

var IfNodeController = function (_DecisionNodeControll2) {
    _inherits(IfNodeController, _DecisionNodeControll2);

    function IfNodeController() {
        _classCallCheck(this, IfNodeController);

        return _possibleConstructorReturn(this, (IfNodeController.__proto__ || Object.getPrototypeOf(IfNodeController)).apply(this, arguments));
    }

    return IfNodeController;
}(DecisionNodeController);

'use strict';

/* exported InputNodeController */
/* global InputOrOutputNodeController */

/**
    Controller for rendering and controlling an input node.
    @class InputNodeController
    @extends InputOrOutputNodeController
*/

var InputNodeController = function (_InputOrOutputNodeCon) {
    _inherits(InputNodeController, _InputOrOutputNodeCon);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function InputNodeController(node, canvas) {
        _classCallCheck(this, InputNodeController);

        var _this37 = _possibleConstructorReturn(this, (InputNodeController.__proto__ || Object.getPrototypeOf(InputNodeController)).call(this, node, canvas));

        _this37.nodeCode = node.userExpression + ' = Get next input';
        return _this37;
    }

    return InputNodeController;
}(InputOrOutputNodeController);

'use strict';

/* exported LoopNodeController */
/* global DecisionNodeController */

/**
    Controller for rendering and controlling a loop node.
    @class LoopNodeController
    @extends DecisionNodeController
*/

var LoopNodeController = function (_DecisionNodeControll3) {
    _inherits(LoopNodeController, _DecisionNodeControll3);

    function LoopNodeController() {
        _classCallCheck(this, LoopNodeController);

        return _possibleConstructorReturn(this, (LoopNodeController.__proto__ || Object.getPrototypeOf(LoopNodeController)).apply(this, arguments));
    }

    return LoopNodeController;
}(DecisionNodeController);

'use strict';

/* exported NodeControllerFactory */
/* global OutputNodeController, StartNodeController, AssignmentNodeController, DecisionNodeController, EndNodeController,
          IfNodeController, InputNodeController, LoopNodeController, FunctionCallNodeController, ElseIfNodeController */

/**
    A factory to make node controllers.
    @class NodeControllerFactory
*/

var NodeControllerFactory = function () {
    function NodeControllerFactory() {
        _classCallCheck(this, NodeControllerFactory);
    }

    _createClass(NodeControllerFactory, [{
        key: 'make',


        /**
            Return a controller for the given node.
            @method make
            @param {FlowchartNode} node The node for which to make a controller.
            @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
            @return {FlowchartNodeController} A controller for the given node.
        */
        value: function make(node, canvas) {
            switch (node.getName()) {
                case 'AssignmentNode':
                    return new AssignmentNodeController(node, canvas);
                case 'DecisionNode':
                    return new DecisionNodeController(node, canvas);
                case 'ElseIfNode':
                    return new ElseIfNodeController(node, canvas);
                case 'EndNode':
                    return new EndNodeController(node, canvas);
                case 'FunctionCallNode':
                    return new FunctionCallNodeController(node, canvas);
                case 'IfNode':
                    return new IfNodeController(node, canvas);
                case 'InputNode':
                    return new InputNodeController(node, canvas);
                case 'LoopNode':
                    return new LoopNodeController(node, canvas);
                case 'OutputNode':
                    return new OutputNodeController(node, canvas);
                case 'StartNode':
                    return new StartNodeController(node, canvas);
                default:
                    throw new Error('NodeControllerFactory\'s make given unrecognized node name');
            }
        }
    }]);

    return NodeControllerFactory;
}();

'use strict';

/* exported OutputNodeController */
/* global InputOrOutputNodeController */

/**
    Controller for rendering and controlling an output node.
    @class OutputNodeController
    @extends InputOrOutputNodeController
*/

var OutputNodeController = function (_InputOrOutputNodeCon2) {
    _inherits(OutputNodeController, _InputOrOutputNodeCon2);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function OutputNodeController(node, canvas) {
        _classCallCheck(this, OutputNodeController);

        var _this39 = _possibleConstructorReturn(this, (OutputNodeController.__proto__ || Object.getPrototypeOf(OutputNodeController)).call(this, node, canvas));

        _this39.nodeCode = 'Put ' + node.userExpression + ' to output';
        return _this39;
    }

    return OutputNodeController;
}(InputOrOutputNodeController);

'use strict';

/* exported StartNodeController */
/* global FlowchartFirstOrLastNodeController */

/**
    Render and control a start node.
    @class StartNodeController
    @extends FlowchartFirstOrLastNodeController
*/

var StartNodeController = function (_FlowchartFirstOrLast2) {
    _inherits(StartNodeController, _FlowchartFirstOrLast2);

    /**
        @constructor
        @param {FlowchartNode} node The node to control.
        @param {Object} canvas Reference to the Raphael.js instance used to draw the flowchart.
    */
    function StartNodeController(node, canvas) {
        _classCallCheck(this, StartNodeController);

        var _this40 = _possibleConstructorReturn(this, (StartNodeController.__proto__ || Object.getPrototypeOf(StartNodeController)).call(this, node, canvas));

        _this40.nodeCode = 'Start';
        return _this40;
    }

    return StartNodeController;
}(FlowchartFirstOrLastNodeController);

'use strict';

/* exported ProgramFunction */
/* global lookupMemoryCellFromVariableLists */

/**
    Model a program function, storing the function's name, flowchart, parameters, return value, and local variables.
    @class ProgramFunction
*/

var ProgramFunction = function () {

    /**
        @constructor
        @param {String} name The name of the function.
        @param {Variables} locals The function's local variables.
        @param {Variables} parameters The function's parameters.
        @param {Variables} _return The function's return value.
    */
    function ProgramFunction(name, locals, parameters, _return) {
        _classCallCheck(this, ProgramFunction);

        /**
            The name of the function.
            @property name
            @type {String}
        */
        this.name = name;

        /**
            The function's local variables.
            @property locals
            @type {Variables}
        */
        this.locals = locals;

        /**
            The function's parameters.
            @property parameters
            @type {Variables}
        */
        this.parameters = parameters;

        /**
            The function's return value.
            @property return
            @type {Variables}
        */
        this.return = _return;

        /**
            The function's flowchart.
            @property flowchart
            @type {Flowchart}
        */
        this.flowchart = null;
    }

    /**
        Return whether this is a built-in function.
        @method isBuiltIn
        @return {Boolean} Whether this is a built-in function.
    */


    _createClass(ProgramFunction, [{
        key: 'isBuiltIn',
        value: function isBuiltIn() {
            return false;
        }

        /**
            Return a clone of this function.
            @method clone
            @return {ProgramFunction} A clone of this function.
        */

    }, {
        key: 'clone',
        value: function clone() {
            var localsClone = this.locals.clone();
            var parametersClone = this.parameters.clone();
            var returnClone = this.return.clone();
            var arrayOfVariables = [localsClone, parametersClone, returnClone];
            var clone = new ProgramFunction(this.name, localsClone, parametersClone, returnClone);

            clone.flowchart = this.flowchart.clone(arrayOfVariables);

            return clone;
        }

        /**
            Copy the values of the argument list to the parameters during execution.
            @method setParametersDuringExecution
            @param {Array} argumentList Array of {Variable}. The list of arguments to copy by value to the parameters.
            @return {void}
        */

    }, {
        key: 'setParametersDuringExecution',
        value: function setParametersDuringExecution(argumentList) {
            var _this41 = this;

            argumentList.forEach(function (argumentVariable, index) {
                var parameterVariable = _this41.parameters[index];
                var arrayOfVariables = [_this41.locals, _this41.parameters, _this41.return];

                if (parameterVariable.isArray()) {
                    argumentVariable.copyMemoryCellValuesTo(parameterVariable, true, true);
                } else {
                    parameterVariable.setValueDuringExecution(argumentVariable.getValue(arrayOfVariables));
                }
            });
        }

        /**
            Lookup the value of the given variable.
            @method getVariableValueByName
            @param {String} variableName The variable name to look up.
            @return {String} The value of the given variable.
        */

    }, {
        key: 'getVariableValueByName',
        value: function getVariableValueByName(variableName) {
            var arrayOfVariables = [this.locals, this.parameters, this.return];
            var memoryCell = lookupMemoryCellFromVariableLists(variableName, arrayOfVariables);

            return String(memoryCell);
        }
    }]);

    return ProgramFunction;
}();

'use strict';

/* exported BuiltInProgramFunction */
/* global ProgramFunction */

/**
    Model a built-in function.
    @class BuiltInProgramFunction
    @extends ProgramFunction
*/

var BuiltInProgramFunction = function (_ProgramFunction) {
    _inherits(BuiltInProgramFunction, _ProgramFunction);

    /**
        @constructor
        @param {String} name The name of the function.
        @param {Flowchart} flowchart The function's flowchart.
        @param {Variables} locals The function's local variables.
        @param {Variables} parameters The function's parameters.
        @param {Variables} _return The function's return value.
        @param {Function} executionFunction A javascript function to execute the built-in.
    */
    function BuiltInProgramFunction(name, flowchart, locals, parameters, _return, executionFunction) {
        _classCallCheck(this, BuiltInProgramFunction);

        var _this42 = _possibleConstructorReturn(this, (BuiltInProgramFunction.__proto__ || Object.getPrototypeOf(BuiltInProgramFunction)).call(this, name, locals, parameters, _return)); // eslint-disable-line max-params


        _this42.flowchart = flowchart;

        /**
            A javascript function to execute the built-in.
            @property executionFunction
            @type {Function}
        */
        _this42.executionFunction = executionFunction;
        return _this42;
    }

    /**
        Return whether this is a built-in function.
        @method isBuiltIn
        @return {Boolean} Whether this is a built-in function.
    */


    _createClass(BuiltInProgramFunction, [{
        key: 'isBuiltIn',
        value: function isBuiltIn() {
            return true;
        }

        /**
            Execute the built-in function to produce a compute the return variable.
            @method execute
            @param {ExecutionContext} context The relevant flowchart properties for execution.
            @return {void}
        */

    }, {
        key: 'execute',
        value: function execute(context) {
            this.executionFunction(this.parameters, this.return, context);
        }
    }]);

    return BuiltInProgramFunction;
}(ProgramFunction);

'use strict';

/* exported CompilerError */

/**
    An error that occurs during compilation.
    @class CompilerError
*/

var CompilerError = function () {

    /**
        @constructor
        @param {String} errorMessage The compilation error message.
        @param {TokensOfLine} line The line with the error.
        @param {String} [suggestion=''] A suggestion on how to address the error.
    */
    function CompilerError(errorMessage, line) {
        var suggestion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

        _classCallCheck(this, CompilerError);

        var suggestionMessage = suggestion ? '\n' + suggestion : '';

        /**
            The compiler error message.
            @property message
            @type {String}
        */
        this.message = 'Line ' + line.lineNumber + ': ' + errorMessage + suggestionMessage;

        /**
            The line number with the error.
            @property lineNumber
            @type {Integer}
        */
        this.lineNumber = line.lineNumber;
    }

    /**
        Return the error message as a string.
        @method toString
        @return {String} The error message as a string.
    */


    _createClass(CompilerError, [{
        key: 'toString',
        value: function toString() {
            return this.message;
        }
    }]);

    return CompilerError;
}();

'use strict';

/* exported ExecutionContext */

/**
    Model the contextually-relevant values needed for a node to perform an execution.
    @class ExecutionContext
*/

var ExecutionContext =

/**
    @constructor
    @param {NumericalInputComponent} input The input to the program.
    @param {NumericalOutputComponent} output The output of the program.
    @param {Array} arrayOfVariables Array of {Variables}. The function's variables.
    @param {Randomizer} randomizer The random number generator.
*/
function ExecutionContext(input, output, arrayOfVariables, randomizer) {
    _classCallCheck(this, ExecutionContext);

    /**
        The input to the program.
        @property input
        @type {NumericalInputComponent}
    */
    this.input = input;

    /**
        The output of the program.
        @property output
        @type {NumericalOutputComponent}
    */
    this.output = output;

    /**
        The function's variables.
        @property arrayOfVariables
        @type {Array} of {Variables}
    */
    this.arrayOfVariables = arrayOfVariables;

    /**
        The program's random number generator.
        @property randomizer
        @type {Randomizer}
    */
    this.randomizer = randomizer;
};

'use strict';

/* exported ExecutionStackElement */

/**
    Model an element in the execution stack, which stores a program function and flowchart node.
    @class ExecutionStackElement
*/

var ExecutionStackElement =

/**
    @constructor
    @param {ProgramFunction} programFunction The program function to store.
    @param {FlowchartNode} node The flowchart node to store.
*/
function ExecutionStackElement(programFunction, node) {
    _classCallCheck(this, ExecutionStackElement);

    /**
        The program function to store.
        @property function
        @type {ProgramFunction}
    */
    this.function = programFunction;

    /**
        The flowchart node to store.
        @property input
        @type {FlowchartNode}
    */
    this.node = node;
};

'use strict';

/* exported Executor */
/* global NumericalInputComponent, NumericalOutputComponent, ExecutionStackElement, ExecutionContext, evaluateAbstractSyntaxTree,
          Randomizer, TextualCodeParser */

/**
    The execution engine that processes a program with input and output. The input and output are optional.
    @class Executor
*/

var Executor = function () {

    /**
        @constructor
        @param {Program} code The program code from which to create an executor.
        @param {String} initialInput The initial input.
        @param {Boolean} isExecutable Whether the program should be executable.
    */
    function Executor(code, initialInput, isExecutable) {
        _classCallCheck(this, Executor);

        /**
            The code from which to make a program.
            @property code
            @type {String}
            @default null
        */
        this.code = null;

        /**
            The program to execute.
            @property program
            @type {Program}
            @default null
        */
        this.program = null;
        this.setProgramAndCodeFromCode(code);

        var isInputSet = typeof initialInput === 'string';

        /**
            The input component for the program. Add input only if an initial input is given.
            @property input
            @type {NumericalInputComponent}
            @default null
        */
        this.input = isInputSet ? new NumericalInputComponent(initialInput) : null;

        /**
            The output component for the program. Add an output if the program is executable.
            @property output
            @type {NumericalOutputComponent}
            @default null
        */
        this.output = isExecutable ? new NumericalOutputComponent() : null;

        /**
            The call stack used during execution.
            @property stack
            @type {Array} of {ExecutionStackElement}
            @default []
        */
        this.stack = [];

        /**
            Instance of a seedable randomizer.
            @property randomizer
            @type {Randomizer}
        */
        this.randomizer = new Randomizer();
    }

    /**
        Set the program from the given code.
        @method setProgramAndCodeFromCode
        @param {String} code The code to make into a program.
        @return {void}
    */


    _createClass(Executor, [{
        key: 'setProgramAndCodeFromCode',
        value: function setProgramAndCodeFromCode(code) {

            // The code has already successfully compiled, so don't need to do so again.
            if (this.code === code && this.program) {
                return;
            }

            // Set |code| to the passed value and set |program| to default.
            this.code = code;
            this.program = null;

            var parser = new TextualCodeParser();

            this.program = parser.parse(code);
        }

        /**
            Prepare the executor for execution.
            @method enterExecution
            @return {void}
        */

    }, {
        key: 'enterExecution',
        value: function enterExecution() {
            var mainFunctionClone = this.program.functions[0].clone();

            this.stack.push(new ExecutionStackElement(mainFunctionClone, mainFunctionClone.flowchart.startNode));

            if (this.input) {
                this.input.initialize();
            }

            this.randomizer.initialize();
        }

        /**
            Tear down the execution.
            @method exitExecution
            @return {void}
        */

    }, {
        key: 'exitExecution',
        value: function exitExecution() {
            this.stack.length = 0;
            if (this.input) {
                this.input.editable();
            }
            if (this.output) {
                this.output.clear();
            }
        }

        /**
            Execute the node at the top of the stack.
            @method execute
            @return {ProgramFunction} The function at the top of the stack.
        */

    }, {
        key: 'execute',
        value: function execute() {
            var _this43 = this;

            // Clear whether each memory cell has been written to.
            this.stack.forEach(function (element) {
                if (element.function.locals) {
                    element.function.locals.clearWrittenTo();
                }
                if (element.function.parameters) {
                    element.function.parameters.clearWrittenTo();
                }
                if (element.function.return) {
                    element.function.return.clearWrittenTo();
                }
            });

            var topOfStack = this.stack[this.stack.length - 1];

            // Node to execute has functions that needs calling, so call the next function.
            if (topOfStack.node.nonBuiltInFunctionCalls.length) {
                var nextCall = topOfStack.node.nonBuiltInFunctionCalls[0];
                var nextFunction = nextCall.function.clone();
                var argumentsList = nextCall.children.map(function (child) {
                    return evaluateAbstractSyntaxTree(child, _this43.makeExecutionContext(nextFunction));
                });

                nextFunction.setParametersDuringExecution(argumentsList);

                this.stack.push(new ExecutionStackElement(nextFunction, nextFunction.flowchart.startNode));
            }

            // Execute the node.
            else {
                    var stackElement = this.stack.pop();
                    var nextNode = stackElement.node.execute(this.makeExecutionContext(stackElement.function));

                    stackElement.node.reset();

                    // Push the next node onto the stack.
                    if (nextNode) {
                        this.stack.push(new ExecutionStackElement(stackElement.function, nextNode));
                    }

                    // No next node means a function return. Get the return value and pass to resolve the function call, if the stack isn't empty.
                    else if (this.stack.length) {
                            this.stack[this.stack.length - 1].node.resolveFunctionCall(stackElement.function.return[0]);
                        }
                }

            return this.stack[this.stack.length - 1] && this.stack[this.stack.length - 1].function;
        }

        /**
            Make a context of the function, input, output, and randomizer.
            @method makeExecutionContext
            @param {ProgramFunction} programFunction The function that the context will include.
            @return {ExecutionContext} Context of the function, input, output, and randomizer.
        */

    }, {
        key: 'makeExecutionContext',
        value: function makeExecutionContext(programFunction) {
            return new ExecutionContext(this.input, this.output, [programFunction.parameters, programFunction.locals, programFunction.return], this.randomizer);
        }

        /**
            Return whether there are any nodes left to execute.
            @method isExecutionDone
            @return {Boolean} Whether there are any nodes left to execute.
        */

    }, {
        key: 'isExecutionDone',
        value: function isExecutionDone() {
            return this.stack.length === 0;
        }
    }]);

    return Executor;
}();

'use strict';

/* exported ExpressionParser, parserGeneratedVariableName */
/* global AbstractSyntaxTree, Tokenizer, isValidIdentifier, VariableSymbol, IntegerVariable, FloatVariable, BinaryOperatorSymbol
          conditionalOperatorExpression, FunctionCallSymbol, UnaryOperatorSymbol, SubscriptOperatorSymbol, MemoryCellSymbol,
          BooleanVariable, ExpressionParserResult, ExpressionParserError, makeSuggestionForInvalidWordFromSimilarWords */

var parserGeneratedVariableName = 'parserGeneratedVariable';

/**
    A parser for converting an expression into an abstract syntax tree.
    @class ExpressionParser
*/

var ExpressionParser = function () {
    function ExpressionParser() {
        _classCallCheck(this, ExpressionParser);
    }

    _createClass(ExpressionParser, [{
        key: 'parse',


        /**
            Convert an expression into an abstract syntax tree.
            @method parse
            @param {String} expression Or {Array} of {Tokens}. The expression to parse.
            @param {Array} arrayOfVariables Array of {Variables}. The variables in this expression's function.
            @param {Array} functions Array of {ProgramFunction}. The functions in this expression's program.
            @return {ExpressionParserResult} The result of parsing an expression.
        */
        value: function parse(expression, arrayOfVariables, functions) {
            var tokens = expression;

            // Tokenize the string.
            if (typeof expression === 'string') {
                var tokenizer = new Tokenizer();
                var lines = tokenizer.tokenize(expression);

                // Combine the lines into 1 large list of tokens.
                tokens = lines.map(function (line) {
                    return line.tokens;
                }).reduce(function (first, second) {
                    return first.concat(second);
                }, []);
            }

            // Remove all spaces.
            tokens = tokens.filter(function (token) {
                return ['indent', 'spaces'].indexOf(token.name) === -1;
            });

            var root = this.buildAbstractSymbolTree(tokens, arrayOfVariables, functions);

            return new ExpressionParserResult(new AbstractSyntaxTree(root), this.staticAnalysisErrorRunner(root));
        }

        /**
            Build the abstract syntax tree from a list of tokens. This is an implementation of the shunting yard algorithm:
            http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#shunting_yard
            @method buildAbstractSymbolTree
            @param {Array} tokens Array of {Token}. The list of tokens to parse.
            @param {Array} arrayOfVariables Array of {Variables}. The variables in this expression's function.
            @param {Array} functions Array of {ProgramFunction}. The functions in this expression's program.
            @return {TreeSymbol} The root of the abstract symbol tree.
        */

    }, {
        key: 'buildAbstractSymbolTree',
        value: function buildAbstractSymbolTree(tokens, arrayOfVariables, functions) {
            var operandsStack = [];
            var operatorsStack = [];
            var wasPreviousSymbolAnOperand = false;

            while (tokens.length) {
                var symbol = this.makeSymbol(tokens, wasPreviousSymbolAnOperand, arrayOfVariables, functions);

                /*
                    An operand is either:
                    * Not an operator
                    * Has a child
                */
                var isAnOperand = !symbol.isAnOperator() || symbol.children[0];

                // Push an operand on the stack.
                if (isAnOperand) {
                    operandsStack.push(symbol);
                } else {

                    // While the new operator is lower precedence than the top operator, then pop the operator.
                    while (operatorsStack.length && this.doesAHaveLowerPrecedenceThanB(symbol, operatorsStack[operatorsStack.length - 1])) {
                        this.popOperator(operandsStack, operatorsStack);
                    }
                    operatorsStack.push(symbol);
                }

                wasPreviousSymbolAnOperand = isAnOperand;
            }

            while (operatorsStack.length) {
                this.popOperator(operandsStack, operatorsStack);
            }

            if (operandsStack.length !== 1 || operatorsStack.length !== 0) {
                this.throwGenericError();
            }

            return operandsStack[0];
        }

        /**
            Throw a generic error.
            @method throwGenericError
            @return {void}
        */

    }, {
        key: 'throwGenericError',
        value: function throwGenericError() {
            throw new ExpressionParserError('Error parsing expression');
        }

        /**
            The top operator is the parent of the top-most operand(s).
            @method popOperator
            @param {Array} operandsStack Array of {TreeSymbol}. The stack of operands.
            @param {Array} operatorsStack Array of {TreeSymbol}. The stack of operators.
            @return {void}
        */

    }, {
        key: 'popOperator',
        value: function popOperator(operandsStack, operatorsStack) {
            var topOfStack = operatorsStack.pop();

            // Need at least 1 operand to add as a child.
            if (operandsStack.length < 1) {
                this.throwGenericError();
            }

            // Binary operator's have two children.
            if (topOfStack.getClassName() === 'BinaryOperatorSymbol') {
                topOfStack.children[1] = operandsStack.pop();
            }

            // Need at least 1 remaining operand to add as a child.
            if (operandsStack.length < 1) {
                this.throwGenericError();
            }

            topOfStack.children[0] = operandsStack.pop();

            operandsStack.push(topOfStack);
        }

        /**
            Return whether the first parameter is lower than the second.
            A larger precedence number has a lower precedence.
            @method doesAHaveLowerPrecedenceThanB
            @param {OperatorSymbol} first The first parameter.
            @param {OperatorSymbol} second The second parameter.
            @return {Boolean} Whether the first parameter is lower than the second.
        */

    }, {
        key: 'doesAHaveLowerPrecedenceThanB',
        value: function doesAHaveLowerPrecedenceThanB(first, second) {
            var doesAHaveLowerPrecedenceThanB = first.getPrecedence() > second.getPrecedence();

            // If |first| is left associative, then equality also means lower precedence.
            if (first.isLeftAssociative()) {
                doesAHaveLowerPrecedenceThanB = first.getPrecedence() >= second.getPrecedence();
            }

            return doesAHaveLowerPrecedenceThanB;
        }

        /**
            Make a symbol from the given tokens.
            @method makeSymbol
            @param {Array} tokens Array of {Token}. The list of tokens to parse.
            @param {Boolean} wasPreviousSymbolAnOperand Whether the previous symbol was an operand. Used to determine if new operator is binary or unary.
            @param {Array} arrayOfVariables Array of {Variables}. The variables in this expression's function.
            @param {Array} functions Array of {ProgramFunction}. The functions in this expression's program.
            @return {TreeSymbol} The symbol from the given tokens.
        */

    }, {
        key: 'makeSymbol',
        value: function makeSymbol(tokens, wasPreviousSymbolAnOperand, arrayOfVariables, functions) {
            // eslint-disable-line complexity
            var token = tokens[0];
            var symbol = null;

            switch (token.name) {
                case 'word':
                    {
                        if (!isValidIdentifier(token.value)) {
                            throw new ExpressionParserError('Invalid identifier: ' + token.value);
                        }

                        var foundVariable = arrayOfVariables.map(function (variables) {
                            return variables.getVariable(token.value);
                        }).find(function (variable) {
                            return variable;
                        });
                        var foundFunction = functions.find(function (programFunction) {
                            return programFunction.name === token.value;
                        });

                        if (foundVariable) {

                            // Remove the variable name token.
                            tokens.shift();

                            var variableSymbol = new VariableSymbol(foundVariable);

                            symbol = variableSymbol;

                            if (tokens.length) {

                                // Check if next token is "[", if so, add subscript operator.
                                if (tokens[0].name === 'openingBracket') {
                                    symbol = this.makeSubscriptSymbol(variableSymbol, tokens, arrayOfVariables, functions);
                                }

                                // Else if check if next token is ".". If so, add member access operator.
                                else if (tokens[0].name === 'period') {
                                        symbol = this.makeMemoryCellFromMemberAccess(foundVariable, tokens);
                                    }
                            }
                        } else if (foundFunction) {

                            // Error if Main is called.
                            if (foundFunction.name === 'Main') {
                                throw new ExpressionParserError('Calling Main function is not allowed');
                            }

                            symbol = this.makeFuctionCallSymbol(tokens, foundFunction, arrayOfVariables, functions);
                        } else {
                            var suggestionMessage = makeSuggestionForInvalidWordFromSimilarWords(token.value, arrayOfVariables, functions);

                            throw new ExpressionParserError('Unknown word \'' + token.value + '\'', suggestionMessage);
                        }
                        break;
                    }
                case 'integerNumber':
                case 'floatNumber':
                    symbol = this.makeVariableSymbolFromNumber(tokens);
                    break;
                case 'arithmeticOperator':
                case 'conditionalOperator':

                    // If the previous symbol was an operand, then this operator is a binary operator. Ex: 4 + 5 => operand, operator, operand
                    if (wasPreviousSymbolAnOperand) {
                        var operator = tokens.shift().value;

                        if (operator === 'not') {
                            throw new ExpressionParserError(operator + ' is not a binary operator');
                        }

                        symbol = new BinaryOperatorSymbol(operator);
                    }

                    /*
                        If the previous symbol was not an operand, then this operator is a unary operator. Two examples:
                        1. -5 => operator (-) then operand (5)
                        2. 5 + -6 => operand (5), operator (+), operator (-), then operand (6). So, the - is a unary operator.
                    */
                    else {
                            var _operator = tokens.shift().value;

                            if (['not', '-', '+'].indexOf(_operator) === -1) {
                                throw new ExpressionParserError(_operator + ' is not a unary operator');
                            }

                            symbol = new UnaryOperatorSymbol(_operator);
                        }
                    break;
                case 'openingParens':
                    {
                        symbol = this.makeSymbolFromParens(tokens, arrayOfVariables, functions);
                        break;
                    }
                default:
                    throw new ExpressionParserError('Unexpected token ' + token.value + ' in expression');
            }

            return symbol;
        }

        /**
            Make a variable symbol from a number.
            @method makeVariableSymbolFromNumber
            @param {Array} tokens Array of {Token}. The list of tokens to parse.
            @return {VariableSymbol} The created variable symbol.
        */

    }, {
        key: 'makeVariableSymbolFromNumber',
        value: function makeVariableSymbolFromNumber(tokens) {
            var token = tokens.shift();
            var variable = null;
            var value = null;

            if (token.name === 'integerNumber') {
                variable = new IntegerVariable(parserGeneratedVariableName);
                value = parseInt(token.value, 10);
            } else {
                variable = new FloatVariable(parserGeneratedVariableName);
                value = parseFloat(token.value);
            }

            variable.setValue(value);

            return new VariableSymbol(variable);
        }

        /**
            Make a symbol from a sub-expression created via parens.
            @method makeSymbolFromParens
            @param {Array} tokens Array of {Token}. The list of tokens to parse.
            @param {Array} arrayOfVariables Array of {Variables}. The variables in this expression's function.
            @param {Array} functions Array of {ProgramFunction}. The functions in this expression's program.
            @return {TreeSymbol} The symbol created from the sub-expression inside the parens.
        */

    }, {
        key: 'makeSymbolFromParens',
        value: function makeSymbolFromParens(tokens, arrayOfVariables, functions) {
            var subExpression = this.getSubExpressionInParens(tokens);

            if (!subExpression.length) {
                throw new ExpressionParserError('Unexpected closing parens');
            }

            return this.buildAbstractSymbolTree(subExpression, arrayOfVariables, functions);
        }

        /**
            Make a subscript symbol for the given variable.
            @method makeSubscriptSymbol
            @param {VariableSymbol} variableSymbol The variable associated with the subscript.
            @param {Array} tokens Array of {Token}. The list of tokens to parse.
            @param {Array} arrayOfVariables Array of {Variables}. The variables in this expression's function.
            @param {Array} functions Array of {ProgramFunction}. The functions in this expression's program.
            @return {SubscriptSymbol} The symbol created from the variable symbol and tokens.
        */

    }, {
        key: 'makeSubscriptSymbol',
        value: function makeSubscriptSymbol(variableSymbol, tokens, arrayOfVariables, functions) {
            var subScript = this.getSubExpressionInsideParensOrBracket(tokens, 'bracket');
            var subScriptTree = this.buildAbstractSymbolTree(subScript, arrayOfVariables, functions);
            var symbol = new SubscriptOperatorSymbol();

            symbol.children[0] = variableSymbol;
            symbol.children[1] = subScriptTree;

            return symbol;
        }

        /**
            Make a member access symbol for the given variable.
            @method makeMemoryCellFromMemberAccess
            @param {Variable} foundVariable The variable associated with the member access.
            @param {Array} tokens Array of {Token}. The list of tokens to parse.
            @return {MemoryCellSymbol} The symbol created from the given variable.
        */

    }, {
        key: 'makeMemoryCellFromMemberAccess',
        value: function makeMemoryCellFromMemberAccess(foundVariable, tokens) {

            // Remove the period.
            tokens.shift();

            var memberName = tokens.shift();
            var symbol = null;

            if (memberName) {
                symbol = new MemoryCellSymbol(foundVariable.getMemoryCellByName(foundVariable.name + '.' + memberName.value));
            } else {
                throw new ExpressionParserError('Unexpected period after variable');
            }

            return symbol;
        }

        /**
            Make a function call symbol from the given tokens.
            @method makeFuctionCallSymbol
            @param {Array} tokens Array of {Token}. The list of tokens to parse.
            @param {ProgramFunction} programFunction The function to call.
            @param {Array} arrayOfVariables Array of {Variables}. The variables in this expression's function.
            @param {Array} functions Array of {ProgramFunction}. The functions in this expression's program.
            @return {FunctionCallSymbol} The function call symbol from the given tokens.
        */

    }, {
        key: 'makeFuctionCallSymbol',
        value: function makeFuctionCallSymbol(tokens, programFunction, arrayOfVariables, functions) {
            var _symbol$children,
                _this44 = this;

            var startIndexToHighlight = tokens[0].startIndexInTheLine;
            var endIndexToHighlight = tokens[tokens.length - 1].endIndexInTheLine;
            var functionName = tokens[0].name;

            // Remove the function name token.
            tokens.shift();

            var tokensCopy = tokens.slice();

            if (tokens[0].name !== 'openingParens') {
                throw new ExpressionParserError('Expected opening parens for ' + functionName + ' function call');
            }

            // Get the list of tokens inside the function call. Ex: GetInput(x + 1, 4) return x + 1, 4
            var argumentTokens = this.getSubExpressionInParens(tokens);
            var argumentList = [];
            var parensCounter = 0;
            var subSubExpression = [];

            if (argumentTokens.length) {

                // Consume the first element
                while (argumentTokens.length) {
                    var nextToken = argumentTokens.shift();

                    // Found a comma separating two arguments; store the current sub-subexpression.
                    if (nextToken.name === 'comma' && !parensCounter) {
                        argumentList.push(subSubExpression);
                        subSubExpression = [];
                    } else {

                        // Handle parens. Increment if opening; decrement if closing.
                        if (nextToken.name === 'openingParens') {
                            parensCounter++;
                        } else if (nextToken.name === 'closingParens') {
                            parensCounter--;
                        }

                        subSubExpression.push(nextToken);
                    }
                }

                // Grab the last argument.
                argumentList.push(subSubExpression);

                // Cannot have an empty argument.
                if (argumentList.find(function (argument) {
                    return !argument.length;
                })) {
                    throw new ExpressionParserError('An argument in ' + functionName + ' is empty, but shouldn\'t be.');
                }
            }

            // If tokens remain, then the end index to highlight should be from the last removed token.
            if (tokens.length) {
                var indexOfPriorToken = tokensCopy.indexOf(tokens[0]) - 1;

                endIndexToHighlight = tokensCopy[indexOfPriorToken].endIndexInTheLine;
            }

            var symbol = new FunctionCallSymbol(programFunction, startIndexToHighlight, endIndexToHighlight);

            (_symbol$children = symbol.children).push.apply(_symbol$children, _toConsumableArray(argumentList.map(function (argument) {
                return _this44.buildAbstractSymbolTree(argument, arrayOfVariables, functions);
            })));

            return symbol;
        }

        /**
            Remove the sub-expression inside the parens.
            @method getSubExpressionInParens
            @param {Array} tokens Array of {Token} List of tokens from which to extract the parens and subexpression.
            @return {Array} of {Token} The sub-expression inside the parens.
        */

    }, {
        key: 'getSubExpressionInParens',
        value: function getSubExpressionInParens(tokens) {
            return this.getSubExpressionInsideParensOrBracket(tokens, 'parens');
        }

        /**
            Remove the sub-expression inside the parens or bracket.
            @method getSubExpressionInsideParensOrBracket
            @param {Array} tokens Array of {Token} List of tokens from which to extract the parens and subexpression.
            @param {String} parensOrBracket The string 'parens' or 'bracket'.
            @return {Array} of {Token} The sub-expression inside the parens or bracket.
        */

    }, {
        key: 'getSubExpressionInsideParensOrBracket',
        value: function getSubExpressionInsideParensOrBracket(tokens, parensOrBracket) {
            var allLowerCase = parensOrBracket.toLowerCase();
            var initialUpperCase = allLowerCase.charAt(0).toUpperCase() + allLowerCase.slice(1);

            // Remove the opening parens.
            tokens.shift();

            // Initialize to 1 to account for the opening parens.
            var counter = 1;
            var subExpression = [];

            // Remove the sub-expression inside the outer-parens. Ex: ((x + 4) * y) - 2 yields (x + 4) * y
            while (tokens.length) {
                var topToken = tokens.shift();

                // Keep track of number of parens.
                if (topToken.name === 'opening' + initialUpperCase) {
                    counter++;
                } else if (topToken.name === 'closing' + initialUpperCase) {
                    counter--;
                }

                // When counter is 0, then we've found the associated closing parens to the original opening parens.
                if (counter === 0) {
                    break;
                } else {
                    subExpression.push(topToken);
                }
            }

            if (counter) {
                throw new ExpressionParserError('Expected a closing ' + allLowerCase);
            }

            return subExpression;
        }

        /**
            Traverse the tree to check for errors in the parent-child symbols.
            @method staticAnalysisErrorRunner
            @param {TreeSymbol} symbol The current symbol being traversed.
            @return {String} The data type being returned.
        */

    }, {
        key: 'staticAnalysisErrorRunner',
        value: function staticAnalysisErrorRunner(symbol) {
            var _this45 = this;

            // eslint-disable-line complexity
            var childDataTypes = symbol.children.map(function (child) {
                return _this45.staticAnalysisErrorRunner(child);
            });

            if (childDataTypes.some(function (child) {
                return !child;
            })) {
                var errorMessage = 'Function call returns nothing. ';

                if (symbol.getClassName() === 'FunctionCallSymbol') {
                    errorMessage += 'Cannot pass nothing to next function call';
                } else {
                    errorMessage += 'Cannot perform operation on nothing';
                }

                throw new ExpressionParserError(errorMessage);
            }

            var symbolDataType = null;
            var numericalVariable = ['IntegerVariable', 'FloatVariable'];

            switch (symbol.getClassName()) {

                // Just return the variable itself.
                case 'VariableSymbol':
                    symbolDataType = symbol.variable;
                    break;

                // Return the memory cell as a variable.
                case 'MemoryCellSymbol':
                    symbolDataType = this.makeVariableFromType(symbol.memoryCell.type);
                    break;

                // The first child must be an array. The second child must be an integer. Return a variable of the type of array.
                case 'SubscriptOperatorSymbol':
                    if (!childDataTypes[0].isArray()) {
                        throw new ExpressionParserError('Cannot subscript a non-array variable');
                    }
                    if (childDataTypes[1].getClassName() !== 'IntegerVariable') {
                        throw new ExpressionParserError('Subscript value must be an integer');
                    }
                    symbolDataType = this.makeVariableFromType(childDataTypes[0].type);
                    break;

                // Conditional operators return a boolean variable. Arithmetic operators return either an integer or float.
                case 'UnaryOperatorSymbol':
                case 'BinaryOperatorSymbol':
                    {
                        var areChildrenNumbers = childDataTypes.every(function (child) {
                            return numericalVariable.indexOf(child.getClassName() >= 0);
                        });

                        // Conditional operators return a boolean.
                        if (conditionalOperatorExpression.test(symbol.operator)) {
                            var isBooleanOperator = ['not', 'and', 'or'].indexOf(symbol.operator) >= 0;
                            var areChildrenBoolean = childDataTypes.every(function (child) {
                                return child.getClassName() === 'BooleanVariable';
                            });

                            // Boolean operators can only have boolean children, and return a boolean.
                            if (isBooleanOperator && !areChildrenBoolean) {
                                throw new ExpressionParserError(symbol.operator + ' must be connected to a conditional operator');
                            }

                            // Must have integer or float children.
                            if (!isBooleanOperator && !areChildrenNumbers) {
                                throw new ExpressionParserError(symbol.operator + ' must relate numbers');
                            }
                            symbolDataType = this.makeVariableFromType('boolean');
                        }

                        // Non-boolean operators must have children that are numbers, and return either a float or integer.
                        else {
                                if (!areChildrenNumbers) {
                                    throw new ExpressionParserError(symbol.operator + ' must operate on numbers');
                                }

                                // If both are integers, return an integer. Otherwise, return a float.
                                var hasNonInteger = childDataTypes.some(function (child) {
                                    return child.getClassName() !== 'IntegerVariable';
                                });

                                symbolDataType = this.makeVariableFromType(hasNonInteger ? 'float' : 'integer');
                            }
                        break;
                    }

                // Verify the arguments and parameters match data types. Return the functions return variable.
                case 'FunctionCallSymbol':
                    {
                        var parameters = symbol.function.parameters;

                        if (symbol.children.length !== parameters.length) {
                            var functionName = symbol.function.name;

                            throw new ExpressionParserError('Expected call to ' + functionName + ' to have ' + parameters.length + ' arguments but found ' + symbol.children.length);
                        }

                        // Arguments should match the parameter data types.
                        childDataTypes.forEach(function (argument, index) {
                            var numericalArrays = ['IntegerArray', 'FloatArray'];
                            var parameterIsNumericalArray = numericalArrays.indexOf(parameters[index].getClassName()) >= 0;
                            var argumentIsNumericalArray = numericalArrays.indexOf(argument.getClassName()) >= 0;
                            var parameterIsNumber = numericalVariable.indexOf(parameters[index].getClassName()) >= 0;
                            var argumentIsNumber = numericalVariable.indexOf(argument.getClassName()) >= 0;

                            // If they are both numerical arrays, then that's fine.
                            if (parameterIsNumericalArray && !argumentIsNumericalArray) {
                                throw new ExpressionParserError(symbol.function.name + ' call expected an array argument but found a non-array argument');
                            }

                            if (parameterIsNumber && !argumentIsNumber) {
                                throw new ExpressionParserError(symbol.function.name + ' call expected a number argument but found a non-number argument');
                            }
                        });

                        // Use the return variable, if one exists.
                        symbolDataType = symbol.function.return.length ? symbol.function.return[0] : symbolDataType;
                        break;
                    }
                default:
                    break;
            }

            return symbolDataType;
        }

        /**
            Make a variable for the given type.
            @method makeVariableFromType
            @param {String} type The type of variable to make.
            @return {Variable} Made from the given type.
        */

    }, {
        key: 'makeVariableFromType',
        value: function makeVariableFromType(type) {
            var variable = null;

            if (type === 'integer') {
                variable = new IntegerVariable(parserGeneratedVariableName);
            } else if (type === 'float') {
                variable = new FloatVariable(parserGeneratedVariableName);
            } else if (type === 'boolean') {
                variable = new BooleanVariable(parserGeneratedVariableName);
            }

            return variable;
        }
    }]);

    return ExpressionParser;
}();

'use strict';

/* exported ExpressionParserError */

/**
    An error generated by the expression parser.
    @class ExpressionParserError
*/

var ExpressionParserError =

/**
    @constructor
    @param {String} error The message indicating the error.
    @param {String} [suggestion=''] A suggestion on how to address the error.
*/
function ExpressionParserError(error) {
    var suggestion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, ExpressionParserError);

    /**
        The message indicating the error.
        @type {String}
        @property error
    */
    this.error = error;

    /**
        A suggestion on how to address the error.
        @type {String}
        @property suggestion
    */
    this.suggestion = suggestion;
};

'use strict';

/* exported ExpressionParserResult */

/**
    Store the result of an expression parsing.
    @class ExpressionParserResult
*/

var ExpressionParserResult =

/**
    @constructor
    @param {AbstractSyntaxTree} tree The abstract syntax tree, resulting from expression parsing.
    @param {Variable} rootDataType The type of data type of the tree's root.
*/
function ExpressionParserResult(tree, rootDataType) {
    _classCallCheck(this, ExpressionParserResult);

    /**
        The abstract syntax tree, resulting from expression parsing.
        @property tree
        @type {AbstractSyntaxTree}
    */
    this.tree = tree;

    /**
        The type of data type of the tree's root.
        @property rootDataType
        @type {Variable}
    */
    this.rootDataType = rootDataType;
};

'use strict';

/* exported Flowchart */

/**
    Model of the flowchart, which stores the start node of the flowchart.
    @class Flowchart
*/

var Flowchart = function () {

    /**
        @constructor
        @param {StartNode} startNode The start node of the flowchart.
    */
    function Flowchart(startNode) {
        _classCallCheck(this, Flowchart);

        /**
            The start node of the flowchart.
            @property startNode
            @type {StartNode}
        */
        this.startNode = startNode;
    }

    /**
        Return a clone of this flowchart.
        @method clone
        @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up memory cells.
        @return {Flowchart} A clone of this flowchart.
    */


    _createClass(Flowchart, [{
        key: 'clone',
        value: function clone(arrayOfVariables) {

            // Build a list of the current nodes in pre-fix order, which means the start node will be the first element.
            var currentPrefixOrder = [];

            this.prefixNodeOrdering(this.startNode, currentPrefixOrder);

            // Clone each node.
            var clonedPrefixOrder = currentPrefixOrder.map(function (node) {
                return node.clone(arrayOfVariables);
            });

            // Set the children of the cloned nodes.
            currentPrefixOrder.forEach(function (currentNode, nodeIndex) {
                var clonedNode = clonedPrefixOrder[nodeIndex];

                currentNode.children.forEach(function (child, childIndex) {
                    var indexOfChildInOrder = currentPrefixOrder.indexOf(child);

                    clonedNode.children[childIndex] = clonedPrefixOrder[indexOfChildInOrder];
                });
            });

            return new Flowchart(clonedPrefixOrder[0]);
        }

        /**
            Build the prefix node ordering of the flowchart.
            @method prefixNodeOrdering
            @param {FlowchartNode} node The current node to traverse.
            @param {Array} prefixOrder Array of {FlowchartNode}. The pre-fix order of the flowchart.
            @return {void}
        */

    }, {
        key: 'prefixNodeOrdering',
        value: function prefixNodeOrdering(node, prefixOrder) {
            var _this46 = this;

            /*
                Base case: Node already been traversed. Do nothing.
                Recursive case: Store the node then traverse the node's children.
            */
            if (prefixOrder.indexOf(node) < 0) {
                prefixOrder.push(node);
                node.children.forEach(function (child) {
                    _this46.prefixNodeOrdering(child, prefixOrder);
                });
            }
        }
    }]);

    return Flowchart;
}();

'use strict';

/* exported NumericalInputComponent */

/**
    Model a component wherein the user can enter numerical values separated by spaces.
    @class NumericalInputComponent
*/

var NumericalInputComponent = function () {

    /**
        @constructor
        @param {String} userInput The initial input to set.
    */
    function NumericalInputComponent(userInput) {
        _classCallCheck(this, NumericalInputComponent);

        /**
            The input into the component.
            @property userInput
            @type {String}
            @default null
        */
        this.userInput = userInput;

        /**
            List of numerical inputs.
            @property inputs
            @type {Array}
            @default null
        */
        this.inputs = null;

        /**
            The initial list of numerical inputs.
            @property initialInputs
            @type {Array}
            @default null
        */
        this.initialInputs = null;

        /**
            List of controllers that are registered to listen to this input component.
            @property registeredControllers
            @type {Array} of {NumericalInputComponentController}
            @default []
        */
        this.registeredControllers = [];

        /**
            Whether the input is currently editable.
            @property isEditable
            @type {Boolean}
            @default true
        */
        this.isEditable = true;
    }

    /**
        Register the given controller to listen to changes on the input.
        @method registerController
        @param {NumericalInputComponentController} controller The controller that wants to be registered to listen to this input.
        @return {void}
    */


    _createClass(NumericalInputComponent, [{
        key: 'registerController',
        value: function registerController(controller) {
            this.registeredControllers.push(controller);
        }

        /**
            Clear the registered controllers.
            @method clearRegisteredControllers
            @return {void}
        */

    }, {
        key: 'clearRegisteredControllers',
        value: function clearRegisteredControllers() {
            this.registeredControllers.length = 0;
        }

        /**
            Store the given user input.
            @method setUserInput
            @param {String} userInput The user's input to set.
            @return {void}
        */

    }, {
        key: 'setUserInput',
        value: function setUserInput(userInput) {

            /*
                Verify that input consists of numerical values separated by whitespace.
                Valid input ex: 42 -13    56.5
                12.4
                    -5
                 Which should be interpreted as 5 numbers: 42 -13 56.5 12.4 -5
            */
            var isValidFormat = /^\s*(-?\d+(\.\d+)?\s+)*(-?\d+(\.\d+)?)?\s*$/.test(userInput);

            if (!isValidFormat) {
                throw new Error('Valid input is numbers separated by whitespace. Ex: 42.5 -13');
            }

            this.initialInputs = userInput.match(/-?\d+(\.\d+)?/g) || [];
            this.inputs = this.initialInputs.slice();
            this.userInput = userInput;
        }

        /**
            Get the next input value.
            @method getNextInput
            @return {String} The next numerical input.
        */

    }, {
        key: 'getNextInput',
        value: function getNextInput() {
            var nextInput = this.inputs.shift();

            if (isNaN(nextInput)) {
                throw new Error('All input values already consumed.');
            }

            return Number(nextInput);
        }

        /**
            Initialize the input component.
            @method initialize
            @return {void}
        */

    }, {
        key: 'initialize',
        value: function initialize() {
            this.setUserInput(this.userInput);
            this.isEditable = false;
        }

        /**
            Set the input to be editable.
            @method editable
            @return {void}
        */

    }, {
        key: 'editable',
        value: function editable() {
            this.isEditable = true;
        }
    }]);

    return NumericalInputComponent;
}();

'use strict';

/* exported NumericalOutputComponent */

/**
    Model a component wherein the user can enter numerical values separated by spaces.
    @class NumericalOutputComponent
*/

var NumericalOutputComponent = function () {

    /**
        @constructor
    */
    function NumericalOutputComponent() {
        _classCallCheck(this, NumericalOutputComponent);

        /**
            The output of the component.
            @property output
            @type {String}
        */
        this.output = '';

        /**
            List of controllers that are registered to listen to this component.
            @property registeredControllers
            @type {Array} of {NumericalOutputComponentController}
            @default []
        */
        this.registeredControllers = [];
    }

    /**
        Register the given controller to listen to changes on the output.
        @method registerController
        @param {NumericalOutputComponentController} controller The controller that wants to be registered to listen to this input.
        @return {void}
    */


    _createClass(NumericalOutputComponent, [{
        key: 'registerController',
        value: function registerController(controller) {
            this.registeredControllers.push(controller);
        }

        /**
            Print the given string.
            @method toPrint
            @param {String} string The string to print.
            @return {void}
        */

    }, {
        key: 'toPrint',
        value: function toPrint(string) {
            this.output += string;
            this.registeredControllers.forEach(function (controller) {
                return controller.updatedOutput();
            });
        }

        /**
            Set the output of the other controllers that are not currently being edited.
            @method setOutputOfOtherControllers
            @param {NumericalOutputComponentController} controllerBeingEdited The controller being edited, so shouldn't be written to.
            @param {String} string The output value.
            @return {void}
        */

    }, {
        key: 'setOutputOfOtherControllers',
        value: function setOutputOfOtherControllers(controllerBeingEdited, string) {
            this.output = string;
            this.registeredControllers.filter(function (controller) {
                return controller !== controllerBeingEdited;
            }).forEach(function (controller) {
                return controller.updatedOutput();
            });
        }

        /**
            Clear the registered controllers.
            @method clearRegisteredControllers
            @return {void}
        */

    }, {
        key: 'clearRegisteredControllers',
        value: function clearRegisteredControllers() {
            this.registeredControllers.length = 0;
        }

        /**
            Clear the output.
            @method clear
            @return {void}
        */

    }, {
        key: 'clear',
        value: function clear() {
            this.output = '';
        }
    }]);

    return NumericalOutputComponent;
}();

'use strict';

/* exported Program */

/**
    Model a program, which stores a list of functions.
    @class Program
*/

var Program =

/**
    @constructor
    @param {Array} functions Array of {ProgramFunctions}. The list of functions defining this program.
*/
function Program(functions) {
    _classCallCheck(this, Program);

    /**
        The list of functions defining this program.
        @property functions
        @type {Array} of {ProgramFunctions}
    */
    this.functions = functions;
};

'use strict';

/* exported Randomizer */
/* global alea */

/**
    A random number generator that can be seeded.
    @class Randomizer
*/

var Randomizer = function () {

    /**
        @constructor
    */
    function Randomizer() {
        _classCallCheck(this, Randomizer);

        /**
            The alea instance, which is a seedable random number generator.
            @property alea
            @type {alea}
            @default null
        */
        this.alea = null;
    }

    /**
        Initialize the randomizer with a seed value.
        @method initialize
        @return {void}
    */


    _createClass(Randomizer, [{
        key: 'initialize',
        value: function initialize() {
            var currentTime = new Date().getTime();

            this.setSeed(currentTime);
        }

        /**
            Create an alea instance with the given seed.
            @method setSeed
            @param {String} seed The seed to set.
            @return {void}
        */

    }, {
        key: 'setSeed',
        value: function setSeed(seed) {
            this.alea = new alea(seed); // eslint-disable-line new-cap
        }

        /**
            Return a randomly-generated 32-bit integer.
            @method getNumber
            @return {Integer} A randomly-generated 32-bit integer.
        */

    }, {
        key: 'getNumber',
        value: function getNumber() {
            return Math.abs(this.alea.int32());
        }
    }]);

    return Randomizer;
}();

'use strict';

/* exported RestrictedCode */

/**
    A program's code that is broken into three parts: pre, placeholder, and post. The placeholder is editable. Pre and post are not editable.
    @class RestrictedCode
*/

var RestrictedCode =

/**
    @constructor
    @param {String} pre The uneditable code before the placeholder.
    @param {String} placeholder The code the user can edit.
    @param {String} post The uneditable code after the placeholder.
*/
function RestrictedCode(pre, placeholder, post) {
    _classCallCheck(this, RestrictedCode);

    /**
        The uneditable code before the placeholder.
        @property pre
        @type {String}
    */
    this.pre = pre;

    /**
        The code the user can edit.
        @property placeholder
        @type {String}
    */
    this.placeholder = placeholder;

    /**
        The uneditable code after the placeholder.
        @property post
        @type {String}
    */
    this.post = post;
};

'use strict';

/* exported TextualCodeParser */
/* global Program, ProgramFunction, Flowchart, IntegerVariable, FloatVariable, IntegerArray, FloatArray, Variables, StartNode, EndNode,
          TokensOfLine, Token, isValidIdentifier, InputNode, OutputNode, AssignmentNode, LoopNode, IfNode, FunctionCallNode,
          Tokenizer, builtInFunctions, ExpressionParser, CompilerError, conditionalOperatorExpression, ElseIfNode, RenderingIndicatorFactory,
          makeSuggestionForInvalidDataType, combineWordsIntoSuggestion, builtInFunctionNames, arithmeticOperatorExpression */

/**
    A parser for converting textual code into a program.
    @class TextualCodeParser
*/

var TextualCodeParser = function () {

    /**
        @constructor
    */
    function TextualCodeParser() {
        _classCallCheck(this, TextualCodeParser);

        /**
            A message to indicate that the parser injected the main function.
            @property parserInjectedMainMessage
            @type {String}
            @default 'Parser injected Main function'
        */
        this.parserInjectedMainMessage = 'Parser injected Main function';

        /**
            An instance of the expression parser.
            @property expressionParser
            @type {ExpressionParser}
        */
        this.expressionParser = new ExpressionParser();

        /**
            The indents divisor. That is, indents are done at a 3-space standard.
            @property indentDivisor
            @type {Integer}
            @default 3
        */
        this.indentDivisor = 3;
    }

    /**
        Convert textual code into a program.
        @method parse
        @param {String} code The textual code to parse.
        @return {Program} The program converted from the textual code.
    */


    _createClass(TextualCodeParser, [{
        key: 'parse',
        value: function parse(code) {
            var _this47 = this;

            var tokenizer = new Tokenizer();
            var lines = tokenizer.tokenize(code);

            // Throw out blank lines, or lines only with indentation.
            var linesToUse = lines.filter(function (line) {
                var lineHasTokens = Boolean(line.tokens.length);
                var lineIsOnlyIndentation = line.tokens.length === 1 && line.tokens[0].name === 'indent';

                return lineHasTokens && !lineIsOnlyIndentation;
            });

            // Remove spaces b/c spaces can be anywhere.
            linesToUse.forEach(function (line) {
                line.tokens = line.tokens.filter(function (token) {
                    return token.name !== 'spaces';
                });
            });

            // Check for indents that are not a multiple of |this.indentDivisor|.
            linesToUse.filter(function (line) {
                return line.tokens[0].name === 'indent';
            }).filter(function (line) {
                return !Number.isInteger(line.tokens[0].value.length / _this47.indentDivisor);
            }).forEach(function (line) {
                return _this47.throwError('Indentation has ' + line.tokens[0].value.length + ' spaces, but should be a multiple of ' + _this47.indentDivisor, line);
            });

            // Batch the lines into functions.
            var returnVariableOfEachFunction = [];
            var parameterVariablesOfEachFunction = [];
            var functionNames = builtInFunctionNames.slice();
            var processedFunctionDeclarations = this.batchIntoFunctions(linesToUse).map(function (functionBatch) {
                var functionDeclarationLine = functionBatch[0];
                var functionLines = functionBatch.slice(1, functionBatch.length);
                var globalScope = { functionNames: functionNames, parameterVariablesOfEachFunction: parameterVariablesOfEachFunction, returnVariableOfEachFunction: returnVariableOfEachFunction };

                var _parseFunctionDeclara = _this47.parseFunctionDeclaration(functionDeclarationLine, globalScope),
                    returnVariable = _parseFunctionDeclara.returnVariable,
                    functionName = _parseFunctionDeclara.functionName,
                    parameterVariables = _parseFunctionDeclara.parameterVariables;

                functionNames.push(functionName);
                returnVariableOfEachFunction.push(returnVariable);
                parameterVariablesOfEachFunction.push(parameterVariables);

                return {
                    functionDeclarationLine: functionDeclarationLine,
                    functionName: functionName,
                    functionLines: functionLines,
                    parameterVariables: parameterVariables,
                    returnVariable: returnVariable
                };
            });

            // Process each function.
            var functionsAndFlowchartLines = processedFunctionDeclarations.map(function (processedFunctionDeclaration) {
                var functionDeclarationLine = processedFunctionDeclaration.functionDeclarationLine,
                    functionName = processedFunctionDeclaration.functionName,
                    functionLines = processedFunctionDeclaration.functionLines,
                    parameterVariables = processedFunctionDeclaration.parameterVariables,
                    returnVariable = processedFunctionDeclaration.returnVariable;

                // Scan function for unindented code.

                var wasMainFunctionInjected = functionDeclarationLine.line === _this47.parserInjectedMainMessage;

                if (!wasMainFunctionInjected) {
                    var unindentedLines = functionLines.filter(function (line) {
                        return line.tokens[0].name !== 'indent';
                    });

                    if (unindentedLines.length) {
                        _this47.throwError('Code inside a function must be indented', unindentedLines[0]);
                    }
                }

                // Split |functionLines| into local variables and flowchart nodes, ignoring comments above variable declarations.
                var dataTypes = functionLines.filter(function (line) {
                    var dataTypeIndex = wasMainFunctionInjected ? 0 : 1;

                    return line.tokens[dataTypeIndex].name === 'dataType';
                });
                var indexAfterLastDataType = functionLines.indexOf(dataTypes[dataTypes.length - 1]) + 1;
                var localVariableLines = functionLines.slice(0, indexAfterLastDataType).filter(function (line) {
                    var dataTypeIndex = wasMainFunctionInjected ? 0 : 1;

                    return line.tokens[dataTypeIndex].name !== 'comment';
                });
                var codeAboveDataTypes = localVariableLines.find(function (line) {
                    var dataTypeIndex = wasMainFunctionInjected ? 0 : 1;

                    return line.tokens[dataTypeIndex].name !== 'dataType';
                });
                var flowchartLines = functionLines.slice(indexAfterLastDataType);

                if (codeAboveDataTypes) {
                    var indexOfCodeAboveDataTypes = localVariableLines.indexOf(codeAboveDataTypes);

                    _this47.throwError('Variable declaration must be at top of function. Something above this line may not be a variable declaration', localVariableLines[indexOfCodeAboveDataTypes + 1]);
                }

                // Build the local variables.
                var functionScope = {
                    functionNames: functionNames,
                    parameterVariables: parameterVariables,
                    returnVariable: returnVariable
                };
                var isFunctionMain = functionName === 'Main';
                var localVariablesName = isFunctionMain ? 'Variables' : 'Local variables';
                var localVariables = _this47.buildLocalVariablesFromLines(localVariableLines, localVariablesName, wasMainFunctionInjected, isFunctionMain, functionScope);

                return {
                    programFunction: new ProgramFunction(functionName, localVariables, parameterVariables, returnVariable),
                    flowchartLines: flowchartLines,
                    wasMainFunctionInjected: wasMainFunctionInjected,
                    functionDeclarationLine: functionDeclarationLine
                };
            });

            var functions = functionsAndFlowchartLines.map(function (functionsAndFlowchartLine) {
                return functionsAndFlowchartLine.programFunction;
            });

            // Build the flowcharts.
            functionsAndFlowchartLines.forEach(function (functionsAndFlowchartLine) {
                var programFunction = functionsAndFlowchartLine.programFunction;
                var flowchartLines = functionsAndFlowchartLine.flowchartLines;
                var wasMainFunctionInjected = functionsAndFlowchartLine.wasMainFunctionInjected;
                var availableFunctions = functions.concat(builtInFunctions);

                programFunction.flowchart = _this47.buildFlowchartFromLines(flowchartLines, [programFunction.parameters, programFunction.locals, programFunction.return], wasMainFunctionInjected, availableFunctions);

                // Verify that function has at least 1 sub-statement.
                var secondNodeName = programFunction.flowchart.startNode.getChildNode().getName();

                // StartNode -> EndNode means there is no sub-statement. Not a problem, though, if main was injected.
                if (secondNodeName === 'EndNode' && !wasMainFunctionInjected) {
                    _this47.throwSubStatementError('A function', functionsAndFlowchartLine.functionDeclarationLine);
                }
            });

            var mainFunction = functions.find(function (programFunction) {
                return programFunction.name === 'Main';
            });

            // Move the function named Main to the front of the functions list.
            if (mainFunction) {
                var mainFunctionIndex = functions.indexOf(mainFunction);

                functions.splice(mainFunctionIndex, 1);
                functions.reverse();
                functions.unshift(mainFunction);

                // Find the line corresponding to Main for use in errors.
                var mainLine = functionsAndFlowchartLines.find(function (functionsAndFlowchartLine) {
                    return functionsAndFlowchartLine.programFunction === mainFunction;
                }).functionDeclarationLine;

                // Error if Main has parameter variables.
                if (mainFunction.parameters.length) {
                    this.throwError('Main cannot have any parameter variables', mainLine);
                }

                // Error if Main has a return variable.
                if (mainFunction.return.length) {
                    this.throwError('Main cannot have a return variable', mainLine);
                }
            }

            // Program must have a function named Main.
            else {
                    throw new Error('Expected a Main function but didn\'t find one');
                }

            return new Program(functions);
        }

        /**
            Build a flowchart from lines of tokens.
            @method buildFlowchartFromLines
            @param {Array} lines Array of {TokensOfLine} The lines of tokens from which to build the flowchart.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Boolean} wasMainFunctionInjected Whether the main function was injected.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {Flowchart} The flowchart built from the lines of tokens.
        */

    }, {
        key: 'buildFlowchartFromLines',
        value: function buildFlowchartFromLines(lines, arrayOfVariables, wasMainFunctionInjected, availableFunctions) {
            this.transpileForLoopStructureToWhileLoopStructure(lines, arrayOfVariables, availableFunctions);

            var startNode = new StartNode();
            var baseIndent = wasMainFunctionInjected ? 0 : 1;
            var secondNode = this.buildFlowchartFromLinesRunner(lines, baseIndent, baseIndent, arrayOfVariables, availableFunctions);
            var startNodeLine = new TokensOfLine('', secondNode.line ? secondNode.line.lineNumber : null);
            var endNodeToUse = new EndNode(null, null, new TokensOfLine('', null));

            startNode.setChildNode(secondNode);
            startNode.line = startNodeLine;
            this.updateEndNodesToBeTheSameInstance(startNode, endNodeToUse);

            return new Flowchart(startNode);
        }

        /**
            Transpile for-loop structures into a while-loop structure.
            @method transpileForLoopStructureToWhileLoopStructure
            @param {Array} lines Array of {TokensOfLine} The lines of tokens from which to transpile for-loop into while-loop.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {Array} of {TokensOfLine} The transpiled lines.
        */

    }, {
        key: 'transpileForLoopStructureToWhileLoopStructure',
        value: function transpileForLoopStructureToWhileLoopStructure(lines, arrayOfVariables, availableFunctions) {
            var _this48 = this;

            var forLoop = null;

            // Starting from the top-most for-loop, convert for-loops into while-loops until there are no more for-loops.
            do {

                // Find a for loop which is either the first token, or second token if the first token is an indent.
                forLoop = lines.find(function (line) {
                    var firstTokenIsFor = line.tokens.length && line.tokens[0].value === 'for';
                    var secondTokenIsFor = line.tokens.length > 1 && line.tokens[0].name === 'indent' && line.tokens[1].value === 'for';

                    return firstTokenIsFor || secondTokenIsFor;
                });

                /*
                    Convert for loop into two assignments and one loop node.
                    Ex: Convert:
                    // ...a...
                    for i = 0; i < 3; i = i + 1
                        // ...b...
                    // ...c...
                     Into:
                    // ...a...
                    i = 0
                    while i < 3
                        // ...b...
                        i = i + 1
                    // ...c...
                */
                if (forLoop) {
                    (function () {
                        var _convertForLoopLineTo = _this48.convertForLoopLineToThreeLines(forLoop, arrayOfVariables, availableFunctions),
                            first = _convertForLoopLineTo.first,
                            second = _convertForLoopLineTo.second,
                            third = _convertForLoopLineTo.third;

                        var firstIndex = lines.indexOf(forLoop);
                        var secondIndex = firstIndex + 1;

                        // Replace |forLoop| with |first| in |lines|.
                        lines[firstIndex] = first;

                        // Insert |second| after |first| in |lines|.
                        lines.splice(secondIndex, 0, second);

                        // Find the first line after the loop body by looking for the next line with less indentation than needed to be in the loop body.
                        var linesAfterSecond = lines.filter(function (line, index) {
                            return index > secondIndex;
                        });
                        var neededIndentation = _this48.computeIndentationLength(first) + _this48.indentDivisor;
                        var lineAfterLoopBody = linesAfterSecond.find(function (line) {
                            return _this48.computeIndentationLength(line) < neededIndentation;
                        });

                        // Found the first line after loop body, so add |third| just before that.
                        if (lineAfterLoopBody) {
                            var thirdIndex = lines.indexOf(lineAfterLoopBody);

                            lines.splice(thirdIndex, 0, third);
                        }

                        // No line after loop body exists, so |third| becomes the last line.
                        else {
                                lines.push(third);
                            }
                    })();
                }
            } while (forLoop);
        }

        /**
            Convert the for loop line into three lines based, one for each part of the for-loop.
            @method convertForLoopLineToThreeLines
            @param {TokensOfLine} forLoop The for loop line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {Object} The three lines from which the for loop was created.
        */

    }, {
        key: 'convertForLoopLineToThreeLines',
        value: function convertForLoopLineToThreeLines(forLoop, arrayOfVariables, availableFunctions) {
            var _this49 = this;

            var tokens = forLoop.tokens;
            var indentToken = tokens[0] && tokens[0].name === 'indent' ? tokens.shift() : null;

            // Remove "for" token.
            tokens.shift();

            /*
                Split the for-loop's tokens into 3 groups, one for each part of the for-loop.
                Ex: for i = 0; i < 3; i = i + 1 has parts: (i = 0), (i < 3), (i = i + 1)
            */
            var firstTokens = [];
            var secondTokens = [];
            var thirdTokens = [];
            var tokenGroups = [firstTokens, secondTokens, thirdTokens];
            var currentGroupIndex = 0;

            tokens.forEach(function (token) {

                // Found a semicolon. Start on the next group of tokens.
                if (token.value === ';') {
                    currentGroupIndex++;

                    // Verify number of parts is as expected.
                    if (currentGroupIndex >= tokenGroups.length) {
                        _this49.throwError('Too many semicolons (expected two semicolons)', forLoop);
                    }
                } else {
                    tokenGroups[currentGroupIndex].push(token);
                }
            });

            // Do some error checking on the resulting |tokenGroups|.
            if (currentGroupIndex !== tokenGroups.length - 1) {
                this.throwError('Too few semicolons (expected two semicolons)', forLoop);
            }

            if (!tokenGroups[0].some(function (token) {
                return token.name === 'assignment';
            })) {
                this.throwError('First part must be an assignment', forLoop);
            }

            var secondPartErrorMessage = 'Second part must be a decision expression';

            if (!tokenGroups[1].some(function (token) {
                return conditionalOperatorExpression.test(token.value);
            })) {
                this.throwError(secondPartErrorMessage, forLoop);
            }

            if (!tokenGroups[2].some(function (token) {
                return token.name === 'assignment';
            })) {
                this.throwError('Third part must be an assignment', forLoop);
            }

            var secondWithoutIndentingOrWhile = secondTokens.slice();

            // Add "while" token to |second|.
            secondTokens.unshift(new Token('word', 'while'));

            // Add indentation to |first| and |second| if there was an |indentToken|.
            var firstIndenting = '';

            if (indentToken) {
                firstIndenting = indentToken.value;
                firstTokens.unshift(new Token('indent', firstIndenting));
                secondTokens.unshift(new Token('indent', firstIndenting));
            }

            // Add indentation to |third| that is 1 more indented than |first|'s indentation.
            var thirdIndenting = firstIndenting + ' '.repeat(this.indentDivisor);

            thirdTokens.unshift(new Token('indent', thirdIndenting));

            /*
                Find the start and end indices from |forLoop.line| for each part.
                Ex: for i = 0; i < 3; i = i + 1
                First part: Start index is 4 and end index is 8.
                Second part: Start index is 11 and end index is 15.
                Third part: Start index is 18 and end index is 26.
            */
            var lineParts = forLoop.line.split(';');

            // Find the indices for the first part in the string. Ex: "for i = 0"
            var firstPartString = lineParts[0].match(/^\s*for\s+(.*)\s*$/)[1];
            var firstStartIndex = lineParts[0].indexOf(firstPartString);
            var firstEndIndex = firstStartIndex + firstPartString.length - 1;

            // Find the indices for the second part in the string. Ex: " i < 3"
            var secondPartString = lineParts[1].trim();
            var lengthTillFirstSemicolon = lineParts[0].length + 1;
            var secondStartIndex = lineParts[1].indexOf(secondPartString) + lengthTillFirstSemicolon;
            var secondEndIndex = secondStartIndex + secondPartString.length - 1;

            // Find the indices for the third part in the string. Ex: " i = i + 1"
            var thirdPartString = lineParts[2].trim();
            var lengthTillSecondSemicolon = lengthTillFirstSemicolon + lineParts[1].length + 1;
            var thirdStartIndex = lineParts[2].indexOf(thirdPartString) + lengthTillSecondSemicolon;
            var thirdEndIndex = thirdStartIndex + thirdPartString.length - 1;

            // Build a line for each part.
            var first = new TokensOfLine(firstPartString, forLoop.lineNumber, firstStartIndex, firstEndIndex);
            var second = new TokensOfLine('while ' + secondPartString, forLoop.lineNumber, secondStartIndex, secondEndIndex);
            var third = new TokensOfLine(thirdPartString, forLoop.lineNumber, thirdStartIndex, thirdEndIndex);

            first.push.apply(first, firstTokens);
            second.push.apply(second, secondTokens);
            third.push.apply(third, thirdTokens);

            first.isFromForLoop = true;
            second.isFromForLoop = true;
            third.isFromForLoop = true;

            // Test that the second part is a decision expression.
            var expressionResult = null;

            try {
                expressionResult = this.runExpressionParserOnLine(secondWithoutIndentingOrWhile, second, arrayOfVariables, availableFunctions);
            } catch (error) {
                this.throwError('Error parsing the second part', forLoop);
            }

            // Check that the expression resolves to a boolean.
            if (expressionResult.rootDataType && expressionResult.rootDataType.getClassName() !== 'BooleanVariable') {
                this.throwError(secondPartErrorMessage, second);
            }

            return { first: first, second: second, third: third };
        }

        /**
            Iterate through the lines of code to build a flowchart.
            @method buildFlowchartFromLinesRunner
            @param {Array} lines Array of {TokensOfLine} The lines of tokens from which to build the flowchart.
            @param {Integer} baseIndent The smallest allowed indent in the function.
            @param {Integer} expectedIndent The expected amount of indentation for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @param {Array} [commentsList=[]] The list of comments waiting to be pair with a node.
            @param {Boolean} [isFirstChildOfFalseBranchOfIfOrElseIf=false] Whether the next node is going to be the first child of the false branch of an if or elseif node.
            @return {FlowchartNode} The top of the current sub-tree.
        */

    }, {
        key: 'buildFlowchartFromLinesRunner',
        value: function buildFlowchartFromLinesRunner( // eslint-disable-line
        lines, baseIndent, expectedIndent, arrayOfVariables, availableFunctions) {
            var commentsList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
            var isFirstChildOfFalseBranchOfIfOrElseIf = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

            var node = null;
            var line = lines.shift();

            if (line) {

                // Compute the indentation length.
                var currentIndent = this.computeIndentationLength(line) / this.indentDivisor;
                var indentation = null;

                if (line.tokens[0].name === 'indent') {
                    indentation = line.tokens.shift();
                }

                // Recursive case: Line is a comment. Store the comment then recurse.
                if (line.tokens[0] && line.tokens[0].name === 'comment') {
                    var comment = line.tokens[0].value.trim();

                    commentsList.push(comment);
                    node = this.buildFlowchartFromLinesRunner(lines, baseIndent, expectedIndent, arrayOfVariables, availableFunctions, commentsList, isFirstChildOfFalseBranchOfIfOrElseIf);
                }

                // Base case: This line belongs to a higher nesting, so we must be at the end of a branch. Put the line back and return null.
                else if (currentIndent < expectedIndent) {
                        if (indentation) {
                            line.tokens.unshift(indentation);
                        }
                        lines.unshift(line);
                    }

                    // Recursive case: Line's indentation matches the current nesting. Create a node from the line then try to do so for the next line.
                    else if (currentIndent === expectedIndent) {

                            // 'elseif' must be the first child of the false branch of an if (or elseif) node.
                            if (line.tokens[0].value === 'elseif' && !isFirstChildOfFalseBranchOfIfOrElseIf) {
                                this.throwError('Should have if/elseif above, but does not', line);
                            }

                            node = this.handleRecursiveBuildFlowchart(line, lines, baseIndent, expectedIndent, arrayOfVariables, availableFunctions, commentsList);
                        }

                        // Error case: Too much indenting.
                        else if (currentIndent > expectedIndent) {
                                var message = 'Expected no indent';

                                if (expectedIndent > 0) {
                                    var expectedIndentWord = 'indent' + (expectedIndent === 1 ? '' : 's');
                                    var currentIndentWord = 'indent' + (currentIndent === 1 ? '' : 's');
                                    var expectedMessage = 'Expected at most ' + expectedIndent + ' ' + expectedIndentWord;
                                    var foundMessage = ', but found ' + currentIndent + ' ' + currentIndentWord;

                                    message = expectedMessage + foundMessage;
                                }

                                this.throwError(message + '. An indent is 3 spaces', line);
                            }
            }

            // Base case: No more lines, but indents are expected, so do nothing.
            else if (expectedIndent > baseIndent) {}

                // Do nothing.


                // Base case: No more lines. We've found the end of the flowchart.
                else {
                        node = new EndNode(null, null, new TokensOfLine('', null));
                    }

            return node;
        }

        /**
            Computate the indentation of the given line.
            @method computeIndentationLength
            @param {TokensOfLine} line The line from which to compute the indentation length.
            @return {Integer} The indentation length of the given line.
        */

    }, {
        key: 'computeIndentationLength',
        value: function computeIndentationLength(line) {
            return line.tokens.length && line.tokens[0].name === 'indent' ? line.tokens[0].value.length : 0;
        }

        /**
            Create a node from the line then try to do so for the next line.
            @method handleRecursiveBuildFlowchart
            @param {TokensOfLine} line The line of tokens from which to make a node.
            @param {Array} lines Array of {TokensOfLine} The lines of tokens from which to build the flowchart.
            @param {Integer} baseIndent The smallest allowed indent in the function.
            @param {Integer} expectedIndent The expected amount of indentation for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @param {Array} commentsList The list of comments waiting to be pair with a node.
            @return {FlowchartNode} The top of the current sub-tree.
        */

    }, {
        key: 'handleRecursiveBuildFlowchart',
        value: function handleRecursiveBuildFlowchart(line, lines, baseIndent, expectedIndent, arrayOfVariables, availableFunctions, commentsList) {
            var _node$comments;

            // eslint-disable-line
            var node = this.makeNodeFromLine(line, arrayOfVariables, availableFunctions);

            // Push comments onto the node.
            (_node$comments = node.comments).push.apply(_node$comments, _toConsumableArray(commentsList));
            commentsList.length = 0;

            switch (node.getName()) {
                case 'InputNode':
                case 'OutputNode':
                case 'AssignmentNode':
                case 'FunctionCallNode':
                    node.setChildNode(this.buildFlowchartFromLinesRunner(lines, baseIndent, expectedIndent, arrayOfVariables, availableFunctions, commentsList));
                    break;

                // Build true branch then false branch.
                case 'LoopNode':
                    {
                        var trueBranchChild = this.buildFlowchartFromLinesRunner(lines, baseIndent, expectedIndent + 1, arrayOfVariables, availableFunctions, commentsList);

                        // Verify the loop has at least one sub-statement.
                        if (!trueBranchChild) {
                            this.throwSubStatementError('A loop', line);
                        }

                        /*
                            Verify a for-loop's true branch doesn't point to the for-loop's 3rd part.
                            Ex: for i = 0; i < 3; i = i + 1 has 3 parts:
                            1. i = 0
                            2. i < 3
                            3. i = i + 1
                             This loop node is the 2nd part. If the loop node points to the 3rd part,
                            then there were no sub-statements in the for-loop.
                        */
                        else if (node.line.isFromForLoop && trueBranchChild.line.isFromForLoop && node.line.lineNumber === trueBranchChild.line.lineNumber) {
                                this.throwSubStatementError('A loop', line);
                            }

                        var falseBranchChild = this.buildFlowchartFromLinesRunner(lines, baseIndent, expectedIndent, arrayOfVariables, availableFunctions, commentsList);

                        this.assignLeavesChildrenToGivenNode(trueBranchChild, node);
                        node.setChildNodeForTrue(trueBranchChild || node);
                        node.setChildNodeForFalse(falseBranchChild);
                        break;
                    }

                // Build true branch, false branch, then after the if-else branches.
                case 'IfNode':
                case 'ElseIfNode':
                    {
                        var _trueBranchChild = this.buildFlowchartFromLinesRunner(lines, baseIndent, expectedIndent + 1, arrayOfVariables, availableFunctions, commentsList);

                        // Verify the true branch has at least one statement.
                        if (!_trueBranchChild) {
                            this.throwSubStatementError('A branch', line);
                        }

                        // If the next line is 'elseif', then don't take from |comments|.
                        var valueOfFirstNonIndentToken = this.getValueOfFirstNonIndentToken(lines);

                        if (valueOfFirstNonIndentToken !== 'elseif') {

                            // Special situation where there were comments above the "else" and there were comments from above the "if" or "elseif".
                            if (commentsList.length && node.comments.length) {
                                var _node$comments2;

                                var trueComment = this.removeInitialTextAndTrim(node.comments[0], '//');
                                var falseComment = this.removeInitialTextAndTrim(commentsList[0], '//');

                                node.comments[0] = '// True: ' + trueComment;
                                commentsList[0] = '// False: ' + falseComment;
                                (_node$comments2 = node.comments).push.apply(_node$comments2, _toConsumableArray(commentsList));
                                commentsList.length = 0;
                            }
                        }

                        var _falseBranchChild = null;

                        // If the next line is an else or elseif with the expected indentation, then traverse the false branch.
                        if (this.nextLineIsElseOrElseIfWithExpectedIndentation(lines, expectedIndent)) {
                            var isElseLine = valueOfFirstNonIndentToken === 'else';
                            var indentOffset = isElseLine ? 1 : 0;
                            var nextLine = lines[0];

                            // Remove the else line.
                            if (isElseLine) {
                                this.verifyElseLineHasNoErrors(lines.shift());
                            }

                            _falseBranchChild = this.buildFlowchartFromLinesRunner(lines, baseIndent, expectedIndent + indentOffset, arrayOfVariables, availableFunctions, commentsList, true);

                            if (isElseLine && !_falseBranchChild) {
                                this.throwSubStatementError('An else statement', nextLine);
                            }
                        }

                        // If next line is else or elseif, then there is an error.
                        if (this.nextLineIsElseOrElseIfWithExpectedIndentation(lines, expectedIndent)) {
                            this.throwError('Should have if/elseif above, but does not', lines[0]);
                        }

                        var nodeAfterIfElse = null;

                        /*
                            If the false branch was an elseif, then get that elseif's merge node. Ex:
                            if 1==1
                                Put "a" to output
                            elseif 2==2
                                Put "b" to output
                            else
                                Put "c" to output
                            Put "d" to output
                             Put "d" to output is the merge node of the elseif, which is what comes after the if-else structure.
                        */
                        if (_falseBranchChild && _falseBranchChild.getName() === 'ElseIfNode') {
                            nodeAfterIfElse = this.findMergeNode(_falseBranchChild);
                        } else {
                            nodeAfterIfElse = this.buildFlowchartFromLinesRunner(lines, baseIndent, expectedIndent, arrayOfVariables, availableFunctions, commentsList);
                        }

                        this.assignLeavesChildrenToGivenNode(_trueBranchChild, nodeAfterIfElse);
                        this.assignLeavesChildrenToGivenNode(_falseBranchChild, nodeAfterIfElse);
                        node.setChildNodeForTrue(_trueBranchChild || nodeAfterIfElse);
                        node.setChildNodeForFalse(_falseBranchChild || nodeAfterIfElse);
                        break;
                    }
                default:
                    this.throwError('Unsupported node type', line);
            }

            return node;
        }

        /**
            Verify that the given else line has no errors.
            @method verifyElseLineHasNoErrors
            @param {TokensOfLine} elseLine Verify there are no errors in this line.
            @return {void}
        */

    }, {
        key: 'verifyElseLineHasNoErrors',
        value: function verifyElseLineHasNoErrors(elseLine) {

            // Remove indent token, if it exists.
            if (elseLine.tokens[0].name === 'indent') {
                elseLine.tokens.shift();
            }

            // Remove else token.
            elseLine.tokens.shift();

            // Check if there are tokens after 'else'. If so, throw error b/c there shouldn't be.
            if (elseLine.tokens.length) {
                var suggestion = elseLine.tokens[0].value === 'if' ? combineWordsIntoSuggestion(['elseif']) : null;

                this.throwError('\'else\' should be the only item on the line', elseLine, suggestion);
            }
        }

        /**
            Return whether the next line is an else or elseif with the expected indentation.
            @method nextLineIsElseOrElseIfWithExpectedIndentation
            @param {Array} lines Array of {TokensOfLine}. The lines of tokens being parsed.
            @param {Integer} expectedIndent The expected amount of indentation.
            @return {Boolean} Whether the next line is an else or elseif with the expected indentation.
        */

    }, {
        key: 'nextLineIsElseOrElseIfWithExpectedIndentation',
        value: function nextLineIsElseOrElseIfWithExpectedIndentation(lines, expectedIndent) {
            var nextLineIsElseOrElseIfWithExpectedIndentation = false;

            if (lines.length) {
                var nextLineIndenting = this.computeIndentationLength(lines[0]) / this.indentDivisor;
                var valueOfFirstNonIndentToken = this.getValueOfFirstNonIndentToken(lines);
                var isNextLineElseOrElseIf = ['else', 'elseif'].indexOf(valueOfFirstNonIndentToken) !== -1;

                nextLineIsElseOrElseIfWithExpectedIndentation = expectedIndent === nextLineIndenting && isNextLineElseOrElseIf;
            }

            return nextLineIsElseOrElseIfWithExpectedIndentation;
        }

        /**
            Make a node from the given line of tokens.
            @method makeNodeFromLine
            @param {TokensOfLine} line The line of tokens from which to make the node.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {FlowchartNode} The node made from the line.
        */

    }, {
        key: 'makeNodeFromLine',
        value: function makeNodeFromLine(line, arrayOfVariables, availableFunctions) {
            var node = null;
            var tokens = line.tokens;
            var firstToken = tokens.shift();

            if (firstToken.name === 'word') {
                if (firstToken.value === 'Put') {
                    node = this.buildOutputNodeGivenPutToken(line, arrayOfVariables, availableFunctions);
                } else if (firstToken.value === 'if') {
                    node = this.buildIfNodeGivenIfToken(line, arrayOfVariables, availableFunctions);
                } else if (firstToken.value === 'while') {
                    node = this.buildLoopNodeGivenWhileToken(line, arrayOfVariables, availableFunctions);
                } else if (firstToken.value === 'elseif') {
                    node = this.buildElseIfNodeGivenElseIfToken(line, arrayOfVariables, availableFunctions);
                }

                // Assignment indicates this is an input or assignment node.
                else if (tokens.find(function (token) {
                        return token.name === 'assignment';
                    })) {

                        // Build list of tokens before the assignment.
                        var foundFirstAssignment = false;
                        var tokensBeforeAssignment = [firstToken];

                        while (!foundFirstAssignment && tokens.length) {
                            if (tokens[0].name === 'assignment') {
                                foundFirstAssignment = true;
                            } else {
                                tokensBeforeAssignment.push(tokens.shift());
                            }
                        }

                        // Build the abstract syntax tree for the assigned value.
                        var expressionParseResult = this.runExpressionParserOnLine(tokensBeforeAssignment, line, arrayOfVariables, availableFunctions);

                        // Remove the assignment.
                        tokens.shift();

                        if (tokens.length) {

                            // Build an input node.
                            if (tokens[0].value === 'Get') {
                                node = this.buildInputNodeGivenAssignedTree(expressionParseResult, line);
                            }

                            // Build an assignment node.
                            else {
                                    node = this.buildAssignmentNodeGivenAssignedTree(expressionParseResult, line, arrayOfVariables, availableFunctions);
                                }
                        } else {
                            this.throwError('Expected an expression after the assignment operator', line);
                        }
                    }

                    // Build a function call node.
                    else {

                            // Add the function name token back.
                            tokens.unshift(firstToken);
                            node = this.buildFunctionCallNode(line, arrayOfVariables, availableFunctions);
                        }
            } else {
                this.throwError('Expected word, found ' + firstToken.name, line);
            }

            return node;
        }

        /**
            Return the value of the first non-indent token of the next line.
            @method getValueOfFirstNonIndentToken
            @param {Array} lines Array of {TokensOfLine} The lines of tokens from which to get the value.
            @return {String} The value of the first non-indent token of the next line.
        */

    }, {
        key: 'getValueOfFirstNonIndentToken',
        value: function getValueOfFirstNonIndentToken(lines) {
            var valueOfFirstNonIndentToken = '';

            if (lines.length && lines[0].tokens.length) {
                var nextLineTokens = lines[0].tokens;

                if (nextLineTokens[0].name === 'indent') {
                    valueOfFirstNonIndentToken = nextLineTokens[1] ? nextLineTokens[1].value : '';
                } else {
                    valueOfFirstNonIndentToken = nextLineTokens[0].value;
                }
            }

            return valueOfFirstNonIndentToken;
        }

        /**
            Assign the leaves in the given tree of nodes with |node|.
            @method assignLeavesChildrenToGivenNode
            @param {FlowchartNode} tree The top of the tree.
            @param {FlowchartNode} node The node with which to assign to the leaves' children.
            @param {Array} [traversedNodes=[]] Array of {FlowchartNode}. The list of nodes that have already been traversed.
            @return {void}
        */

    }, {
        key: 'assignLeavesChildrenToGivenNode',
        value: function assignLeavesChildrenToGivenNode(tree, node) {
            var traversedNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            // eslint-disable-line complexity

            // If |tree| exists and hasn't been traversed, then traverse it.
            if (tree && traversedNodes.indexOf(tree) === -1) {
                traversedNodes.push(tree);

                // Base case: Found self. Do not pursue this tree.
                if (tree === node) {
                    return;
                }

                switch (tree.getName()) {

                    // Base case: End node has no children.
                    case 'EndNode':
                        break;

                    case 'InputNode':
                    case 'OutputNode':
                    case 'AssignmentNode':
                    case 'FunctionCallNode':

                        // Recursive case: Child node exists, so traverse that node.
                        if (tree.getChildNode()) {
                            this.assignLeavesChildrenToGivenNode(tree.getChildNode(), node, traversedNodes);
                        }

                        // Base case: Child node doesn't exist, so assign |node|.
                        else {
                                tree.setChildNode(node);
                            }
                        break;
                    case 'LoopNode':
                    case 'IfNode':
                    case 'ElseIfNode':
                        {

                            // Recursive case: True branch child exists, so traverse that node.
                            if (tree.getChildNodeForTrue()) {
                                this.assignLeavesChildrenToGivenNode(tree.getChildNodeForTrue(), node, traversedNodes);
                            }

                            // Base case: True branch child doesn't exist, so assign |node|.
                            else {
                                    tree.setChildNodeForTrue(node);
                                }

                            // Recursive case: False branch child exists, so traverse that node.
                            if (tree.getChildNodeForFalse()) {
                                this.assignLeavesChildrenToGivenNode(tree.getChildNodeForFalse(), node, traversedNodes);
                            }

                            // Base case: False branch child doesn't exist, so assign |node|.
                            else {
                                    tree.setChildNodeForFalse(node);
                                }
                            break;
                        }
                    default:
                        throw new Error('Unknown node type ' + tree.getName() + ' encountered in assignLeavesChildrenToGivenNode');
                }
            }
        }

        /**
            Build an if-else node from the given line.
            @method buildIfNodeGivenIfToken
            @param {TokensOfLine} line The tokens for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {IfNode} The if-else node build from the given line of tokens.
        */

    }, {
        key: 'buildIfNodeGivenIfToken',
        value: function buildIfNodeGivenIfToken(line, arrayOfVariables, availableFunctions) {
            var expressionResult = this.runExpressionParserOnLine(line.tokens, line, arrayOfVariables, availableFunctions);

            // Extract the expression from the line of code. Ex: Extract "x > 5" from "if x > 5".
            var userExpression = this.removeInitialTextAndTrim(line.line, 'if');

            // Check that the expression resolves to a boolean.
            if (expressionResult.rootDataType && expressionResult.rootDataType.getClassName() !== 'BooleanVariable') {
                this.throwError('Expression does not evaluate to a boolean value', line);
            }

            return new IfNode(expressionResult.tree, userExpression, line);
        }

        /**
            Build a loop node from the given line.
            @method buildLoopNodeGivenWhileToken
            @param {TokensOfLine} line The tokens for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {LoopNode} The loop node build from the given line of tokens.
        */

    }, {
        key: 'buildLoopNodeGivenWhileToken',
        value: function buildLoopNodeGivenWhileToken(line, arrayOfVariables, availableFunctions) {
            var expressionResult = this.runExpressionParserOnLine(line.tokens, line, arrayOfVariables, availableFunctions);

            // Extract the expression from the line of code. Ex: Extract "x > 5" from "while x > 5".
            var userExpression = this.removeInitialTextAndTrim(line.line, 'while');

            // Check that the expression resolves to a boolean.
            if (expressionResult.rootDataType && expressionResult.rootDataType.getClassName() !== 'BooleanVariable') {
                this.throwError('Expression does not evaluate to a boolean value', line);
            }

            return new LoopNode(expressionResult.tree, userExpression, line);
        }

        /**
            Build an elseif node from the given line.
            @method buildElseIfNodeGivenElseIfToken
            @param {TokensOfLine} line The tokens for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {LoopNode} The loop node build from the given line of tokens.
        */

    }, {
        key: 'buildElseIfNodeGivenElseIfToken',
        value: function buildElseIfNodeGivenElseIfToken(line, arrayOfVariables, availableFunctions) {
            var expressionResult = this.runExpressionParserOnLine(line.tokens, line, arrayOfVariables, availableFunctions);

            // Extract the expression from the line of code. Ex: Extract "x > 5" from "elseif x > 5".
            var userExpression = this.removeInitialTextAndTrim(line.line, 'elseif');

            // Check that the expression resolves to a boolean.
            if (expressionResult.rootDataType && expressionResult.rootDataType.getClassName() !== 'BooleanVariable') {
                this.throwError('Expression does not evaluate to a boolean value', line);
            }

            return new ElseIfNode(expressionResult.tree, userExpression, line);
        }

        /**
            Build an assignment node from the given line.
            @method buildAssignmentNodeGivenAssignedTree
            @param {ExpressionParserResult} assignedResult The expression result of the assignment variable.
            @param {TokensOfLine} line The tokens for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {AssignmentNode} Built by parsing the remaining tokens.
        */

    }, {
        key: 'buildAssignmentNodeGivenAssignedTree',
        value: function buildAssignmentNodeGivenAssignedTree(assignedResult, line, arrayOfVariables, availableFunctions) {

            // Throw special error if ending in semicolon.
            if (line.tokens[line.tokens.length - 1].value === ';') {
                this.throwErrorEndsWithSemicolon(line);
            }

            var assigneeResult = this.runExpressionParserOnLine(line.tokens, line, arrayOfVariables, availableFunctions);

            // Separate the assigned from the assignment expression. Ex: Extract "y" and x + 1" from "y = x + 1".
            var splitExpression = line.line.split('=');
            var userAssignedExpression = splitExpression.shift().trim();
            var userExpression = splitExpression.join('').trim();

            // Either both trees evaluated to being arrays variables, or both evaluated to being non-array, number variables.
            if (assignedResult.rootDataType && assigneeResult.rootDataType) {
                var isAssignedAnArray = assignedResult.rootDataType.isArray();
                var isAssigneeAnArray = assigneeResult.rootDataType.isArray();

                // Both can be an array.
                if (isAssignedAnArray && isAssigneeAnArray) {}

                // Do nothing.


                // Cannot have one array and one not an array.
                else if (isAssignedAnArray && !isAssigneeAnArray) {
                        this.throwError('Cannot assign non-array variable to an array variable', line);
                    } else if (!isAssignedAnArray && isAssigneeAnArray) {
                        this.throwError('Cannot assign array variable to a non-array variable', line);
                    }

                    // If assigned is not an array, then it must evaluate to a non-array variable.
                    else if (!this.doesEvaluateToNonArrayVariable(assignedResult)) {
                            this.throwError('Must assign to a variable', line);
                        }

                        // If assignee is not an array, then it must evaluate to an integer or float variable.
                        else if (!this.doesEvaluateToNumericVariable(assigneeResult)) {
                                this.throwError('Right-hand side of assignment does not evaluate to integer or float', line);
                            }
            } else {
                this.throwError('Both sides of the assignment must have something', line);
            }

            return new AssignmentNode(assignedResult.tree, assigneeResult.tree, userAssignedExpression, userExpression, line);
        }

        /**
            Build a function call node from the line of tokens.
            @method buildFunctionCallNode
            @param {TokensOfLine} line The tokens for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {FunctionCallNode} Built with the line of code.
        */

    }, {
        key: 'buildFunctionCallNode',
        value: function buildFunctionCallNode(line, arrayOfVariables, availableFunctions) {

            // Throw special error if ending in semicolon.
            if (line.tokens[line.tokens.length - 1].value === ';') {
                this.throwErrorEndsWithSemicolon(line);
            }

            var expressionResult = this.runExpressionParserOnLine(line.tokens, line, arrayOfVariables, availableFunctions);

            // Check that there is no return value from the called function.
            if (expressionResult.rootDataType) {
                this.throwError('Function\'s return value not used', line);
            }

            return new FunctionCallNode(expressionResult.tree, line.line.trim(), line);
        }

        /**
            Parse the remaining tokens to build an input node.
            @method buildInputNodeGivenAssignedTree
            @param {ExpressionParserResult} assignedResult The expression result of the assignment variable.
            @param {TokensOfLine} line The tokens for this line.
            @return {InputNode} Built by parsing the remaining tokens.
        */

    }, {
        key: 'buildInputNodeGivenAssignedTree',
        value: function buildInputNodeGivenAssignedTree(assignedResult, line) {
            var tokens = line.tokens;

            // Expecting 3 tokens: 'Get', 'next', 'input'.
            if (tokens.length !== 3 || tokens[1].value !== 'next' || tokens[2].value !== 'input') {
                // eslint-disable-line no-magic-numbers

                // Throw special error semicolon after 'input'.
                if (tokens.length === 4 && tokens[3].value === ';') {
                    // eslint-disable-line no-magic-numbers
                    this.throwErrorEndsWithSemicolon(line);
                } else {
                    this.throwError('Expected input format: <variable> = Get next input', line);
                }
            }

            // Extract the assigned expression from the line of code. Ex: Extract "x[1]" from "x[1] = Get next input".
            var userExpression = line.line.split('=')[0].trim();

            if (!this.doesEvaluateToNonArrayVariable(assignedResult)) {
                this.throwError('Expected assignment to be to a non-array variable', line);
            }

            return new InputNode(assignedResult.tree, userExpression, line);
        }

        /**
            Parse the remaining tokens to build an output node.
            @method buildOutputNodeGivenPutToken
            @param {TokensOfLine} line The tokens for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {OutputNode} Built by parsing the remaining tokens.
        */

    }, {
        key: 'buildOutputNodeGivenPutToken',
        value: function buildOutputNodeGivenPutToken(line, arrayOfVariables, availableFunctions) {

            // 'Put' has already been removed.
            var tokens = line.tokens;
            var thingToOutputToken = tokens.shift();
            var errorMessage = 'Expected output format: Put <string or variable> to output';

            if (!thingToOutputToken) {
                this.throwError(errorMessage, line);
            }

            var isString = thingToOutputToken.name === 'string';
            var expressionTree = null;
            var userExpression = thingToOutputToken.value;

            if (isString) {}

            // Do nothing. The values are setup above.


            // Build an abstract syntax tree for the thing to output.
            else {

                    // Move all output tokens to |tokensToOutput| for abstract syntax tree building.
                    var tokensToOutput = [thingToOutputToken];

                    while (tokens.length && tokens[0].value !== 'to') {
                        tokensToOutput.push(tokens.shift());
                    }

                    var expressionResult = this.runExpressionParserOnLine(tokensToOutput, line, arrayOfVariables, availableFunctions);
                    var doesExpressionEvaluateToANonArrayNumericalValue = expressionResult.rootDataType && expressionResult.rootDataType.getClassName() !== 'BooleanVariable' && !expressionResult.rootDataType.isArray();

                    // Ensure the expression evaluates to a non-array, numerical value.
                    if (!doesExpressionEvaluateToANonArrayNumericalValue) {
                        this.throwError('Expected output of a numerical value', line);
                    }

                    // Get everything between "Put" and "to" in "Put ____ to output".
                    var endIndexOfPut = line.line.indexOf('Put') + 'Put'.length;
                    var startIndexOfTo = line.line.lastIndexOf('to');

                    userExpression = line.line.slice(endIndexOfPut, startIndexOfTo).trim();
                    expressionTree = expressionResult.tree;
                }

            // Output must end with "to output"
            if (tokens.length !== 2 || tokens[0].value !== 'to' || tokens[1].value !== 'output') {
                // eslint-disable-line no-magic-numbers

                // Throw special error semicolon after 'output'.
                if (tokens.length === 3 && tokens[2].value === ';') {
                    // eslint-disable-line no-magic-numbers
                    this.throwErrorEndsWithSemicolon(line);
                } else {
                    this.throwError(errorMessage, line);
                }
            }

            // Catch potential parsing errors with the string.
            var node = null;

            try {
                node = new OutputNode(expressionTree, userExpression, isString, line);
            } catch (error) {
                this.throwError(error.message, line);
            }

            return node;
        }

        /**
            Parse the given line and return the result.
            @method runExpressionParserOnLine
            @param {Array} tokens Array of {Token}. The tokens to parse.
            @param {TokensOfLine} line The tokens for this line.
            @param {Array} arrayOfVariables Array of {Variables} List of the parameter, local, and return variables.
            @param {Array} availableFunctions Array of {ProgramFunction}. The available functions in this program.
            @return {ExpressionParserResult} The result of the token parsing.
        */

    }, {
        key: 'runExpressionParserOnLine',
        value: function runExpressionParserOnLine(tokens, line, arrayOfVariables, availableFunctions) {
            var result = null;

            try {
                result = this.expressionParser.parse(tokens, arrayOfVariables, availableFunctions);
            } catch (error) {
                this.throwError(error.error, line, error.suggestion);
            }

            return result;
        }

        /**
            Return whether the parser result evaluates to a non-array, numeric variable.
            @method doesEvaluateToNumericVariable
            @param {ExpressionParserResult} result The result to evaluate.
            @return {Boolean} Whether the parser result evaluates to a non-array, numeric variable.
        */

    }, {
        key: 'doesEvaluateToNumericVariable',
        value: function doesEvaluateToNumericVariable(result) {
            return !result.tree.root.operator || arithmeticOperatorExpression.test(result.tree.root.operator) || result.tree.root.getClassName() === 'SubscriptOperatorSymbol';
        }

        /**
            Return whether the parser result evaluates to a non-array variable.
            @method doesEvaluateToNonArrayVariable
            @param {ExpressionParserResult} result The result to evaluate.
            @return {Boolean} Whether the parser result evaluates to a non-array variable.
        */

    }, {
        key: 'doesEvaluateToNonArrayVariable',
        value: function doesEvaluateToNonArrayVariable(result) {
            var doesEvaluateToNonArrayVariable = false;

            // Resolve to a non-array variable.
            if (result.tree.root) {
                var rootClass = result.tree.root.getClassName();

                // Subscript and memory cell resolve to a non-array variable.
                if (['SubscriptOperatorSymbol', 'MemoryCellSymbol'].indexOf(rootClass) >= 0) {
                    doesEvaluateToNonArrayVariable = true;
                }

                // Variable that is non-array is non-array.
                else if (rootClass === 'VariableSymbol' && !result.tree.root.variable.isArray()) {
                        doesEvaluateToNonArrayVariable = true;
                    }
            }

            return doesEvaluateToNonArrayVariable;
        }

        /**
            Build the local variables from lines of tokens.
            @method buildLocalVariablesFromLines
            @param {Array} lines Array of {TokensOfLine}. The lines from which to build the local variables.
            @param {String} name The name of the local variables.
            @param {Boolean} wasMainFunctionInjected Whether the main function was injected.
            @param {Boolean} isFunctionMain Whether the local variables are in the Main function.
            @param {Object} functionScope Stores the existing function names, parameter variables, and return variable.
            @return {Variables} The local variables.
        */

    }, {
        key: 'buildLocalVariablesFromLines',
        value: function buildLocalVariablesFromLines(lines, name, wasMainFunctionInjected, isFunctionMain, functionScope) {
            var _this50 = this;

            var localVariables = new Variables(name);

            // Look through lines to verify indentation is of smallest indent size then remove indentation.
            if (!wasMainFunctionInjected) {
                lines.forEach(function (line) {
                    var indentToken = line.tokens.shift();
                    var indentationSize = indentToken.value.length;

                    if (indentationSize !== _this50.indentDivisor) {
                        _this50.throwError('Indentation is ${indentationSize} but expected ${this.indentDivisor}', line);
                    }
                });
            }

            lines.forEach(function (line) {
                var variable = _this50.makeVariable(line);

                // Check if variable name (i.e., identifier) already exists as a local/parameter/return variable name or an implicit/built-in/user-defined function name.
                if (localVariables.getVariable(variable.name)) {
                    var variableType = isFunctionMain ? '' : 'local ';

                    _this50.throwDuplicateIdentifierError(variable.name, variableType + 'variable', line);
                } else if (functionScope.parameterVariables.getVariable(variable.name)) {
                    _this50.throwDuplicateIdentifierError(variable.name, 'parameter variable', line);
                } else if (functionScope.returnVariable.getVariable(variable.name)) {
                    _this50.throwDuplicateIdentifierError(variable.name, 'return variable', line);
                } else if (functionScope.functionNames.includes(variable.name)) {
                    _this50.throwDuplicateFunctionError(variable.name, line);
                }

                localVariables.push(variable);

                // No tokens should remain.
                if (line.tokens.length) {
                    _this50.throwContentAfterDeclarationError(localVariables[localVariables.length - 1], line);
                }
            });

            return localVariables;
        }

        /**
            Batch the lines into functions.
            @method batchIntoFunctions
            @param {Array} lines Array of {TokensOfLine}. The lines to batch into functions.
            @return {Array} of {Array} of {TokensOfLines}. The lines batched into functions.
        */

    }, {
        key: 'batchIntoFunctions',
        value: function batchIntoFunctions(lines) {
            var _this51 = this;

            var hasExplicitFunction = lines.some(function (line) {
                return line.tokens[0].value === 'Function';
            });
            var batchesOfLines = [];

            if (hasExplicitFunction) {
                var currentFunction = null;

                lines.forEach(function (line) {
                    if (line.tokens[0].value === 'Function') {
                        currentFunction = [line];
                        batchesOfLines.push(currentFunction);
                    } else if (currentFunction) {
                        currentFunction.push(line);
                    } else {
                        _this51.throwError('Cannot have code outside function', line);
                    }
                });
            } else {

                // If no functions, then make one for: Function nothing Main()
                var defaultMain = new TokensOfLine(this.parserInjectedMainMessage, 0);

                defaultMain.push(new Token('word', 'Function'), new Token('word', 'Main'), new Token('openingParens', '('), new Token('closingParens', ')'), new Token('word', 'returns'), new Token('dataType', 'nothing'));

                batchesOfLines.push([defaultMain].concat(_toConsumableArray(lines)));
            }

            return batchesOfLines;
        }

        /**
            Parse the function declaration line to build the return variable, function name, and parameter variables.
            @method parseFunctionDeclaration
            @param {TokensOfLine} line The line to parse.
            @param {Object} globalScope Program's global scope used for checking the identifiers in the function declaration.
            @return {Object} The return variable, function name, and parameter variables.
        */

    }, {
        key: 'parseFunctionDeclaration',
        value: function parseFunctionDeclaration(line, globalScope) {
            // eslint-disable-line complexity
            var lineTokens = line.tokens;

            // Remove the initial "Function" token.
            lineTokens.shift();

            // Get the function name.
            var functionToken = lineTokens.shift();

            if (!functionToken) {
                this.throwError('Missing function name', line);
            } else if (functionToken.name !== 'word' || !isValidIdentifier(functionToken.value)) {
                this.throwError('Invalid function name', line);
            }

            var functionName = functionToken.value;
            var allFunctionNamesSoFar = globalScope.functionNames.slice().concat([functionName]);

            // Check if function name (i.e., identifier) already exists as a parameter/return variable or built-in/user-defined function name.
            if (globalScope.functionNames.includes(functionName)) {
                this.throwDuplicateFunctionError(functionName, line);
            } else if (globalScope.parameterVariablesOfEachFunction.some(function (variables) {
                return variables.getVariable(functionName);
            })) {
                this.throwDuplicateIdentifierError(functionName, 'parameter variable in a different function', line);
            } else if (globalScope.returnVariableOfEachFunction.some(function (variables) {
                return variables.getVariable(functionName);
            })) {
                this.throwDuplicateIdentifierError(functionName, 'return variable in a different function', line);
            }

            // Remove opening parens.
            var openingParensToken = lineTokens.shift();

            if (!openingParensToken || openingParensToken.name !== 'openingParens') {
                this.throwError('Missing opening parens before parameters', line);
            }

            // Build the parameter variables.
            var parameterVariables = new Variables('Parameter variables');

            while (lineTokens.length && lineTokens[0].name !== 'closingParens') {
                var variable = this.makeVariable(line, true);

                this.checkVariableAgainstParametersAndFunctions(variable.name, parameterVariables, allFunctionNamesSoFar, line);

                parameterVariables.push(variable);

                if (lineTokens.length) {

                    // If a token remains, ensure it's a comma then remove it.
                    if (lineTokens[0].name === 'comma') {
                        lineTokens.shift();
                    } else if (lineTokens[0].name === 'closingParens') {

                        // Do nothing.
                    } else {
                        this.throwContentAfterDeclarationError(parameterVariables[parameterVariables.length - 1], line);
                    }
                }
            }

            // Remove closing parens.
            var closingParensToken = lineTokens.shift();

            if (!closingParensToken || closingParensToken.name !== 'closingParens') {
                this.throwError('Missing closing parens after parameters', line);
            }

            // Check for "returns" keyword.
            var returnToken = lineTokens.shift();

            if (!returnToken || returnToken.value !== 'returns') {
                this.throwError('Missing \'returns\' keyword after closing parens', line);
            }

            // Build the return variable.
            var returnVariable = new Variables('Return variable');

            if (!lineTokens.length) {
                this.throwError('Missing return type after \'returns\'', line);
            } else if (lineTokens[0].name === 'dataType') {
                if (lineTokens[0].value === 'nothing') {

                    // Remove the "nothing" token.
                    lineTokens.shift();
                } else {
                    var _variable = this.makeVariable(line, true);

                    this.checkVariableAgainstParametersAndFunctions(_variable.name, parameterVariables, allFunctionNamesSoFar, line);

                    returnVariable.push(_variable);
                }
            } else {
                this.throwError('Invalid return type \'' + lineTokens[0].value + '\'', line, makeSuggestionForInvalidDataType(lineTokens[0].value));
            }

            return { returnVariable: returnVariable, functionName: functionName, parameterVariables: parameterVariables };
        }

        /**
            Check if variable name (i.e., identifier) already exists as a parameter variable or an implicit/built-in/user-defined function name.
            @method checkVariableAgainstParametersAndFunctions
            @param {String} variableName The variable name to check against parameters and function names.
            @param {Variables} parameterVariables The parameter variables of the function.
            @param {Array} functionNames The function names.
            @param {TokensOfLine} line The line of the variable declaration.
            @return {void}
        */

    }, {
        key: 'checkVariableAgainstParametersAndFunctions',
        value: function checkVariableAgainstParametersAndFunctions(variableName, parameterVariables, functionNames, line) {
            if (parameterVariables.getVariable(variableName)) {
                this.throwDuplicateIdentifierError(variableName, 'parameter variable', line);
            } else if (functionNames.includes(variableName)) {
                this.throwDuplicateFunctionError(variableName, line);
            }
        }

        /**
            Make a variable from the given line. Examples of variables:
            integer numCats
            float percentChance
            integer array(5) myNums
            float array(7) myPercents
            @method makeVariable
            @param {TokensOfLine} line The original line of tokens before any pre-processing.
            @return {Variable} The variable made from the given line.
        */

    }, {
        key: 'makeVariable',
        value: function makeVariable(line) {
            // eslint-disable-line
            var lineTokens = line.tokens;

            // Too few tokens this line.
            if (lineTokens.length < 2) {
                // eslint-disable-line no-magic-numbers
                this.throwError('Missing variable name', line);
            }

            // Remove spacing from token type to account for array types having arbitrary whitespace between words. Ex: integer   array
            var dataType = lineTokens.shift().value;
            var dataTypeNoWhitespace = require('utilities').removeWhitespace(dataType);

            // If an array, then get the number of elements.
            var numberOfElements = null;

            if (['integerarray', 'floatarray'].indexOf(dataTypeNoWhitespace) >= 0) {
                if (lineTokens.length < 4) {
                    // eslint-disable-line no-magic-numbers
                    this.throwError('For array declaration, expected data type, number of elements, then variable name', line);
                }

                var parens1 = lineTokens.shift();

                numberOfElements = lineTokens.shift().value;

                var parens2 = lineTokens.shift();

                if (parens1.name !== 'openingParens') {
                    this.throwError('Expected opening parens after the data type', line);
                } else if (parens2.name !== 'closingParens') {
                    this.throwError('Expected closing parens after the number of elements', line);
                }
            }

            // Get the variable name.
            var variableName = lineTokens.shift().value;
            var unknownDataType = false;

            try {
                switch (dataTypeNoWhitespace) {
                    case 'integer':
                        return new IntegerVariable(variableName);
                    case 'float':
                        return new FloatVariable(variableName);
                    case 'integerarray':
                        return new IntegerArray(variableName, numberOfElements);
                    case 'floatarray':
                        return new FloatArray(variableName, numberOfElements);
                    default:
                        unknownDataType = true;
                        break;
                }
            } catch (error) {
                this.throwError(error.message, line);
            }

            if (unknownDataType) {
                this.throwError('Unrecognized data type \'' + dataType + '\'', line, makeSuggestionForInvalidDataType(dataType));
            }
        }

        /**
            Return the code without the initial text and trimmed.
            @method removeInitialTextAndTrim
            @param {String} code The code from which to remove the text and trim.
            @param {String} text The text to remove from the beginning of the code.
            @return {String} The code without the initial text and trimmed.
        */

    }, {
        key: 'removeInitialTextAndTrim',
        value: function removeInitialTextAndTrim(code, text) {
            return code.trim().slice(text.length).trim();
        }

        /**
            Throw an error caused by not having a sub-statement.
            @method throwSubStatementError
            @param {String} name The name of the constructor that doesn't have a sub-statement.
            @param {TokensOfLine} line The line with the error.
            @return {void}
        */

    }, {
        key: 'throwSubStatementError',
        value: function throwSubStatementError(name, line) {
            this.throwError(name + ' must have at least one sub-statement, indented by 3 spaces', line);
        }

        /**
            Throw an error message.
            @method throwError
            @param {String} message The message explaining the error.
            @param {TokensOfLine} line The line with the error.
            @param {String} [suggestion=''] A suggestion on how to address the error.
            @return {void}
        */

    }, {
        key: 'throwError',
        value: function throwError(message, line) {
            var suggestion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

            throw new CompilerError(message, line, suggestion);
        }

        /**
            Throw an error message about not needing a semicolon.
            @method throwErrorEndsWithSemicolon
            @param {TokensOfLine} line The line with the error.
            @return {void}
        */

    }, {
        key: 'throwErrorEndsWithSemicolon',
        value: function throwErrorEndsWithSemicolon(line) {
            this.throwError('Semicolon not needed', line);
        }

        /**
            Throw an error that there is content after a variable declaration.
            @method throwContentAfterDeclarationError
            @param {Variable} variable The variable that has content after it.
            @param {TokensOfLine} line The line on which the variable was declared.
            @return {void}
        */

    }, {
        key: 'throwContentAfterDeclarationError',
        value: function throwContentAfterDeclarationError(variable, line) {
            var classNameToDataType = {
                IntegerVariable: 'integer',
                FloatVariable: 'float',
                IntegerArray: 'integer array',
                FloatArray: 'float array'
            };
            var dataType = classNameToDataType[variable.getClassName()];
            var messageMiddle = '';
            var suggestion = null;

            if (variable.isArray()) {
                messageMiddle = ', number of elements \'(' + variable.sizeCell.getValue() + ')\',';
            } else if (variable.name === 'vector') {
                suggestion = combineWordsIntoSuggestion([dataType + ' array']);
            }

            this.throwError('Found content after data type \'' + dataType + '\'' + messageMiddle + ' and variable name \'' + variable.name + '\'', line, suggestion);
        }

        /**
            Throw an error indicating there is a duplicate identifier.
            @method throwDuplicateIdentifierError
            @param {String} identifierName The name of the duplicate identifier.
            @param {String} type The other type of identifier, which is a duplicate.
            @param {TokensOfLine} line The line on which the identifier was declared.
            @return {void}
        */

    }, {
        key: 'throwDuplicateIdentifierError',
        value: function throwDuplicateIdentifierError(identifierName, type, line) {
            this.throwError('\'' + identifierName + '\' is also declared as a ' + type, line);
        }

        /**
            Throw an error for a duplicate function name.
            @method throwDuplicateFunctionError
            @param {String} functionName The name of the duplicate function.
            @param {TokensOfLine} line The line on which the identifier was declared.
            @return {void}
        */

    }, {
        key: 'throwDuplicateFunctionError',
        value: function throwDuplicateFunctionError(functionName, line) {
            var functionType = builtInFunctionNames.includes(functionName) ? 'built-in ' : '';

            this.throwDuplicateIdentifierError(functionName, functionType + 'function', line);
        }

        /**
            Update the end nodes to all be the same instance of EndNode.
            @method updateEndNodesToBeTheSameInstance
            @param {FlowchartNode} currentNode The current node being traversed.
            @param {EndNode} endNodeToUse The end node instance to use.
            @param {Array} traversedNodes Array of {FlowchartNode}. Nodes that have been traversed.
            @return {void}
        */

    }, {
        key: 'updateEndNodesToBeTheSameInstance',
        value: function updateEndNodesToBeTheSameInstance(currentNode, endNodeToUse) {
            var _this52 = this;

            var traversedNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

            currentNode.children.forEach(function (child, index) {

                // Base case: Found an end node to replace.
                if (child.getName() === 'EndNode') {
                    currentNode.children[index] = endNodeToUse;
                }

                // Recursive case: Found a node that hasn't been traversed.
                else if (traversedNodes.indexOf(child) === -1) {
                        traversedNodes.push(child);
                        _this52.updateEndNodesToBeTheSameInstance(child, endNodeToUse, traversedNodes);
                    }
            });
        }

        /**
            Find the merge node for the elseif node. The merge node is the node at the end of both the true and false branch of the elseif.
            @method findMergeNode
            @param {ElseIftNode} elseIfNode The current node being traversed.
            @return {FlowchartNode} The merge node.
        */

    }, {
        key: 'findMergeNode',
        value: function findMergeNode(elseIfNode) {
            var renderingFactory = new RenderingIndicatorFactory();
            var mergeNodePairs = renderingFactory.findIfElseMergeNodePairs(elseIfNode);
            var mergePair = mergeNodePairs.find(function (pair) {
                return pair.ifElseIfNode === elseIfNode;
            });

            return mergePair ? mergePair.mergeNode : null;
        }
    }]);

    return TextualCodeParser;
}();

'use strict';

/* exported TreeSymbol */

/**
    Abstact class modeling a symbol in an abstract syntax tree.
    @class TreeSymbol
*/

var TreeSymbol = function () {

    /**
        @constructor
    */
    function TreeSymbol() {
        _classCallCheck(this, TreeSymbol);

        /**
            The children of this symbol.
            @property children
            @type {Array} of {Symbol}
        */
        this.children = [];
    }

    /**
        Return the name of this symbol class. Inheriting objects must override.
        @method getClassName
        @return {String} The name of this symbol class.
    */


    _createClass(TreeSymbol, [{
        key: 'getClassName',
        value: function getClassName() {
            throw new Error('TreeSymbol\'s getClassName function should be overridden');
        }

        /**
            Make a clone of this symbol. Inheriting objects must override.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
            @return {TreeSymbol} A clone of this symbol.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            // eslint-disable-line no-unused-vars
            throw new Error('TreeSymbol\'s clone function should be overridden');
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            throw new Error('TreeSymbol\'s shallowCopy function should be overridden');
        }

        /**
            Return whether this symbol is an operator.
            @method isAnOperator
            @return {Boolean} Whether this symbol is an operator.
        */

    }, {
        key: 'isAnOperator',
        value: function isAnOperator() {
            return false;
        }
    }]);

    return TreeSymbol;
}();

'use strict';

/* exported OperatorSymbol */
/* global TreeSymbol */

/**
    Abstact model of an operator symbol.
    @class OperatorSymbol
    @extends TreeSymbol
*/

var OperatorSymbol = function (_TreeSymbol) {
    _inherits(OperatorSymbol, _TreeSymbol);

    /**
        @constructor
        @param {String} operator The operator for this symbol.
    */
    function OperatorSymbol(operator) {
        _classCallCheck(this, OperatorSymbol);

        /**
            The operator for this symbol.
            @property operator
            @type {String}
        */
        var _this53 = _possibleConstructorReturn(this, (OperatorSymbol.__proto__ || Object.getPrototypeOf(OperatorSymbol)).call(this));

        _this53.operator = operator;
        return _this53;
    }

    /**
        Return whether this symbol is an operator.
        @method isAnOperator
        @return {Boolean} Whether this symbol is an operator.
    */


    _createClass(OperatorSymbol, [{
        key: 'isAnOperator',
        value: function isAnOperator() {
            return true;
        }

        /**
            Return whether the operator is left-associative.
            @method isLeftAssociative
            @return {Boolean} Whether the operator is left-associative.
        */

    }, {
        key: 'isLeftAssociative',
        value: function isLeftAssociative() {
            throw new Error('OperatorSymbol\'s isLeftAssociative function should be overridden');
        }

        /**
            Return the precedence of the operator.
            @method getPrecedence
            @return {Integer} The precedence of the operator.
        */

    }, {
        key: 'getPrecedence',
        value: function getPrecedence() {
            throw new Error('OperatorSymbol\'s getPrecedence function should be overridden');
        }
    }]);

    return OperatorSymbol;
}(TreeSymbol);

'use strict';

/* exported AbstractSyntaxTree */

/**
    Model an abstract syntax tree for use in executing a process or decision node.
    @class AbstractSyntaxTree
*/

var AbstractSyntaxTree = function () {

    /**
        @constructor
        @param {TreeSymbol} root The root of the tree.
    */
    function AbstractSyntaxTree(root) {
        _classCallCheck(this, AbstractSyntaxTree);

        /**
            The root of the tree.
            @property root
            @type {TreeSymbol}
        */
        this.root = root;
    }

    /**
        Make a copy of this AST.
        @method clone
        @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
        @return {AbstractSyntaxTree} The cloned AST.
    */


    _createClass(AbstractSyntaxTree, [{
        key: 'clone',
        value: function clone(arrayOfVariables) {
            return new AbstractSyntaxTree(this.root.clone(arrayOfVariables));
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            return new AbstractSyntaxTree(this.root.shallowCopy());
        }
    }]);

    return AbstractSyntaxTree;
}();

'use strict';

/* exported BinaryOperatorSymbol */
/* global OperatorSymbol */

/**
    Model a binary operator symbol, which has two children.
    @class BinaryOperatorSymbol
    @extends OperatorSymbol
*/

var BinaryOperatorSymbol = function (_OperatorSymbol) {
    _inherits(BinaryOperatorSymbol, _OperatorSymbol);

    /**
        @constructor
        @param {String} operator The operator for this symbol.
    */
    function BinaryOperatorSymbol(operator) {
        _classCallCheck(this, BinaryOperatorSymbol);

        /**
            List of operators that are left-associative.
            @property leftAssociativities
            @type {Array} of {String}
        */
        var _this54 = _possibleConstructorReturn(this, (BinaryOperatorSymbol.__proto__ || Object.getPrototypeOf(BinaryOperatorSymbol)).call(this, operator));

        _this54.leftAssociativities = ['*', '/', '%', '+', '-', '<', '>', '>=', '<=', '==', '!=', 'and', 'or'];

        /**
            Lookup dictionary for the precedence of each operator.
            @property precedences
            @type {Dictionary}
        */
        _this54.precedences = {
            '*': 3,
            '/': 3,
            '%': 3,
            '+': 4,
            '-': 4,
            '<': 5,
            '>': 5,
            '>=': 5,
            '<=': 5,
            '==': 6,
            '!=': 6,
            and: 7,
            or: 8
        };
        return _this54;
    }

    /**
        Return the name of this symbol class.
        @method getClassName
        @return {String} The name of this symbol class.
    */


    _createClass(BinaryOperatorSymbol, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'BinaryOperatorSymbol';
        }

        /**
            Make a clone of this symbol.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
            @return {BinaryOperatorSymbol} A clone of this symbol.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            var clone = new BinaryOperatorSymbol(this.operator);

            clone.children[0] = this.children[0].clone(arrayOfVariables);
            clone.children[1] = this.children[1].clone(arrayOfVariables);

            return clone;
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            var clone = new BinaryOperatorSymbol(this.operator);

            clone.children[0] = this.children[0].shallowCopy();
            clone.children[1] = this.children[1].shallowCopy();

            return clone;
        }

        /**
            Return whether the operator is left-associative.
            @method isLeftAssociative
            @return {Boolean} Whether the operator is left-associative.
        */

    }, {
        key: 'isLeftAssociative',
        value: function isLeftAssociative() {
            return this.leftAssociativities.includes(this.operator);
        }

        /**
            Return the precedence of the operator.
            @method getPrecedence
            @return {Integer} The precedence of the operator.
        */

    }, {
        key: 'getPrecedence',
        value: function getPrecedence() {
            return this.precedences[this.operator];
        }
    }]);

    return BinaryOperatorSymbol;
}(OperatorSymbol);

'use strict';

/* exported FunctionCallSymbol */
/* global TreeSymbol */

/**
    Model the function call, which consists of a reference to a {ProgramFunction} and a list of arguments.
    @class FunctionCallSymbol
    @extends TreeSymbol
*/

var FunctionCallSymbol = function (_TreeSymbol2) {
    _inherits(FunctionCallSymbol, _TreeSymbol2);

    /**
        @constructor
        @param {ProgramFunction} programFunction The function to call.
        @param {Number} startIndexToHighlight The index in the line in which this function call starts (first letter of function name).
        @param {Number} endIndexToHighlight The index in the line in which this function call ends (closing parens).
    */
    function FunctionCallSymbol(programFunction, startIndexToHighlight, endIndexToHighlight) {
        _classCallCheck(this, FunctionCallSymbol);

        /**
            The function to call.
            @property function
            @type {ProgramFunction}
        */
        var _this55 = _possibleConstructorReturn(this, (FunctionCallSymbol.__proto__ || Object.getPrototypeOf(FunctionCallSymbol)).call(this));

        _this55.function = programFunction;

        /**
            The index in the line in which this function call starts (first letter of function name).
            @property startIndexToHighlight
            @type {Number}
        */
        _this55.startIndexToHighlight = startIndexToHighlight;

        /**
            The index in the line in which this function call ends (closing parens).
            @property endIndexToHighlight
            @type {Number}
        */
        _this55.endIndexToHighlight = endIndexToHighlight;
        return _this55;
    }

    /**
        Return the name of this symbol class.
        @method getClassName
        @return {String} The name of this symbol class.
    */


    _createClass(FunctionCallSymbol, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'FunctionCallSymbol';
        }

        /**
            Make a clone of this symbol.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
            @return {FunctionCallSymbol} A clone of this symbol.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            var clone = new FunctionCallSymbol(this.function, this.startIndexToHighlight, this.endIndexToHighlight);

            clone.children = this.children.map(function (child) {
                return child.clone(arrayOfVariables);
            });

            return clone;
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            var clone = new FunctionCallSymbol(this.function, this.startIndexToHighlight, this.endIndexToHighlight);

            clone.children = this.children.map(function (child) {
                return child.shallowCopy();
            });

            return clone;
        }
    }]);

    return FunctionCallSymbol;
}(TreeSymbol);

'use strict';

/* exported MemoryCellSymbol */
/* global TreeSymbol, lookupMemoryCellFromVariableLists */

/**
    Model a memory cell symbol, which has no children.
    @class MemoryCellSymbol
    @extends TreeSymbol
*/

var MemoryCellSymbol = function (_TreeSymbol3) {
    _inherits(MemoryCellSymbol, _TreeSymbol3);

    /**
        @constructor
        @param {MemoryCell} memoryCell The memory cell for this symbol.
    */
    function MemoryCellSymbol(memoryCell) {
        _classCallCheck(this, MemoryCellSymbol);

        /**
            The memory cell for this symbol.
            @property memoryCell
            @type {MemoryCell}
        */
        var _this56 = _possibleConstructorReturn(this, (MemoryCellSymbol.__proto__ || Object.getPrototypeOf(MemoryCellSymbol)).call(this));

        _this56.memoryCell = memoryCell;
        return _this56;
    }

    /**
        Return the name of this symbol class.
        @method getClassName
        @return {String} The name of this symbol class.
    */


    _createClass(MemoryCellSymbol, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'MemoryCellSymbol';
        }

        /**
            Make a clone of this symbol.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
            @return {MemoryCellSymbol} A clone of this symbol.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            var newMemoryCell = lookupMemoryCellFromVariableLists(this.memoryCell.name, arrayOfVariables);

            return new MemoryCellSymbol(newMemoryCell);
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            return new MemoryCellSymbol(this.memoryCell);
        }
    }]);

    return MemoryCellSymbol;
}(TreeSymbol);

'use strict';

/* exported SubscriptOperatorSymbol */
/* global OperatorSymbol */

/**
    Model a subscript operator symbol, such as nums[x + 1].
    @class SubscriptOperatorSymbol
    @extends OperatorSymbol
*/

var SubscriptOperatorSymbol = function (_OperatorSymbol2) {
    _inherits(SubscriptOperatorSymbol, _OperatorSymbol2);

    /**
        @constructor
    */
    function SubscriptOperatorSymbol() {
        _classCallCheck(this, SubscriptOperatorSymbol);

        return _possibleConstructorReturn(this, (SubscriptOperatorSymbol.__proto__ || Object.getPrototypeOf(SubscriptOperatorSymbol)).call(this, '[]'));
    }

    /**
        Return the name of this symbol class.
        @method getClassName
        @return {String} The name of this symbol class.
    */


    _createClass(SubscriptOperatorSymbol, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'SubscriptOperatorSymbol';
        }

        /**
            Make a clone of this symbol.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
            @return {SubscriptOperatorSymbol} A clone of this symbol.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            var clone = new SubscriptOperatorSymbol();

            // The first child is the array and the second is the index. Ex: myInts[4] yields myInts (first child) and 4 (second child).
            clone.children[0] = this.children[0].clone(arrayOfVariables);
            clone.children[1] = this.children[1].clone(arrayOfVariables);

            return clone;
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            var clone = new SubscriptOperatorSymbol();

            // The first child is the array and the second is the index. Ex: myInts[4] yields myInts (first child) and 4 (second child).
            clone.children[0] = this.children[0].shallowCopy();
            clone.children[1] = this.children[1].shallowCopy();

            return clone;
        }

        /**
            Return whether the operator is left-associative.
            @method isLeftAssociative
            @return {Boolean} Whether the operator is left-associative.
        */

    }, {
        key: 'isLeftAssociative',
        value: function isLeftAssociative() {
            return true;
        }

        /**
            Return the precedence of the operator.
            @method getPrecedence
            @return {Integer} The precedence of the operator.
        */

    }, {
        key: 'getPrecedence',
        value: function getPrecedence() {
            return 1;
        }
    }]);

    return SubscriptOperatorSymbol;
}(OperatorSymbol);

'use strict';

/* exported UnaryOperatorSymbol */
/* global OperatorSymbol */

/**
    Model a unary operator symbol, which has one child.
    @class UnaryOperatorSymbol
    @extends OperatorSymbol
*/

var UnaryOperatorSymbol = function (_OperatorSymbol3) {
    _inherits(UnaryOperatorSymbol, _OperatorSymbol3);

    function UnaryOperatorSymbol() {
        _classCallCheck(this, UnaryOperatorSymbol);

        return _possibleConstructorReturn(this, (UnaryOperatorSymbol.__proto__ || Object.getPrototypeOf(UnaryOperatorSymbol)).apply(this, arguments));
    }

    _createClass(UnaryOperatorSymbol, [{
        key: 'getClassName',


        /**
            Return the name of this symbol class.
            @method getClassName
            @return {String} The name of this symbol class.
        */
        value: function getClassName() {
            return 'UnaryOperatorSymbol';
        }

        /**
            Make a clone of this symbol.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
            @return {UnaryOperatorSymbol} A clone of this symbol.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            var clone = new UnaryOperatorSymbol(this.operator);

            clone.children[0] = this.children[0].clone(arrayOfVariables);

            return clone;
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            var clone = new UnaryOperatorSymbol(this.operator);

            clone.children[0] = this.children[0].shallowCopy();

            return clone;
        }

        /**
            Return whether the operator is left-associative.
            @method isLeftAssociative
            @return {Boolean} Whether the operator is left-associative.
        */

    }, {
        key: 'isLeftAssociative',
        value: function isLeftAssociative() {
            return false;
        }

        /**
            Return the precedence of the operator.
            @method getPrecedence
            @return {Integer} The precedence of the operator.
        */

    }, {
        key: 'getPrecedence',
        value: function getPrecedence() {
            return 2; // eslint-disable-line no-magic-numbers
        }
    }]);

    return UnaryOperatorSymbol;
}(OperatorSymbol);

'use strict';

/* exported VariableSymbol */
/* global TreeSymbol, parserGeneratedVariableName */

/**
    Model a variable symbol, which has no children.
    @class VariableSymbol
    @extends TreeSymbol
*/

var VariableSymbol = function (_TreeSymbol4) {
    _inherits(VariableSymbol, _TreeSymbol4);

    /**
        @constructor
        @param {Variable} variable The variable for this symbol.
    */
    function VariableSymbol(variable) {
        _classCallCheck(this, VariableSymbol);

        /**
            The variable for this symbol.
            @property variable
            @type {Variable}
        */
        var _this59 = _possibleConstructorReturn(this, (VariableSymbol.__proto__ || Object.getPrototypeOf(VariableSymbol)).call(this));

        _this59.variable = variable;
        return _this59;
    }

    /**
        Return the name of this symbol class.
        @method getClassName
        @return {String} The name of this symbol class.
    */


    _createClass(VariableSymbol, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'VariableSymbol';
        }

        /**
            Make a clone of this symbol.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up variables.
            @return {VariableSymbol} A clone of this symbol.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            var _this60 = this;

            var newVariable = this.variable.name === parserGeneratedVariableName ? this.variable.clone() : arrayOfVariables.map(function (variables) {
                return variables.getVariable(_this60.variable.name);
            }).find(function (variable) {
                return variable;
            });

            return new VariableSymbol(newVariable);
        }

        /**
            Make a shallow copy of this symbol.
            @method shallowCopy
            @return {TreeSymbol} A shallow copy of this symbol.
        */

    }, {
        key: 'shallowCopy',
        value: function shallowCopy() {
            return new VariableSymbol(this.variable);
        }
    }]);

    return VariableSymbol;
}(TreeSymbol);

'use strict';

/* exported FlowchartNode */
/* global VariableSymbol, findNonBuiltInFunctionCalls */

/**
    Abstract model of a node in the flowchart.
    @class FlowchartNode
*/

var FlowchartNode = function () {

    /**
        @constructor
        @param {AbstractSyntaxTree} [expression=null] The expression to execute.
        @param {String} [userExpression=''] The expression as a string, as written by the user.
        @param {TokensOfLine} [line=null] The line associated with this node.
    */
    function FlowchartNode() {
        var expression = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var userExpression = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var line = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, FlowchartNode);

        /**
            The expression to execute.
            @property expression
            @type {AbstractSyntaxTree}
        */
        this.expression = expression;

        /**
            The original version of the expression.
            @property originalExpression
            @type {AbstractSyntaxTree}
        */
        this.originalExpression = expression && expression.shallowCopy();

        /**
            The expression as a string, as written by the user.
            @property userExpression
            @type {String}
        */
        this.userExpression = userExpression;

        /**
            The children of this node.
            @property children
            @type {FlowchartNode}
            @default []
        */
        this.children = [];

        /**
            The comments of the nodes.
            @property comments
            @type {Array}
            @default []
        */
        this.comments = [];

        /**
            The non-builtin function calls in the tree.
            @property nonBuiltInFunctionCalls
            @type {Array} of {FunctionCallSymbol}
            @default []
        */
        this.nonBuiltInFunctionCalls = [];

        /**
            Whether the node is the next to be executed.
            @property isNextToExecute
            @type {Boolean}
            @default false
        */
        this.isNextToExecute = false;

        /**
            The line associated with this node.
            @property line
            @type {TokensOfLine}
        */
        this.line = line;

        if (expression) {
            findNonBuiltInFunctionCalls(this.expression.root, this.nonBuiltInFunctionCalls);
        }
    }

    /**
        Resolve a function call by assigning the return variable.
        @method resolveFunctionCall
        @param {Variable} returnVariable The return variable from a function call.
        @return {void}
    */


    _createClass(FlowchartNode, [{
        key: 'resolveFunctionCall',
        value: function resolveFunctionCall(returnVariable) {
            var symbol = this.nonBuiltInFunctionCalls.shift();

            this.resolveFunctionCallInTree(this.expression, symbol, returnVariable);
        }

        /**
            Resolve a function call by assigning the return variable and removing the function call from the tree.
            @method resolveFunctionCallInTree
            @param {AbstractSyntaxTree} tree The tree from which to resolve the function call.
            @param {FunctionCallSymbol} symbol The symbol to remove from the tree.
            @param {Variable} returnVariable The return variable from a function call.
            @return {void}
        */

    }, {
        key: 'resolveFunctionCallInTree',
        value: function resolveFunctionCallInTree(tree, symbol, returnVariable) {

            // Replace the function call symbol with the returned value.
            if (returnVariable) {
                var variableSymbol = new VariableSymbol(returnVariable.clone());

                if (tree.root === symbol) {
                    tree.root = variableSymbol;
                } else {
                    this.replaceFunctionCallSymbolWithVariable(tree.root, symbol, variableSymbol);
                }
            }

            // The function returned nothing and is the top of the tree, so remove the function from the tree.
            else if (tree.root === symbol) {
                    tree.root = null;
                } else {
                    throw new Error('There is no return value, but a return value was expected.');
                }
        }

        /**
            Recursively find and replace the given symbol in the tree.
            @method replaceFunctionCallSymbolWithVariable
            @param {TreeSymbol} currentSymbol The currently traversed symbol.
            @param {FunctionCallSymbol} symbolToReplace The function call symbol to replace.
            @param {VariableSymbol} variable The variable symbol to replace the function call symbol with.
            @return {void}
        */

    }, {
        key: 'replaceFunctionCallSymbolWithVariable',
        value: function replaceFunctionCallSymbolWithVariable(currentSymbol, symbolToReplace, variable) {
            var _this61 = this;

            currentSymbol.children.forEach(function (child, index) {
                if (child === symbolToReplace) {
                    currentSymbol.children[index] = variable;
                } else {
                    _this61.replaceFunctionCallSymbolWithVariable(child, symbolToReplace, variable);
                }
            });
        }

        /**
            Execute the code in this node. Inheriting models must overwrite.
            @method execute
            @param {Object} context The relevant flowchart properties for execution.
            @return {FlowchartNode} The next node to execute after this one.
        */

    }, {
        key: 'execute',
        value: function execute(context) {
            // eslint-disable-line no-unused-vars
            throw new Error('FlowchartNode\'s execute function should be overridden');
        }

        /**
            Return the name of this node. Inheriting objects must override.
            @method getName
            @return {String} The name of this node.
        */

    }, {
        key: 'getName',
        value: function getName() {
            throw new Error('FlowchartNode\'s getName function should be overridden');
        }

        /**
            Return a clone of this node.
            @method clone
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up memory cells.
            @return {FlowchartNode} A clone of the node.
        */

    }, {
        key: 'clone',
        value: function clone(arrayOfVariables) {
            var _clone$comments;

            var clonedExpression = this.expression ? this.expression.clone(arrayOfVariables) : this.expression;
            var clone = this._nodeSpecificClone(clonedExpression, arrayOfVariables);

            (_clone$comments = clone.comments).push.apply(_clone$comments, _toConsumableArray(this.comments));
            clone.line = this.line;

            return clone;
        }

        /**
            Return a clone of the specific node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up memory cells.
            @return {FlowchartNode} A clone of the specific node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression, arrayOfVariables) {
            // eslint-disable-line no-unused-vars
            throw new Error('FlowchartNode\'s _nodeSpecificClone function should be overridden');
        }

        /**
            Reset the expression and re-build the non-built-in function calls.
            @method reset
            @return {void}
        */

    }, {
        key: 'reset',
        value: function reset() {
            if (this.expression) {
                this.expression = this.originalExpression.shallowCopy();

                findNonBuiltInFunctionCalls(this.expression.root, this.nonBuiltInFunctionCalls);
            }
        }
    }]);

    return FlowchartNode;
}();

'use strict';

/* exported SingleChildNode */
/* global FlowchartNode */

/**
    Abstract model for a node with a single child.
    @class SingleChildNode
    @extends FlowchartNode
*/

var SingleChildNode = function (_FlowchartNode) {
    _inherits(SingleChildNode, _FlowchartNode);

    /**
        @constructor
        @param {AbstractSyntaxTree} expression The expression to execute.
        @param {String} userExpression The expression as a string, as written by the user.
        @param {TokensOfLine} line The line associated with this node.
    */
    function SingleChildNode(expression, userExpression, line) {
        _classCallCheck(this, SingleChildNode);

        // Add the single child.
        var _this62 = _possibleConstructorReturn(this, (SingleChildNode.__proto__ || Object.getPrototypeOf(SingleChildNode)).call(this, expression, userExpression, line));

        _this62.children.push(null);
        return _this62;
    }

    /**
        Set the child node.
        @method setChildNode
        @param {FlowchartNode} childNode The child to set for this node.
        @return {void}
    */


    _createClass(SingleChildNode, [{
        key: 'setChildNode',
        value: function setChildNode(childNode) {
            this.children[0] = childNode;
        }

        /**
            Return the child node.
            @method getChildNode
            @return {FlowchartNode} The child node.
        */

    }, {
        key: 'getChildNode',
        value: function getChildNode() {
            return this.children[0];
        }

        /**
            Perform node-specific execution, then return the child node.
            @method execute
            @param {Object} context The relevant flowchart properties for execution.
            @return {FlowchartNode} The next node to execute after this one.
        */

    }, {
        key: 'execute',
        value: function execute(context) {
            this._nodeSpecificExecution(context);

            return this.getChildNode();
        }

        /**
            Perform node-specific execution. Inheriting models must override.
            @method _nodeSpecificExecution
            @param {Object} context The relevant flowchart properties for execution.
            @return {void}
        */

    }, {
        key: '_nodeSpecificExecution',
        value: function _nodeSpecificExecution(context) {
            // eslint-disable-line no-unused-vars
            throw new Error('SingleChildNode\'s _nodeSpecificExecution function should be overridden');
        }
    }]);

    return SingleChildNode;
}(FlowchartNode);

'use strict';

/* exported ProcessNode */
/* global SingleChildNode */

/**
    Node that executes one line of code.
    @class ProcessNode
    @extends SingleChildNode
*/

var ProcessNode = function (_SingleChildNode) {
    _inherits(ProcessNode, _SingleChildNode);

    function ProcessNode() {
        _classCallCheck(this, ProcessNode);

        return _possibleConstructorReturn(this, (ProcessNode.__proto__ || Object.getPrototypeOf(ProcessNode)).apply(this, arguments));
    }

    return ProcessNode;
}(SingleChildNode);

'use strict';

/* exported AssignmentNode */
/* global ProcessNode, evaluateAbstractSyntaxTree, findNonBuiltInFunctionCalls, isGivenSymbolInAbstractSyntaxTree */

/**
    Node that executes an assignment operation.
    @class AssignmentNode
    @extends ProcessNode
*/

var AssignmentNode = function (_ProcessNode) {
    _inherits(AssignmentNode, _ProcessNode);

    /**
        @constructor
        @param {AbstractSyntaxTree} assignedTree An AST for where to assign the expression's result.
        @param {AbstractSyntaxTree} expression The expression to execute.
        @param {String} userAssignedExpression The user-written assigned part of the assignment statement.
        @param {String} userExpression The expression as a string, as written by the user.
        @param {TokensOfLine} line The line associated with this node.
    */
    function AssignmentNode(assignedTree, expression, userAssignedExpression, userExpression, line) {
        _classCallCheck(this, AssignmentNode);

        /**
            An AST for where to assign the expression's result.
            @property assignedTree
            @type {AbstractSyntaxTree}
        */
        var _this64 = _possibleConstructorReturn(this, (AssignmentNode.__proto__ || Object.getPrototypeOf(AssignmentNode)).call(this, expression, userExpression, line));

        _this64.assignedTree = assignedTree;

        /**
            The original version of the assigned expression.
            @property originalAssignedTree
            @type {AbstractSyntaxTree}
        */
        _this64.originalAssignedTree = assignedTree && assignedTree.shallowCopy();

        /**
            The user-written assigned part of the assignment statement.
            @property userAssignedExpression
            @type {String}
        */
        _this64.userAssignedExpression = userAssignedExpression;

        if (_this64.assignedTree) {
            findNonBuiltInFunctionCalls(_this64.assignedTree.root, _this64.nonBuiltInFunctionCalls);
        }
        return _this64;
    }

    /**
        Resolve a function call by assigning the return variable.
        @method resolveFunctionCall
        @param {Variable} returnVariable The return variable from a function call.
        @return {void}
    */


    _createClass(AssignmentNode, [{
        key: 'resolveFunctionCall',
        value: function resolveFunctionCall(returnVariable) {
            var symbol = this.nonBuiltInFunctionCalls.shift();

            if (isGivenSymbolInAbstractSyntaxTree(symbol, this.assignedTree.root)) {
                this.resolveFunctionCallInTree(this.assignedTree, symbol, returnVariable);
            } else {
                this.resolveFunctionCallInTree(this.expression, symbol, returnVariable);
            }
        }

        /**
            Execute the expression.
            @method _nodeSpecificExecution
            @param {ExecutionContext} context The relevant flowchart properties for execution.
            @return {void}
        */

    }, {
        key: '_nodeSpecificExecution',
        value: function _nodeSpecificExecution(context) {
            var expressionResult = evaluateAbstractSyntaxTree(this.expression.root, context);
            var assignedLocation = evaluateAbstractSyntaxTree(this.assignedTree.root, context);

            // If the value is an array, then copy each value.
            if (assignedLocation.getClassName() !== 'MemoryCell' && assignedLocation.isArray()) {
                expressionResult.copyMemoryCellValuesTo(assignedLocation, true);
            } else {
                assignedLocation.setValueDuringExecution(expressionResult.getValue(context.arrayOfVariables));
            }
        }

        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */

    }, {
        key: 'getName',
        value: function getName() {
            return 'AssignmentNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @param {Array} arrayOfVariables Array of {Variables}. List of variables used for looking up memory cells.
            @return {AssignmentNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression, arrayOfVariables) {
            var clonedAssignedTree = this.assignedTree.clone(arrayOfVariables);

            return new AssignmentNode(clonedAssignedTree, expression, this.userAssignedExpression, this.userExpression);
        }

        /**
            Reset the expression and re-build the non-built-in function calls.
            @method reset
            @return {void}
        */

    }, {
        key: 'reset',
        value: function reset() {
            _get(AssignmentNode.prototype.__proto__ || Object.getPrototypeOf(AssignmentNode.prototype), 'reset', this).call(this);

            if (this.assignedTree) {
                this.assignedTree = this.originalAssignedTree.shallowCopy();
                findNonBuiltInFunctionCalls(this.assignedTree.root, this.nonBuiltInFunctionCalls);
            }
        }
    }]);

    return AssignmentNode;
}(ProcessNode);

'use strict';

/* exported DecisionNode */
/* global FlowchartNode, evaluateAbstractSyntaxTree */

/**
    Abstract model for a decision node with two children.
    @class DecisionNode
    @extends FlowchartNode
*/

var DecisionNode = function (_FlowchartNode2) {
    _inherits(DecisionNode, _FlowchartNode2);

    /**
        @constructor
        @param {AbstractSyntaxTree} expression The expression to execute.
        @param {String} userExpression The expression as a string, as written by the user.
        @param {TokensOfLine} line The line associated with this node.
    */
    function DecisionNode(expression, userExpression, line) {
        _classCallCheck(this, DecisionNode);

        // Decision nodes have two children.
        var _this65 = _possibleConstructorReturn(this, (DecisionNode.__proto__ || Object.getPrototypeOf(DecisionNode)).call(this, expression, userExpression, line));

        _this65.children.push(null, null);
        return _this65;
    }

    /**
        Set the child node for true.
        @method setChildNodeForTrue
        @param {FlowchartNode} childNodeForTrue The child node to take if the expression evaluates to true.
        @return {void}
    */


    _createClass(DecisionNode, [{
        key: 'setChildNodeForTrue',
        value: function setChildNodeForTrue(childNodeForTrue) {
            this.children[0] = childNodeForTrue;
        }

        /**
            Get the child node for true.
            @method getChildNodeForTrue
            @return {FlowchartNode} The child node to take if the expression evaluates to true.
        */

    }, {
        key: 'getChildNodeForTrue',
        value: function getChildNodeForTrue() {
            return this.children[0];
        }

        /**
            Set the child node for false.
            @method setChildNodeForFalse
            @param {FlowchartNode} childNodeForFalse The child node to take if the expression evaluates to false.
            @return {void}
        */

    }, {
        key: 'setChildNodeForFalse',
        value: function setChildNodeForFalse(childNodeForFalse) {
            this.children[1] = childNodeForFalse;
        }

        /**
            Get the child node for false.
            @method getChildNodeForFalse
            @return {FlowchartNode} The child node to take if the expression evaluates to false.
        */

    }, {
        key: 'getChildNodeForFalse',
        value: function getChildNodeForFalse() {
            return this.children[1];
        }

        /**
            Perform node-specific execution, then return the child node.
            @method execute
            @param {ExecutionContext} context The relevant flowchart properties for execution.
            @return {FlowchartNode} The next node to execute after this one.
        */

    }, {
        key: 'execute',
        value: function execute(context) {
            var expressionResult = evaluateAbstractSyntaxTree(this.expression.root, context);

            return expressionResult.getValue() ? this.getChildNodeForTrue() : this.getChildNodeForFalse();
        }
    }]);

    return DecisionNode;
}(FlowchartNode);

'use strict';

/* exported ElseIfNode */
/* global DecisionNode */

/**
    An elseif decision node.
    @class ElseIfNode
    @extends DecisionNode
*/

var ElseIfNode = function (_DecisionNode) {
    _inherits(ElseIfNode, _DecisionNode);

    function ElseIfNode() {
        _classCallCheck(this, ElseIfNode);

        return _possibleConstructorReturn(this, (ElseIfNode.__proto__ || Object.getPrototypeOf(ElseIfNode)).apply(this, arguments));
    }

    _createClass(ElseIfNode, [{
        key: 'getName',


        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */
        value: function getName() {
            return 'ElseIfNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @return {ElseIfNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression) {
            return new ElseIfNode(expression, this.userExpression);
        }
    }]);

    return ElseIfNode;
}(DecisionNode);

'use strict';

/* exported EndNode */
/* global FlowchartNode */

/**
    The last node in a flowchart. Used to indicate a program is at the end.
    @class EndNode
    @extends FlowchartNode
*/

var EndNode = function (_FlowchartNode3) {
    _inherits(EndNode, _FlowchartNode3);

    function EndNode() {
        _classCallCheck(this, EndNode);

        return _possibleConstructorReturn(this, (EndNode.__proto__ || Object.getPrototypeOf(EndNode)).apply(this, arguments));
    }

    _createClass(EndNode, [{
        key: 'execute',


        /**
            EndNode does nothing then returns null.
            @method execute
            @param {Object} context The relevant flowchart properties for execution.
            @return {FlowchartNode} Null reference.
        */
        value: function execute(context) {
            // eslint-disable-line no-unused-vars
            return null;
        }

        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */

    }, {
        key: 'getName',
        value: function getName() {
            return 'EndNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @return {EndNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone() {
            return new EndNode();
        }
    }]);

    return EndNode;
}(FlowchartNode);

'use strict';

/* exported FunctionCallNode */
/* global ProcessNode, evaluateAbstractSyntaxTree */

/**
    Node that executes one function call, which has no return value.
    @class FunctionCallNode
    @extends ProcessNode
*/

var FunctionCallNode = function (_ProcessNode2) {
    _inherits(FunctionCallNode, _ProcessNode2);

    function FunctionCallNode() {
        _classCallCheck(this, FunctionCallNode);

        return _possibleConstructorReturn(this, (FunctionCallNode.__proto__ || Object.getPrototypeOf(FunctionCallNode)).apply(this, arguments));
    }

    _createClass(FunctionCallNode, [{
        key: '_nodeSpecificExecution',


        /**
            Execute the expression.
            @method _nodeSpecificExecution
            @param {ExecutionContext} context The relevant flowchart properties for execution.
            @return {void}
        */
        value: function _nodeSpecificExecution(context) {
            if (this.expression.root) {
                evaluateAbstractSyntaxTree(this.expression.root, context);
            }
        }

        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */

    }, {
        key: 'getName',
        value: function getName() {
            return 'FunctionCallNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @return {FunctionCallNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression) {
            return new FunctionCallNode(expression, this.userExpression);
        }
    }]);

    return FunctionCallNode;
}(ProcessNode);

'use strict';

/* exported IfNode */
/* global DecisionNode */

/**
    An if-else decision node.
    @class IfNode
    @extends DecisionNode
*/

var IfNode = function (_DecisionNode2) {
    _inherits(IfNode, _DecisionNode2);

    function IfNode() {
        _classCallCheck(this, IfNode);

        return _possibleConstructorReturn(this, (IfNode.__proto__ || Object.getPrototypeOf(IfNode)).apply(this, arguments));
    }

    _createClass(IfNode, [{
        key: 'getName',


        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */
        value: function getName() {
            return 'IfNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @return {IfNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression) {
            return new IfNode(expression, this.userExpression);
        }
    }]);

    return IfNode;
}(DecisionNode);

'use strict';

/* exported InputNode */
/* global SingleChildNode, evaluateAbstractSyntaxTree */

/**
    Node that gets the next input and stores to a memory cell.
    @class InputNode
    @extends SingleChildNode
*/

var InputNode = function (_SingleChildNode2) {
    _inherits(InputNode, _SingleChildNode2);

    function InputNode() {
        _classCallCheck(this, InputNode);

        return _possibleConstructorReturn(this, (InputNode.__proto__ || Object.getPrototypeOf(InputNode)).apply(this, arguments));
    }

    _createClass(InputNode, [{
        key: '_nodeSpecificExecution',


        /**
            Store next input in the memory cell.
            @method _nodeSpecificExecution
            @param {Object} context The relevant flowchart properties for execution.
            @return {void}
        */
        value: function _nodeSpecificExecution(context) {
            evaluateAbstractSyntaxTree(this.expression.root, context).setValueDuringExecution(context.input.getNextInput());
        }

        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */

    }, {
        key: 'getName',
        value: function getName() {
            return 'InputNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @return {InputNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression) {
            return new InputNode(expression, this.userExpression);
        }
    }]);

    return InputNode;
}(SingleChildNode);

'use strict';

/* exported LoopNode */
/* global DecisionNode */

/**
    A loop decision node.
    @class LoopNode
    @extends DecisionNode
*/

var LoopNode = function (_DecisionNode3) {
    _inherits(LoopNode, _DecisionNode3);

    function LoopNode() {
        _classCallCheck(this, LoopNode);

        return _possibleConstructorReturn(this, (LoopNode.__proto__ || Object.getPrototypeOf(LoopNode)).apply(this, arguments));
    }

    _createClass(LoopNode, [{
        key: 'getName',


        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */
        value: function getName() {
            return 'LoopNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @return {LoopNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression) {
            return new LoopNode(expression, this.userExpression);
        }
    }]);

    return LoopNode;
}(DecisionNode);

'use strict';

/* exported OutputNode */
/* global SingleChildNode, evaluateAbstractSyntaxTree */

/**
    Node that prints a memory cell's value or string to output.
    @class OutputNode
    @extends SingleChildNode
*/

var OutputNode = function (_SingleChildNode3) {
    _inherits(OutputNode, _SingleChildNode3);

    /**
        @constructor
        @param {AbstractSyntaxTree} expression The expression to execute.
        @param {String} userExpression The expression as a string, as written by the user.
        @param {Boolean} isString Whether the thing to output is a string.
        @param {TokensOfLine} line The line associated with this node.
    */
    function OutputNode(expression, userExpression, isString, line) {
        _classCallCheck(this, OutputNode);

        /**
            Whether the thing to output is a string.
            @property isString
            @type {Boolean}
        */
        var _this72 = _possibleConstructorReturn(this, (OutputNode.__proto__ || Object.getPrototypeOf(OutputNode)).call(this, expression, userExpression, line));

        _this72.isString = isString;

        /**
            The string to output with unescaped characters.
            @property stringToOutput
            @type {String}
            @default null
        */
        _this72.stringToOutput = isString ? _this72.unescape(userExpression) : null;
        return _this72;
    }

    /**
        Print the |thingToOutput| to output.
        @method _nodeSpecificExecution
        @param {Object} context The relevant flowchart properties for execution.
        @return {void}
    */


    _createClass(OutputNode, [{
        key: '_nodeSpecificExecution',
        value: function _nodeSpecificExecution(context) {
            var string = this.isString ? this.stringToOutput : evaluateAbstractSyntaxTree(this.expression.root, context).toString();

            context.output.toPrint(string);
        }

        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */

    }, {
        key: 'getName',
        value: function getName() {
            return 'OutputNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @param {AbstractSyntaxTree} expression The already cloned expression.
            @return {OutputNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone(expression) {
            return new OutputNode(expression, this.userExpression, this.isString);
        }

        /**
            Unescape the characters such as \n to newline, \t to tab, \" to ", and \\ to \.
            @method unescape
            @param {String} string The string to unescape.
            @return {String} The unescaped string.
        */

    }, {
        key: 'unescape',
        value: function unescape(string) {
            var previousCharacterWasBackslash = false;
            var newString = '';
            var stringWithoutQuotes = string.slice(1, -1);

            for (var index = 0; index < stringWithoutQuotes.length; index++) {
                var currentCharacter = stringWithoutQuotes[index];

                if (previousCharacterWasBackslash) {
                    if (currentCharacter === 'n') {
                        newString += '\n';
                    } else if (currentCharacter === 't') {
                        newString += '\t';
                    } else if (currentCharacter === '"') {
                        newString += '"';
                    } else if (currentCharacter === '\\') {
                        newString += '\\';
                    } else {

                        // Do nothing. Just consume this character.
                    }

                    previousCharacterWasBackslash = false;
                } else if (currentCharacter === '\\') {
                    previousCharacterWasBackslash = true;
                } else {
                    newString += currentCharacter;
                    previousCharacterWasBackslash = false;
                }
            }

            if (previousCharacterWasBackslash) {
                throw new Error('Unexpected extra backslash');
            }

            return newString;
        }
    }]);

    return OutputNode;
}(SingleChildNode);

'use strict';

/* exported StartNode */
/* global SingleChildNode */

/**
    The first node in a flowchart.
    @class StartNode
    @extends SingleChildNode
*/

var StartNode = function (_SingleChildNode4) {
    _inherits(StartNode, _SingleChildNode4);

    function StartNode() {
        _classCallCheck(this, StartNode);

        return _possibleConstructorReturn(this, (StartNode.__proto__ || Object.getPrototypeOf(StartNode)).apply(this, arguments));
    }

    _createClass(StartNode, [{
        key: '_nodeSpecificExecution',


        /**
            Nothing to execute.
            @method _nodeSpecificExecution
            @return {void}
        */
        value: function _nodeSpecificExecution() {} // eslint-disable-line no-empty-function

        /**
            Return the name of this node.
            @method getName
            @return {String} The name of this node.
        */

    }, {
        key: 'getName',
        value: function getName() {
            return 'StartNode';
        }

        /**
            Return a clone of this node.
            @method _nodeSpecificClone
            @return {StartNode} A clone of this node.
        */

    }, {
        key: '_nodeSpecificClone',
        value: function _nodeSpecificClone() {
            return new StartNode();
        }
    }]);

    return StartNode;
}(SingleChildNode);

'use strict';

/* exported RenderingIndicator */

/**
    Abstract model of an indicator used for rendering.
    @class RenderingIndicator
*/

var RenderingIndicator = function () {
    function RenderingIndicator() {
        _classCallCheck(this, RenderingIndicator);
    }

    _createClass(RenderingIndicator, [{
        key: 'getName',


        /**
            Return the name of this indicator. Inheriting objects must override.
            @method getName
            @return {String} The name of this indicator.
        */
        value: function getName() {
            throw new Error('RenderingIndicator\'s getName function should be overridden');
        }
    }]);

    return RenderingIndicator;
}();

'use strict';

/* exported MergeRenderingIndicator */
/* global RenderingIndicator */

/**
    Abstract model of indicator to render an edge from the last node of an if-else node's branch.
    @class MergeRenderingIndicator
    @extends RenderingIndicator
*/

var MergeRenderingIndicator = function (_RenderingIndicator) {
    _inherits(MergeRenderingIndicator, _RenderingIndicator);

    /**
        @constructor
        @param {DecisionNode} ifElseIfNode The if or elseif node that was merged.
    */
    function MergeRenderingIndicator(ifElseIfNode) {
        _classCallCheck(this, MergeRenderingIndicator);

        /**
            The if or elseif node that was merged.
            @property ifElseIfNode
            @type {DecisionNode}
        */
        var _this74 = _possibleConstructorReturn(this, (MergeRenderingIndicator.__proto__ || Object.getPrototypeOf(MergeRenderingIndicator)).call(this));

        _this74.ifElseIfNode = ifElseIfNode;
        return _this74;
    }

    return MergeRenderingIndicator;
}(RenderingIndicator);

'use strict';

/* exported BackToLoopRenderingIndicator */
/* global RenderingIndicator */

/**
    Model of indicator to render an edge going back to a loop.
    @class BackToLoopRenderingIndicator
    @extends RenderingIndicator
*/

var BackToLoopRenderingIndicator = function (_RenderingIndicator2) {
    _inherits(BackToLoopRenderingIndicator, _RenderingIndicator2);

    /**
        @constructor
        @param {FlowchartNode} loopNode The loop node to go back to.
        @param {FlowchartNode} nodeBeforeLoopNode The node before the loop node to go back to.
    */
    function BackToLoopRenderingIndicator(loopNode, nodeBeforeLoopNode) {
        _classCallCheck(this, BackToLoopRenderingIndicator);

        /**
            The loop node to go back to.
            @property loopNode
            @type {FlowchartNode}
        */
        var _this75 = _possibleConstructorReturn(this, (BackToLoopRenderingIndicator.__proto__ || Object.getPrototypeOf(BackToLoopRenderingIndicator)).call(this));

        _this75.loopNode = loopNode;

        /**
            The node before the loop node to go back to.
            @property nodeBeforeLoopNode
            @type {FlowchartNode}
        */
        _this75.nodeBeforeLoopNode = nodeBeforeLoopNode;
        return _this75;
    }

    /**
        Return the name of this indicator.
        @method getName
        @return {String} The name of this indicator.
    */


    _createClass(BackToLoopRenderingIndicator, [{
        key: 'getName',
        value: function getName() {
            return 'BackToLoopRenderingIndicator';
        }
    }]);

    return BackToLoopRenderingIndicator;
}(RenderingIndicator);

'use strict';

/* exported CountAndNode */

/**
    Store a node and a counter.
    @class CountAndNode
*/

var CountAndNode = function () {

    /**
        @constructor
        @param {FlowchartNode} node The node to count.
    */
    function CountAndNode(node) {
        _classCallCheck(this, CountAndNode);

        /**
            The node to count.
            @property node
            @type {FlowchartNode}
        */
        this.node = node;

        /**
            The count of the node.
            @property count
            @type {Integer}
            @default 1
        */
        this.count = 1;
    }

    /**
        Return a clone of this instance.
        @method clone
        @return {CountAndNode} A clone of this instance.
    */


    _createClass(CountAndNode, [{
        key: 'clone',
        value: function clone() {
            var clone = new CountAndNode(this.node);

            clone.count = this.count;
            return clone;
        }
    }]);

    return CountAndNode;
}();

'use strict';

/* exported DistanceAndNode */

/**
    Store a node and a distance.
    @class DistanceAndNode
*/

var DistanceAndNode =

/**
    @constructor
    @param {FlowchartNode} node The node to distance.
*/
function DistanceAndNode(node) {
    _classCallCheck(this, DistanceAndNode);

    /**
        The node to distance.
        @property node
        @type {FlowchartNode}
    */
    this.node = node;

    /**
        The distance of the node.
        @property distance
        @type {Integer}
        @default 0
    */
    this.distance = 0;
};

'use strict';

/* exported MergeFalseRenderingIndicator */
/* global MergeRenderingIndicator */

/**
    Model of indicator to render an edge from the last node of an if-else node's false branch.
    @class MergeFalseRenderingIndicator
    @extends MergeRenderingIndicator
*/

var MergeFalseRenderingIndicator = function (_MergeRenderingIndica) {
    _inherits(MergeFalseRenderingIndicator, _MergeRenderingIndica);

    function MergeFalseRenderingIndicator() {
        _classCallCheck(this, MergeFalseRenderingIndicator);

        return _possibleConstructorReturn(this, (MergeFalseRenderingIndicator.__proto__ || Object.getPrototypeOf(MergeFalseRenderingIndicator)).apply(this, arguments));
    }

    _createClass(MergeFalseRenderingIndicator, [{
        key: 'getName',


        /**
            Return the name of this indicator.
            @method getName
            @return {String} The name of this indicator.
        */
        value: function getName() {
            return 'MergeFalseRenderingIndicator';
        }
    }]);

    return MergeFalseRenderingIndicator;
}(MergeRenderingIndicator);

'use strict';

/* exported MergeNodePair */

/**
    Store an if-else node and the associated merge node.
    @class MergeNodePair
*/

var MergeNodePair =

/**
    @constructor
    @param {DecisionNode} ifElseIfNode The if or elseif node.
    @param {FlowchartNode} mergeNode The associated merge node.
*/
function MergeNodePair(ifElseIfNode, mergeNode) {
    _classCallCheck(this, MergeNodePair);

    /**
        The if or elseif node.
        @property ifElseIfNode
        @type {DecisionNode}
    */
    this.ifElseIfNode = ifElseIfNode;

    /**
        The associated merge node.
        @property mergeNode
        @type {FlowchartNode}
    */
    this.mergeNode = mergeNode;
};

'use strict';

/* exported MergeTrueRenderingIndicator */
/* global MergeRenderingIndicator */

/**
    Model of indicator to render an edge from the last node of an if-else node's true branch.
    @class MergeTrueRenderingIndicator
    @extends MergeRenderingIndicator
*/

var MergeTrueRenderingIndicator = function (_MergeRenderingIndica2) {
    _inherits(MergeTrueRenderingIndicator, _MergeRenderingIndica2);

    /**
        @constructor
        @param {Integer} row The node's row during rendering.
        @param {Integer} column The node's column during rendering.
        @param {FlowchartNode} ifElseIfNode The if-else node that was merged.
    */
    function MergeTrueRenderingIndicator(row, column, ifElseIfNode) {
        _classCallCheck(this, MergeTrueRenderingIndicator);

        /**
            The node's row during rendering.
            @property row
            @type {Integer}
        */
        var _this77 = _possibleConstructorReturn(this, (MergeTrueRenderingIndicator.__proto__ || Object.getPrototypeOf(MergeTrueRenderingIndicator)).call(this, ifElseIfNode));

        _this77.row = row;

        /**
            The node's column during rendering.
            @property column
            @type {Integer}
        */
        _this77.column = column;
        return _this77;
    }

    /**
        Return the name of this indicator.
        @method getName
        @return {String} The name of this indicator.
    */


    _createClass(MergeTrueRenderingIndicator, [{
        key: 'getName',
        value: function getName() {
            return 'MergeTrueRenderingIndicator';
        }
    }]);

    return MergeTrueRenderingIndicator;
}(MergeRenderingIndicator);

'use strict';

/* exported NodeRenderingIndicator */
/* global RenderingIndicator */

/**
    Model of node rendering information, including the node, and which column and row the node should be rendered in.
    @class NodeRenderingIndicator
    @extends RenderingIndicator
*/

var NodeRenderingIndicator = function (_RenderingIndicator3) {
    _inherits(NodeRenderingIndicator, _RenderingIndicator3);

    /**
        @constructor
        @param {Integer} row The node's row during rendering.
        @param {Integer} column The node's column during rendering.
        @param {FlowchartNode} node The node to render.
    */
    function NodeRenderingIndicator(row, column, node) {
        _classCallCheck(this, NodeRenderingIndicator);

        /**
            The node's row during rendering.
            @property row
            @type {Integer}
        */
        var _this78 = _possibleConstructorReturn(this, (NodeRenderingIndicator.__proto__ || Object.getPrototypeOf(NodeRenderingIndicator)).call(this));

        _this78.row = row;

        /**
            The node's column during rendering.
            @property column
            @type {Integer}
        */
        _this78.column = column;

        /**
            The node to render.
            @property node
            @type {FlowchartNode}
        */
        _this78.node = node;
        return _this78;
    }

    /**
        Return the name of this indicator.
        @method getName
        @return {String} The name of this indicator.
    */


    _createClass(NodeRenderingIndicator, [{
        key: 'getName',
        value: function getName() {
            return 'NodeRenderingIndicator';
        }
    }]);

    return NodeRenderingIndicator;
}(RenderingIndicator);

'use strict';

/* exported RenderingIndicatorFactory */
/* global MergeNodePair, DistanceAndNode, MergeFalseRenderingIndicator, MergeTrueRenderingIndicator, NodeRenderingIndicator,
          BackToLoopRenderingIndicator, CountAndNode */

/**
    Abstract model of an indicator used for rendering.
    @class RenderingIndicatorFactory
*/

var RenderingIndicatorFactory = function () {
    function RenderingIndicatorFactory() {
        _classCallCheck(this, RenderingIndicatorFactory);
    }

    _createClass(RenderingIndicatorFactory, [{
        key: 'make',


        /**
            Make a list of {RenderingIndicator}s for the given flowchart.
            @method make
            @param {Flowchart} flowchart The flowchart from which to make a list of {RenderingIndicator}s.
            @return {Array} of {RenderingIndicator}. A list of {RenderingIndicator}s for the given flowchart.
        */
        value: function make(flowchart) {
            var list = [];
            var mergeNodePairs = this.findIfElseMergeNodePairs(flowchart.startNode);

            this.createRenderListRunner(flowchart.startNode, 0, 0, mergeNodePairs, [], list);
            this.moveMergeTrueIndicatorColumnsIntoPosition(list);
            return list;
        }

        /**
            In a flowchart, find the nodes that are a merge node for an if-else node's branches.
            That is, at the end of both if-else branches, there is a common node (the merge node). Find those merge nodes.
            @method findIfElseMergeNodePairs
            @param {StartNode} startNode The first node in the flowchart.
            @return {Array} of {MergeNodePair} The merge nodes.
        */

    }, {
        key: 'findIfElseMergeNodePairs',
        value: function findIfElseMergeNodePairs(startNode) {
            var mergeNodePairs = [];

            this.findIfElseMergeNodePairsRunner(startNode, mergeNodePairs, [], []);

            return mergeNodePairs;
        }

        /**
            Traverse a flowchart to find the merge node for each if-else node.
            A merge node for an if-else branch is the node at the end of both the true and false branches of an if-else node.
             @method findIfElseMergeNodePairsRunner
            @param {FlowchartNode} node The current node.
            @param {Array} mergeNodePairs Array of {MergeNodePair}. The running list of if-else nodes associated with their merge nodes.
            @param {Array} visitedNodes Array of {CountAndNode}. The nodes already visited on the way to this node.
            @return {Array} of {DistanceAndNode}. The list of descendant nodes and distance from this node.
        */

    }, {
        key: 'findIfElseMergeNodePairsRunner',
        value: function findIfElseMergeNodePairsRunner(node, mergeNodePairs, visitedNodes) {
            var _this79 = this;

            var descendants = [];

            if (node) {
                var visitedNode = visitedNodes.find(function (element) {
                    return element.node === node;
                });
                var shouldAddNodeToDescendants = false;

                // Base case: Node has already been visited.
                if (visitedNode) {

                    // If a loop node has been visited only once, then include the loop node in the descendants list b/c loop nodes have 2 entry points.
                    if (visitedNode.node.getName() === 'LoopNode') {
                        if (visitedNode.count === 1) {
                            shouldAddNodeToDescendants = true;
                            visitedNode.count++;
                        }
                    }
                } else {
                    shouldAddNodeToDescendants = true;
                    visitedNodes.push(new CountAndNode(node));

                    // Recursive case: Get the descendants of this node's children.
                    var childrenDescendants = node.children.map(function (child) {
                        return _this79.findIfElseMergeNodePairsRunner(child, mergeNodePairs, visitedNodes.map(function (element) {
                            return element.clone();
                        }));
                    });

                    if (childrenDescendants.length === 1) {
                        descendants.push.apply(descendants, _toConsumableArray(childrenDescendants[0]));
                    } else if (childrenDescendants.length === 2) {
                        // eslint-disable-line no-magic-numbers
                        var mergeNode = this.searchForMergeNodeInDescendants(childrenDescendants);

                        if (mergeNode) {
                            mergeNodePairs.push(new MergeNodePair(node, mergeNode));
                        }
                        descendants.push.apply(descendants, _toConsumableArray(this.combineDescendants(childrenDescendants)));
                    }
                }

                if (shouldAddNodeToDescendants) {
                    descendants.unshift(new DistanceAndNode(node));
                    descendants.forEach(function (descendant) {
                        return descendant.distance++;
                    });
                }
            }

            return descendants;
        }

        /**
            Combine the descendants. Remove duplicates, keeping the node with the smallest distance.
            @method combineDescendants
            @param {Array} childrenDescendants Array of {Array} of {DistanceAndNode}. The descendants of each branch, which are to be combined.
            @return {Array} of {DistanceAndNode}. The combined list of descendants.
        */

    }, {
        key: 'combineDescendants',
        value: function combineDescendants(childrenDescendants) {
            var filteredDescendant1 = this.keepDescendantsWithSmallestDistance(childrenDescendants[0], childrenDescendants[1]);
            var filteredDescendant2 = this.keepDescendantsWithSmallestDistance(childrenDescendants[1], childrenDescendants[0], true);

            return filteredDescendant1.concat(filteredDescendant2);
        }

        /**
            Return the subset of |descendants1| that does not contain items from |descendants2|.
            If there is a duplicate, then only return from |descendants1| if |descendants1|'s item has a smaller distance than |descendants2|'s item.
            @method keepDescendantsWithSmallestDistance
            @param {Array} descendants1 Array of {DistanceAndNode}. Return a subset of these that are unique from |descendants2|
            @param {Array} descendants2 Array of {DistanceAndNode}. Used to filter out items from |descendants1|.
            @param {Boolean} enforceSmallest Whether to enforce that the smallest must be found, not just smallest or equal to the smallest.
            @return {Array} of {DistanceAndNode}. The unique descendants from |descendants1|.
        */

    }, {
        key: 'keepDescendantsWithSmallestDistance',
        value: function keepDescendantsWithSmallestDistance(descendants1, descendants2) {
            var enforceSmallest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            return descendants1.filter(function (descendant1) {
                var descendant2Duplicate = descendants2.find(function (descendant2) {
                    return descendant1.node === descendant2.node;
                });
                var keepDescendant = true;

                if (descendant2Duplicate) {
                    keepDescendant = enforceSmallest ? descendant1.distance < descendant2Duplicate.distance : descendant1.distance <= descendant2Duplicate.distance;
                }

                return keepDescendant;
            });
        }

        /**
            Return the mode node in the descendants of each branch, if there is one.
            @method searchForMergeNodeInDescendants
            @param {Array} childrenDescendants Array of {Array} of {DistanceAndNode}. The descendants of each branch.
            @return {FlowchartNode} The merge node, if there is one.
        */

    }, {
        key: 'searchForMergeNodeInDescendants',
        value: function searchForMergeNodeInDescendants(childrenDescendants) {

            // Sort the descendants of each branch by the distance from this node, with closest first.
            childrenDescendants.forEach(function (childDescendants) {
                return childDescendants.sort(function (first, second) {
                    return first.distance - second.distance;
                });
            });

            /*
                The merge node is the node in both branches with the smallest distance from this node.
                That is, there may be multiple nodes that are in both branches, but we want only the merge node with the smallest distance.
            */
            var smallestDistance = Infinity;
            var smallestDistanceNode = null;

            childrenDescendants[0].forEach(function (descendant1) {
                childrenDescendants[1].forEach(function (descendant2) {

                    // Found a potential merge node. Check if it has the smallest distance from this node.
                    if (descendant1.node === descendant2.node) {
                        var distance = Math.min(descendant1.distance, descendant2.distance);

                        if (distance < smallestDistance) {
                            smallestDistance = distance;
                            smallestDistanceNode = descendant1.node;
                        }
                    }
                });
            });

            return smallestDistanceNode;
        }

        /**
            Build a list of rendering indicators by recursively traversing the flowchart.
            @method createRenderListRunner
            @param {FlowchartNode} node The current node being traversed.
            @param {Integer} row The node's row during rendering.
            @param {Integer} column The node's column during rendering.
            @param {Array} mergeNodePairs Array of {MergeNodePair}. List of nodes that are merged at after an if-else node's branches.
            @param {Array} decisionStack Array of {DecisionNode}. Stack of if-else and loop nodes used to track association of merge nodes with if-else nodes.
            @param {Array} list {Array} of {RenderingIndicator}. The list of indicators for rendering.
            @return {Integer} The largest row to date.
        */

    }, {
        key: 'createRenderListRunner',
        value: function createRenderListRunner(node, row, column, mergeNodePairs, decisionStack, list) {
            // eslint-disable-line max-params
            var rowToUse = row;
            var topOfStack = decisionStack[decisionStack.length - 1];

            // Base case: Node is a merge pair node of the top of the stack.
            if (mergeNodePairs.some(function (pair) {
                return pair.mergeNode === node && pair.ifElseIfNode === topOfStack;
            })) {
                rowToUse -= 1;
            }

            // Base case: Reached end of loop node's true branch.
            else if (node === topOfStack) {
                    rowToUse -= 1;
                }

                // Traverse the node.
                else {
                        rowToUse = this.handleRenderListNode(node, rowToUse, column, mergeNodePairs, decisionStack, list);
                    }

            return rowToUse;
        }

        /**
            Handle the node creation and child recursion.
            @method handleRenderListNode
            @param {FlowchartNode} node The current node being traversed.
            @param {Integer} row The node's row during rendering.
            @param {Integer} column The node's column during rendering.
            @param {Array} mergeNodePairs Array of {MergeNodePair}. List of nodes that are merged at after an if-else node's branches.
            @param {Array} decisionStack Array of {DecisionNode}. Stack of if-else and loop nodes used to track association of merge nodes with if-else nodes.
            @param {Array} list {Array} of {RenderingIndicator}. The list of indicators for rendering.
            @return {Integer} The largest row to date.
        */

    }, {
        key: 'handleRenderListNode',
        value: function handleRenderListNode(node, row, column, mergeNodePairs, decisionStack, list) {
            // eslint-disable-line
            var rowToUse = row;

            list.push(new NodeRenderingIndicator(rowToUse, column, node));

            switch (node.getName()) {

                // Recursive case: Node has 1 child.
                case 'AssignmentNode':
                case 'FunctionCallNode':
                case 'InputNode':
                case 'OutputNode':
                case 'StartNode':
                    rowToUse = this.createRenderListRunner(node.getChildNode(), rowToUse + 1, column, mergeNodePairs, decisionStack, list);
                    break;

                // Recursive case: Node is a loop node.
                case 'LoopNode':
                    {
                        decisionStack.push(node);

                        // Run the true branch.
                        rowToUse = this.createRenderListRunner(node.getChildNodeForTrue(), rowToUse, column + 1, mergeNodePairs, decisionStack, list);

                        decisionStack.pop();

                        // When true branch has no nodes, |rowToUse| is too small.
                        rowToUse = Math.max(rowToUse, row);

                        // If last on list is MergeFalse, then give an extra row of space.
                        if (list[list.length - 1].getName() === 'MergeFalseRenderingIndicator') {
                            rowToUse += 1;
                        }

                        // Associate the back to loop with the last added node indicator.
                        var nodeIndicators = list.filter(function (indicator) {
                            return indicator.getName() === 'NodeRenderingIndicator';
                        });
                        var lastNodeIndicatorAdded = nodeIndicators[nodeIndicators.length - 1];

                        list.push(new BackToLoopRenderingIndicator(node, lastNodeIndicatorAdded.node));

                        // Run the false branch.
                        rowToUse = this.createRenderListRunner(node.getChildNodeForFalse(), rowToUse + 1, column, mergeNodePairs, decisionStack, list);
                        break;
                    }

                // Recursive case: Node is an if-else node.
                case 'IfNode':
                case 'ElseIfNode':
                    {
                        decisionStack.push(node);

                        // Run the true branch.
                        rowToUse = this.createRenderListRunner(node.getChildNodeForTrue(), rowToUse, column + 1, mergeNodePairs, decisionStack, list);

                        // When true branch has no nodes, |rowToUse| is too small.
                        rowToUse = Math.max(rowToUse, row);

                        // Add more space if needed.
                        if (this.isPreviousIndicatorBackToLoopOrMergeFalseWithPreviousofNode(list)) {
                            rowToUse += 1;
                        }

                        // Note: The column value is set later via |moveMergeTrueIndicatorColumnsIntoPosition|.
                        list.push(new MergeTrueRenderingIndicator(rowToUse, column, node));

                        // Run the false branch. Only increment column if false branch isn't elseif-node.
                        var falseBranchNode = node.getChildNodeForFalse();
                        var isFalseBranchElseIfNode = falseBranchNode.getName() === 'ElseIfNode';
                        var columnIncrementer = isFalseBranchElseIfNode ? 0 : 1;

                        rowToUse = this.createRenderListRunner(falseBranchNode, rowToUse + 1, column + columnIncrementer, mergeNodePairs, decisionStack, list);

                        // If last on list is BackToLoop, then give an extra row of space.
                        var wasBackToLoopBeforeMergeFalse = list[list.length - 1].getName() === 'BackToLoopRenderingIndicator';
                        var wasMergeFalseBeforeBackToLoopBeforeMergeFalse = wasBackToLoopBeforeMergeFalse && list[list.length - 2].getName() === 'MergeFalseRenderingIndicator'; // eslint-disable-line no-magic-numbers

                        list.push(new MergeFalseRenderingIndicator(node));

                        decisionStack.pop();

                        /*
                            Recurse on this node's MergeNode if:
                            * The MergeNode isn't already in |list|
                            * The MergeNode isn't a merge node of a node in the decision stack
                        */
                        var mergeNode = mergeNodePairs.find(function (mergeNodePair) {
                            return mergeNodePair.ifElseIfNode === node;
                        }).mergeNode;
                        var isMergeNodeInList = list.some(function (indicator) {
                            return indicator.node === mergeNode;
                        });
                        var isMergeNodeAMergeNodeInDecisionStack = decisionStack.some(function (decisionNode) {
                            return mergeNodePairs.some(function (mergeNodePair) {
                                return mergeNodePair.ifElseIfNode === decisionNode && mergeNodePair.mergeNode === mergeNode;
                            });
                        });

                        if (!isMergeNodeInList && !isMergeNodeAMergeNodeInDecisionStack) {

                            // Be two rows down from the largest row so far.
                            var indicatorRows = list.filter(function (indicator) {
                                return indicator.row;
                            }).map(function (indicator) {
                                return indicator.row;
                            });
                            var largestRow = Math.max.apply(Math, _toConsumableArray(indicatorRows));

                            if (wasBackToLoopBeforeMergeFalse) {
                                largestRow += 1;

                                if (wasMergeFalseBeforeBackToLoopBeforeMergeFalse) {
                                    largestRow += 1;
                                }
                            }

                            rowToUse = this.handleRenderListNode(mergeNode, largestRow + 2, column, mergeNodePairs, decisionStack, list // eslint-disable-line no-magic-numbers
                            );
                        }

                        // Add more space if needed.
                        else if (this.isPreviousIndicatorBackToLoopOrMergeFalseWithPreviousofNode(list)) {
                                rowToUse += 1;
                            }
                        break;
                    }

                // Base case: Node has no children.
                default:
                    break;
            }

            return rowToUse;
        }

        /**
            Return whether last on list is a BackToLoop OR (MergeFalse AND indicator before that is not a node).
            @method isPreviousIndicatorBackToLoopOrMergeFalseWithPreviousofNode
            @param {Array} list {Array} of {RenderingIndicator}. The list of indicators for rendering.
            @return {Boolean} Whether last on list is a BackToLoop OR (MergeFalse AND indicator before that is not a node).
        */

    }, {
        key: 'isPreviousIndicatorBackToLoopOrMergeFalseWithPreviousofNode',
        value: function isPreviousIndicatorBackToLoopOrMergeFalseWithPreviousofNode(list) {
            var previousIndicator = list[list.length - 1].getName();
            var previousIsBackToLoop = previousIndicator === 'BackToLoopRenderingIndicator';
            var previousIsMergeFalse = previousIndicator === 'MergeFalseRenderingIndicator';
            var previousPreviousIndicator = list[list.length - 2].getName(); // eslint-disable-line no-magic-numbers
            var previousPreviousIsNode = previousPreviousIndicator === 'NodeRenderingIndicator';

            return previousIsBackToLoop || previousIsMergeFalse && !previousPreviousIsNode;
        }

        /**
            Each MergeTrue indicator's column should be 1 more than any child of the associated if node.
            MergeTrue indicators are created before the false branch has been explored.
            The false branch may have had more column use than the true branch.
            So, this function makes sure that MergeTrue's column is 1 more than the false branch.
            Further, the function makes a second pass through the flowchart to propagate an if node's MergeTrue indicator's column to nested elseif node's MergeTrue indicator.
            @method moveMergeTrueIndicatorColumnsIntoPosition
            @param {Array} list {Array} of {RenderingIndicator}. The list of indicators for rendering.
            @return {void}
        */

    }, {
        key: 'moveMergeTrueIndicatorColumnsIntoPosition',
        value: function moveMergeTrueIndicatorColumnsIntoPosition(list) {
            var _this80 = this;

            // Maintain a stack of max columns; one for each if and elseif node. Each if and elseif node will push a new max column to the stack.
            var maxColumnsSoFar = [];

            list.forEach(function (indicator) {
                var maxColumnThisLoop = 0;

                switch (indicator.getName()) {

                    // If the node is an if or elseif, then push another max column to the stack.
                    case 'NodeRenderingIndicator':
                        {
                            if (_this80.isNodeIfOrElseIf(indicator.node)) {
                                maxColumnsSoFar.push(0);
                            }

                            maxColumnThisLoop = indicator.column;
                            break;
                        }

                    // MergeFalse indicates an if or elseif has finished. Update the respective MergeTrue's column.
                    case 'MergeFalseRenderingIndicator':
                        {
                            var mergeTrue = list.filter(function (indicator2) {
                                return indicator2.getName() === 'MergeTrueRenderingIndicator';
                            }).find(function (indicator2) {
                                return indicator2.ifElseIfNode === indicator.ifElseIfNode;
                            });

                            var newMaxColumn = maxColumnsSoFar.pop();

                            // If node increases the column by 1, b/c the if branch must be larger than any other column, but elseif does not.
                            if (mergeTrue.ifElseIfNode.getName() === 'IfNode') {
                                newMaxColumn++;
                            }
                            maxColumnThisLoop = mergeTrue.column = newMaxColumn;
                            break;
                        }
                    default:
                        break;
                }

                // Update max columns per if node.
                maxColumnsSoFar.forEach(function (max, index) {
                    maxColumnsSoFar[index] = Math.max(max, maxColumnThisLoop);
                });
            });

            /*
                Maintain a stack of if node columns. Push to stack when at the MergeTrue of an if node; pop when finished in if node.
                Assign the last element on the stack to the MergeTrue for an elseif node.
            */
            var ifNodeColumnStack = [];

            list.forEach(function (indicator) {
                switch (indicator.getName()) {

                    case 'MergeTrueRenderingIndicator':
                        {

                            // The node is an if node, so push the node's column to the stack.
                            if (indicator.ifElseIfNode.getName() === 'IfNode') {
                                ifNodeColumnStack.push(indicator.column);
                            }

                            // MergeTrue on elseif is when to set the indicator's column with the last on the stack.
                            else if (indicator.ifElseIfNode.getName() === 'ElseIfNode') {
                                    indicator.column = ifNodeColumnStack[ifNodeColumnStack.length - 1];
                                }
                            break;
                        }

                    // MergeFalse indicates an if has finished, so pop.
                    case 'MergeFalseRenderingIndicator':
                        {
                            if (indicator.ifElseIfNode.getName() === 'IfNode') {
                                ifNodeColumnStack.pop();
                            }
                            break;
                        }
                    default:
                        break;
                }
            });
        }

        /**
            Return whether the node is either an if or elseif node.
            @method isNodeIfOrElseIf
            @param {FlowchartNode} node The node to check.
            @return {Boolean} Whether the node is either an if or elseif node.
        */

    }, {
        key: 'isNodeIfOrElseIf',
        value: function isNodeIfOrElseIf(node) {
            return ['IfNode', 'ElseIfNode'].indexOf(node.getName()) !== -1;
        }
    }]);

    return RenderingIndicatorFactory;
}();

'use strict';

/* exported Token */

/**
    Model for a token, storing the token's name and value.
    @class Token
*/

var Token =

/**
    @constructor
    @param {String} name The name of the token.
    @param {String} value The value of the token.
    @param {Number} startIndexInTheLine The index of the first letter of the token in the line.
*/
function Token(name, value, startIndexInTheLine) {
    _classCallCheck(this, Token);

    /**
        The name of the token.
        @property name
        @type {String}
    */
    this.name = name;

    /**
        The value of the token.
        @property value
        @type {String}
    */
    this.value = value;

    /**
        The index of the first letter of the token in the line.
        @property startIndexInTheLine
        @type {Number}
    */
    this.startIndexInTheLine = startIndexInTheLine;

    /**
        The index of the last letter of the token in the line.
        @property endIndexInTheLine
        @type {Number}
    */
    this.endIndexInTheLine = startIndexInTheLine + value.length - 1;
};

'use strict';

/* exported TokenType */

/**
    Model for a token type includes the name of the token type and the regular expression to capture that type.
    @class TokenType
*/

var TokenType =

/**
    @constructor
    @param {String} name The name of the token type.
    @param {RegExp} expression The regular expression describing this token type.
*/
function TokenType(name, expression) {
    _classCallCheck(this, TokenType);

    /**
        The name of the token type.
        @property type
        @type {String}
    */
    this.name = name;

    /**
        The regular expression describing this token type.
        @property expression
        @type {RegExp}
    */
    this.expression = expression;
};

'use strict';

/* exported Tokenizer */
/* global TokensOfLine, tokenTypes, Token, TokenType */

/**
    Tokenizer for converting code into tokens.
    @class Tokenizer
*/

var Tokenizer = function () {
    function Tokenizer() {
        _classCallCheck(this, Tokenizer);
    }

    _createClass(Tokenizer, [{
        key: 'tokenize',


        /**
            Convert the given code into a list of tokens.
            @method tokenize
            @param {String} code The code to tokenize.
            @return {Array} of {Array} of {Token} List of tokens for each line.
        */
        value: function tokenize(code) {
            var _this81 = this;

            return code.split(/\r\n|\r|\n/).map(function (line, index) {
                return _this81.tokenizeLine(line, index);
            });
        }

        /**
            Tokenize the given line.
            @method tokenizeLine
            @param {String} line The line to tokenize.
            @param {Integer} lineIndex The index of the given line in the code.
            @return {Array} of {Token} List of tokens for this line.
        */

    }, {
        key: 'tokenizeLine',
        value: function tokenizeLine(line, lineIndex) {
            var lineNumber = lineIndex + 1;
            var tokensThisLine = new TokensOfLine(line, lineNumber);

            // If there is whitespace at the beginning of the line, then tokenize as "indent".
            var indentTokenType = new TokenType('indent', /^\s+/);

            var _attemptToMatchTokenT = this.attemptToMatchTokenToLine(indentTokenType, line, tokensThisLine, line),
                tmpLine = _attemptToMatchTokenT.tmpLine,
                hasAddedToken = _attemptToMatchTokenT.hasAddedToken;

            while (tmpLine.length > 0) {
                for (var index = 0; index < tokenTypes.length; ++index) {

                    // Token type matched the next characters in |tmpLine|.
                    var _attemptToMatchTokenT2 = this.attemptToMatchTokenToLine(tokenTypes[index], tmpLine, tokensThisLine, line);

                    tmpLine = _attemptToMatchTokenT2.tmpLine;
                    hasAddedToken = _attemptToMatchTokenT2.hasAddedToken;
                    if (hasAddedToken) {
                        break;
                    }

                    // No more token types to try.
                    else if (index + 1 === tokenTypes.length) {
                            throw new Error('Unrecognized token near: ' + tmpLine + ' (line ' + lineNumber + ')');
                        }
                }
            }

            return tokensThisLine;
        }

        /**
            Try to match the token type to the line. If a match is found, add the token to the tokens this line.
            @method attemptToMatchTokenToLine
            @param {TokenType} tokenType The token type to attempt to match.
            @param {String} line The line of code on which to attempt to match.
            @param {TokensThisLine} tokensThisLine The tokens so far this line.
            @param {String} fullLine The full line of code on which to attempt to match. Unlike |line|, this is always the full line.
            @return {Object} The updated line and whether a token was added.
        */

    }, {
        key: 'attemptToMatchTokenToLine',
        value: function attemptToMatchTokenToLine(tokenType, line, tokensThisLine, fullLine) {
            var tmpLine = line;
            var match = tmpLine.match(tokenType.expression);
            var hasAddedToken = Boolean(match);

            // Token type matches the next characters in |tmpLine|.
            if (match) {
                var value = match[0];
                var newToken = new Token(tokenType.name, value, fullLine.length - line.length);

                tokensThisLine.push(newToken);

                // Remove matched characters from |tmpLine|.
                tmpLine = tmpLine.slice(match.index + value.length);
            }

            return { tmpLine: tmpLine, hasAddedToken: hasAddedToken };
        }
    }]);

    return Tokenizer;
}();

'use strict';

/* exported TokensOfLine */

/**
    Model of the list of tokens in a line of code.
    @class TokensOfLine
*/

var TokensOfLine = function () {

    /**
        @constructor
        @param {String} line The line of code.
        @param {Number} lineNumber The line number of this line of code.
        @param {Integer} [startIndexOfSegment=null] The first index of the segment of the line to highlight during execution.
        @param {Integer} [endIndexOfSegment=null] The last index of the segment of the line to highlight during execution.
    */
    function TokensOfLine(line, lineNumber) {
        var startIndexOfSegment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var endIndexOfSegment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        _classCallCheck(this, TokensOfLine);

        /**
            The line of code.
            @property line
            @type {String}
        */
        this.line = line;

        /**
            The line number of this line of code.
            @property lineNumber
            @type {Number}
        */
        this.lineNumber = lineNumber;

        /**
            The tokens on this line.
            @property tokens
            @type {Array}
            @default []
        */
        this.tokens = [];

        /**
            The first index of |line| that is related to the particular segment. Ex:
            @property startIndexOfSegment
            @type {Integer}
        */
        this.startIndexOfSegment = startIndexOfSegment || 0;

        /**
            The first index of |line| that is related to the particular segment. Ex:
            @property endIndexOfSegment
            @type {Integer}
        */
        this.endIndexOfSegment = endIndexOfSegment || Math.max(line.length - 1, 0);

        /**
            Whether this token is from a for loop. Ex: The "i < 3" from "for i = 0; i < 3; i = i + 1".
            @property isFromForLoop
            @type {Boolean}
            @default false
        */
        this.isFromForLoop = false;
    }

    /**
        Push given token to list of tokens.
        @method push
        @param {Token} token The token to push.
        @return {void}
    */


    _createClass(TokensOfLine, [{
        key: 'push',
        value: function push() {
            var _tokens;

            (_tokens = this.tokens).push.apply(_tokens, arguments);
        }
    }]);

    return TokensOfLine;
}();

'use strict';

/* exported tokenTypes, arithmeticOperatorExpression, conditionalOperatorExpression */
/* global TokenType */

var arithmeticOperatorExpression = /^[+\-*/%]/;
var conditionalOperatorExpression = /^(>=|<=|>|<|==|!=|not|and|or)/;

var tokenTypes = [new TokenType('comment', /^\/\/.*$/),

// The data types: float, integer, float array, and integer array.
new TokenType('dataType', /^(float\s+array|integer\s+array|float|integer|nothing)(?!\w+)/),

// Arithmetic operators: +, -, *, /
new TokenType('arithmeticOperator', arithmeticOperatorExpression),

// Conditional operators: >, <, >=, <=, ==, !=, &&, and ||.
new TokenType('conditionalOperator', conditionalOperatorExpression),

// Float and integer numbers.
new TokenType('floatNumber', /^\d+\.\d+/), new TokenType('integerNumber', /^\d+/),

// A string may contain an escaped string.
new TokenType('string', /^"[^"\\]*(\\.[^"\\]*)*"/),

// Assortment of miscellaneous tokens.
new TokenType('questionMark', /^\?/), new TokenType('assignment', /^=/), new TokenType('openingParens', /^\(/), new TokenType('closingParens', /^\)/), new TokenType('openingBracket', /^\[/), new TokenType('closingBracket', /^\]/), new TokenType('comma', /^,/), new TokenType('period', /^\./), new TokenType('semicolon', /^\;/), new TokenType('spaces', /^\s+/), new TokenType('word', /^\w+/)];

'use strict';

/* exported MemoryCell */
/* global parserGeneratedVariableName */

/**
    Abstract model of one cell in memory.
    @class MemoryCell
*/

var MemoryCell = function () {

    /**
        @constructor
        @param {String} name The name of the memory cell.
        @param {String} type The data type of the memory cell. Valid values: integer, float, boolean
    */
    function MemoryCell(name, type) {
        _classCallCheck(this, MemoryCell);

        /**
            The name of the memory cell.
            @property name
            @type {String}
        */
        this.name = name;

        /**
            The data type of the memory cell. Valid values: integer, float, boolean
            @property type
            @type {String}
        */
        this.type = type;

        /**
            The value stored in the memory cell.
            @property value
            @type {Number}
            @default 0
        */
        this.value = 0;

        /**
            If this cell is apart of an array, then the array may want to listen to changes. Such as changes to ".size".
            @property arrayListenerCallback
            @type {Function}
            @default null
        */
        this.arrayListenerCallback = null;

        /**
            Whether this memory cell was recently written to. Used to highlight memory cells that were recently written to.
            @property wasWrittenTo
            @type {Boolean}
            @default false
        */
        this.wasWrittenTo = false;
    }

    /**
        Return the class name.
        @method getClassName
        @return {String} The class name.
    */


    _createClass(MemoryCell, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'MemoryCell';
        }

        /**
            Get the value of the memory cell.
            @method getValue
            @return {Number} The value of the memory cell.
        */

    }, {
        key: 'getValue',
        value: function getValue() {
            return this.value;
        }

        /**
            Set a value to the memory cell.
            @method setValue
            @param {Number} value The value to set to the memory cell.
            @return {void}
        */

    }, {
        key: 'setValue',
        value: function setValue(value) {
            var valueToSet = value;

            if (this.type === 'integer' && valueToSet !== '?') {
                valueToSet = Math.trunc(valueToSet);

                if (this.name !== parserGeneratedVariableName) {
                    var maxSigned32BitInteger = 2147483647;
                    var minSigned32BitInteger = -2147483648;
                    var errorMessage = ' of ' + this.name + ' when assigned ' + valueToSet;

                    // Check for overflow.
                    if (valueToSet > maxSigned32BitInteger) {
                        throw new Error('Overflow' + errorMessage);
                    }

                    // Check for underflow.
                    if (valueToSet < minSigned32BitInteger) {
                        throw new Error('Underflow' + errorMessage);
                    }
                }
            }

            // Inform the listening array of the change.
            if (this.arrayListenerCallback) {
                this.arrayListenerCallback(valueToSet);
            }

            this.value = valueToSet;
        }

        /**
            Set a value to the memory cell during execution.
            @method setValueDuringExecution
            @param {Number} value The value to set to the memory cell.
            @return {void}
        */

    }, {
        key: 'setValueDuringExecution',
        value: function setValueDuringExecution(value) {
            this.wasWrittenTo = true;
            this.setValue(value);
        }

        /**
            Clear whether this memory cell was written to.
            @method clearWrittenTo
            @return {void}
        */

    }, {
        key: 'clearWrittenTo',
        value: function clearWrittenTo() {
            this.wasWrittenTo = false;
        }

        /**
            Convert the value to a string. If a float value, then ensure a decimal.
            @method toString
            @return {String} The value as a string.
        */

    }, {
        key: 'toString',
        value: function toString() {
            var asString = this.value.toString();

            // If a float and doesn't have a decimal, then ensure there is one.
            if (this.type === 'float' && asString.indexOf('.') === -1) {
                asString = this.value.toFixed(1);
            }

            return asString;
        }

        /**
            Return a clone of this memory cell.
            @method clone
            @return {MemoryCell} A clone of this memory cell.
        */

    }, {
        key: 'clone',
        value: function clone() {
            var clone = new MemoryCell(this.name, this.type);

            clone.value = this.value;
            clone.arrayListenerCallback = this.arrayListenerCallback;
            clone.wasWrittenTo = this.wasWrittenTo;

            return clone;
        }
    }]);

    return MemoryCell;
}();

'use strict';

/* exported Variable */
/* global isValidIdentifier */

/**
    An abstract model of a variable.
    @class Variable
*/

var Variable = function () {

    /**
        @constructor
    */
    function Variable() {
        _classCallCheck(this, Variable);

        /**
            The name of the variable.
            @property name
            @type {String}
            @default ''
        */
        this.name = '';
    }

    /**
        Set the name of the variable.
        @method setName
        @param {String} name The name of the variable.
        @return {void}
    */


    _createClass(Variable, [{
        key: 'setName',
        value: function setName(name) {

            // Variable name must begin with a letter or underscore, then may be followed by letters, underscores, and/or numbers.
            if (!isValidIdentifier(name)) {
                throw new Error('Invalid variable name');
            }

            this.name = name;
        }

        /**
            Return whether this is an array.
            @method isArray
            @return {Boolean} Whether this is an array.
        */

    }, {
        key: 'isArray',
        value: function isArray() {
            return false;
        }

        /**
            Return the name of this variable class. Inheriting objects must override.
            @method getClassName
            @return {String} The name of this variable class.
        */

    }, {
        key: 'getClassName',
        value: function getClassName() {
            throw new Error('Variable\'s getClassName function should be overridden');
        }

        /**
            Return a clone of this variable. Inheriting objects must override.
            @method clone
            @return {Variable} A clone of this variable.
        */

    }, {
        key: 'clone',
        value: function clone() {
            throw new Error('Variable\'s clone function should be overridden');
        }
    }]);

    return Variable;
}();

'use strict';

/* exported SingleVariable */
/* global MemoryCell, Variable */

/**
    An abstract model of a variable with one memory cell.
    @class SingleVariable
    @extends Variable
*/

var SingleVariable = function (_Variable) {
    _inherits(SingleVariable, _Variable);

    /**
        @constructor
        @param {String} name The name of the variable.
        @param {MemoryCell} type The type of data to store.
    */
    function SingleVariable(name, type) {
        _classCallCheck(this, SingleVariable);

        /**
            The type of memory cell's to store.
            @property memoryCellType
            @type {MemoryCell}
        */
        var _this82 = _possibleConstructorReturn(this, (SingleVariable.__proto__ || Object.getPrototypeOf(SingleVariable)).call(this));

        _this82.cell = new MemoryCell(name, type);

        _this82.setName(name);
        return _this82;
    }

    /**
        Set the name of the variable.
        @method setName
        @param {String} name The name of the array.
        @return {void}
    */


    _createClass(SingleVariable, [{
        key: 'setName',
        value: function setName(name) {
            _get(SingleVariable.prototype.__proto__ || Object.getPrototypeOf(SingleVariable.prototype), 'setName', this).call(this, name);
            this.cell.name = name;
        }

        /**
            Set a value in the variable.
            @method setValue
            @param {Number} value The value to set to the variable's cell.
            @return {void}
        */

    }, {
        key: 'setValue',
        value: function setValue(value) {
            this.cell.setValue(value);
        }

        /**
            Get the value in the variable's cell.
            @method getValue
            @return {Number} The value in the variable's cell.
        */

    }, {
        key: 'getValue',
        value: function getValue() {
            return this.cell.getValue();
        }

        /**
            Get the string value of the memory cell during execution, which must have a write before read.
            @method toString
            @return {String} The string value of the memory cell.
        */

    }, {
        key: 'toString',
        value: function toString() {
            return this.cell.toString();
        }

        /**
            Set a value in the variable during execution.
            @method setValueDuringExecution
            @param {Number} value The value to set to the variable's cell.
            @return {void}
        */

    }, {
        key: 'setValueDuringExecution',
        value: function setValueDuringExecution(value) {
            this.cell.setValueDuringExecution(value);
        }

        /**
            Clear whether the memory cell was written to.
            @method clearWrittenTo
            @return {void}
        */

    }, {
        key: 'clearWrittenTo',
        value: function clearWrittenTo() {
            this.cell.clearWrittenTo();
        }
    }]);

    return SingleVariable;
}(Variable);

'use strict';

/* exported ArrayVariable */
/* global Variable, MemoryCell */

/**
    An abstract model of a variable with an array of memory cells.
    @class ArrayVariable
    @extends Variable
*/

var ArrayVariable = function (_Variable2) {
    _inherits(ArrayVariable, _Variable2);

    /**
        @constructor
        @param {String} name The name of the array.
        @param {Integer} numberOfElements Or {String}. The number of elements in the array. Can be: '?'.
        @param {MemoryCell} type The type of memory cell's to store.
    */
    function ArrayVariable(name, numberOfElements, type) {
        _classCallCheck(this, ArrayVariable);

        /**
            The type of memory cell's to store.
            @property memoryCellType
            @type {MemoryCell}
        */
        var _this83 = _possibleConstructorReturn(this, (ArrayVariable.__proto__ || Object.getPrototypeOf(ArrayVariable)).call(this));

        _this83.type = type;

        /**
            The memory cell storing the size of the array.
            @property sizeCell
            @type {MemoryCell}
        */
        _this83.sizeCell = new MemoryCell('', 'integer');

        /**
            The memory cells in the array.
            @property arrayCells
            @type {Array} of {MemoryCell}
            @default []
        */
        _this83.arrayCells = [];

        _this83.setName(name);
        _this83.sizeCell.setValue(numberOfElements);
        _this83.setNumberOfElements(numberOfElements);

        // The size has a known value, so has been written to.
        if (numberOfElements !== '?') {
            _this83.sizeCell.hasEverBeenWrittenTo = true;
        }

        // Listen to changes on the size cell, so the array can resize if appropriate.
        _this83.sizeCell.arrayListenerCallback = function (newSize) {
            if (_this83.sizeCell.getValue() !== '?') {
                throw new Error('Cannot change size of array that already has a set size');
            }
            _this83.setNumberOfElements(newSize);
        };
        return _this83;
    }

    /**
        Set the number of elements in the array.
        @method setNumberOfElements
        @param {Integer} numberOfElements Or {String}. The number of elements in the array. Can be: '?'.
        @return {void}
    */


    _createClass(ArrayVariable, [{
        key: 'setNumberOfElements',
        value: function setNumberOfElements(numberOfElements) {
            var _this84 = this;

            var numberOfElementsIsAnInteger = Number.isInteger(parseInt(numberOfElements, 10));
            var numberOfElementsIsUnknown = numberOfElements === '?';

            if (!(numberOfElementsIsAnInteger || numberOfElementsIsUnknown)) {
                throw new Error('Array size must be an integer or question mark');
            }

            // Update array of cells.
            var currentNumberOfCells = this.arrayCells.length;
            var newNumberOfCells = numberOfElementsIsUnknown ? 0 : numberOfElements;
            var numberOfCellsToAdd = newNumberOfCells - currentNumberOfCells;

            if (numberOfCellsToAdd > 0) {
                require('utilities').createArrayOfSizeN(numberOfCellsToAdd).forEach(function (value, index) {
                    _this84.arrayCells.push(new MemoryCell(_this84.name + '[' + (currentNumberOfCells + index) + ']', _this84.type));
                });
            } else {
                this.arrayCells.length = 0;
            }
        }

        /**
            Set the name of the array.
            @method setName
            @param {String} name The name of the array.
            @return {void}
        */

    }, {
        key: 'setName',
        value: function setName(name) {
            _get(ArrayVariable.prototype.__proto__ || Object.getPrototypeOf(ArrayVariable.prototype), 'setName', this).call(this, name);

            this.sizeCell.name = name + '.size';

            // Set the memory cell names.
            this.arrayCells.forEach(function (cell, index) {
                cell.name = name + '[' + index + ']';
            });
        }

        /**
            Return the memory cell with the given name.
            @method getMemoryCellByName
            @param {String} name The name of the memory cell to return.
            @return {MemoryCell} The memory cell with the given name.
        */

    }, {
        key: 'getMemoryCellByName',
        value: function getMemoryCellByName(name) {
            return this.sizeCell.name === name ? this.sizeCell : this.arrayCells.find(function (memoryCell) {
                return memoryCell.name === name;
            });
        }

        /**
            Return that this is an array.
            @method isArray
            @return {Boolean} That this is an array.
        */

    }, {
        key: 'isArray',
        value: function isArray() {
            return true;
        }

        /**
            Copy the memory cell values from this array to the other.
            @method copyMemoryCellValuesTo
            @param {ArrayVariable} to The variable to copy to.
            @param {Boolean} [isDuringExecution=false] Whether the copy is done during execution.
            @param {Boolean} [isDuringFunctionCall=false] Whether the copy is done during a function call or an assignment.
            @return {void}
        */

    }, {
        key: 'copyMemoryCellValuesTo',
        value: function copyMemoryCellValuesTo(to) {
            var _this85 = this;

            var isDuringExecution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var isDuringFunctionCall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


            // During execution, also set the size.
            if (isDuringExecution) {
                var arraySizeToSet = this.sizeCell.getValue();
                var arraySizeGettingSet = to.sizeCell.getValue();

                if (arraySizeToSet === '?') {
                    var message = isDuringFunctionCall ? 'An array in a function argument cannot have size of ?.' : 'Array on right-hand side has size of ?. Cannot assign with an array that has a size of ?.';

                    throw new Error(message);
                }

                // If the assigned has size ?, then set size as result's size.
                if (arraySizeGettingSet === '?') {
                    to.sizeCell.setValueDuringExecution(arraySizeToSet);
                } else if (arraySizeGettingSet !== arraySizeToSet) {
                    var messageStart = isDuringFunctionCall ? 'Array in argument list and parameter array' : 'Array on left and array on right-hand side';

                    throw new Error(messageStart + ' have different sizes, but shouldn\'t.');
                }
            }

            to.arrayCells.forEach(function (toCell, index) {
                var fromCell = _this85.arrayCells[index];

                if (isDuringExecution) {
                    toCell.setValueDuringExecution(fromCell.getValue());
                } else {
                    toCell.setValue(fromCell.getValue());
                }
            });
        }

        /**
            Clear whether any memory cell in the array was written to.
            @method clearWrittenTo
            @return {void}
        */

    }, {
        key: 'clearWrittenTo',
        value: function clearWrittenTo() {
            this.sizeCell.clearWrittenTo();
            this.arrayCells.forEach(function (cell) {
                return cell.clearWrittenTo();
            });
        }
    }]);

    return ArrayVariable;
}(Variable);

'use strict';

/* exported BooleanVariable */
/* global SingleVariable */

/**
    Model an boolean cell in memory.
    @class BooleanVariable
    @extends SingleVariable
*/

var BooleanVariable = function (_SingleVariable) {
    _inherits(BooleanVariable, _SingleVariable);

    /**
        @constructor
        @param {String} name The name of the memory cell.
    */
    function BooleanVariable(name) {
        _classCallCheck(this, BooleanVariable);

        return _possibleConstructorReturn(this, (BooleanVariable.__proto__ || Object.getPrototypeOf(BooleanVariable)).call(this, name, 'boolean'));
    }

    /**
        Return the name of this variable class.
        @method getClassName
        @return {String} The name of this variable class.
    */


    _createClass(BooleanVariable, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'BooleanVariable';
        }

        /**
            Return a clone of this variable.
            @method clone
            @return {BooleanVariable} A clone of this variable.
        */

    }, {
        key: 'clone',
        value: function clone() {
            var clone = new BooleanVariable(this.name);

            clone.setValue(this.getValue());

            return clone;
        }
    }]);

    return BooleanVariable;
}(SingleVariable);

'use strict';

/* exported FloatArray */
/* global ArrayVariable */

/**
    Model an array of floats.
    @class FloatArray
    @extends ArrayVariable
*/

var FloatArray = function (_ArrayVariable) {
    _inherits(FloatArray, _ArrayVariable);

    /**
        @constructor
        @param {String} name The name of the array.
        @param {Integer} numberOfElements The number of elements in the array.
    */
    function FloatArray(name, numberOfElements) {
        _classCallCheck(this, FloatArray);

        return _possibleConstructorReturn(this, (FloatArray.__proto__ || Object.getPrototypeOf(FloatArray)).call(this, name, numberOfElements, 'float'));
    }

    /**
        Return the name of this variable class.
        @method getClassName
        @return {String} The name of this variable class.
    */


    _createClass(FloatArray, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'FloatArray';
        }

        /**
            Return a clone of this variable. Inheriting objects must override.
            @method clone
            @return {FloatArray} A clone of this variable.
        */

    }, {
        key: 'clone',
        value: function clone() {
            var clone = new FloatArray(this.name, this.sizeCell.getValue());

            this.copyMemoryCellValuesTo(clone);

            return clone;
        }
    }]);

    return FloatArray;
}(ArrayVariable);

'use strict';

/* exported FloatVariable */
/* global SingleVariable */

/**
    Model a float variable.
    @class FloatVariable
    @extends SingleVariable
*/

var FloatVariable = function (_SingleVariable2) {
    _inherits(FloatVariable, _SingleVariable2);

    /**
        @constructor
        @param {String} name The name of the memory cell.
    */
    function FloatVariable(name) {
        _classCallCheck(this, FloatVariable);

        return _possibleConstructorReturn(this, (FloatVariable.__proto__ || Object.getPrototypeOf(FloatVariable)).call(this, name, 'float'));
    }

    /**
        Return the name of this variable class.
        @method getClassName
        @return {String} The name of this variable class.
    */


    _createClass(FloatVariable, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'FloatVariable';
        }

        /**
            Return a clone of this variable. Inheriting objects must override.
            @method clone
            @return {FloatVariable} A clone of this variable.
        */

    }, {
        key: 'clone',
        value: function clone() {
            var clone = new FloatVariable(this.name);

            clone.setValue(this.getValue());

            return clone;
        }
    }]);

    return FloatVariable;
}(SingleVariable);

'use strict';

/* exported IntegerArray */
/* global ArrayVariable */

/**
    Model an array of integer.
    @class IntegerArray
    @extends ArrayVariable
*/

var IntegerArray = function (_ArrayVariable2) {
    _inherits(IntegerArray, _ArrayVariable2);

    /**
        @constructor
        @param {String} name The name of the array.
        @param {Integer} numberOfElements The number of elements in the array.
    */
    function IntegerArray(name, numberOfElements) {
        _classCallCheck(this, IntegerArray);

        return _possibleConstructorReturn(this, (IntegerArray.__proto__ || Object.getPrototypeOf(IntegerArray)).call(this, name, numberOfElements, 'integer'));
    }

    /**
        Return the name of this variable class.
        @method getClassName
        @return {String} The name of this variable class.
    */


    _createClass(IntegerArray, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'IntegerArray';
        }

        /**
            Return a clone of this variable. Inheriting objects must override.
            @method clone
            @return {IntegerArray} A clone of this variable.
        */

    }, {
        key: 'clone',
        value: function clone() {
            var clone = new IntegerArray(this.name, this.sizeCell.getValue());

            this.copyMemoryCellValuesTo(clone);

            return clone;
        }
    }]);

    return IntegerArray;
}(ArrayVariable);

'use strict';

/* exported IntegerVariable */
/* global SingleVariable */

/**
    Model an integer cell in memory.
    @class IntegerVariable
    @extends SingleVariable
*/

var IntegerVariable = function (_SingleVariable3) {
    _inherits(IntegerVariable, _SingleVariable3);

    /**
        @constructor
        @param {String} name The name of the memory cell.
    */
    function IntegerVariable(name) {
        _classCallCheck(this, IntegerVariable);

        return _possibleConstructorReturn(this, (IntegerVariable.__proto__ || Object.getPrototypeOf(IntegerVariable)).call(this, name, 'integer'));
    }

    /**
        Return the name of this variable class.
        @method getClassName
        @return {String} The name of this variable class.
    */


    _createClass(IntegerVariable, [{
        key: 'getClassName',
        value: function getClassName() {
            return 'IntegerVariable';
        }

        /**
            Return a clone of this variable. Inheriting objects must override.
            @method clone
            @return {IntegerVariable} A clone of this variable.
        */

    }, {
        key: 'clone',
        value: function clone() {
            var clone = new IntegerVariable(this.name);

            clone.setValue(this.getValue());

            return clone;
        }
    }]);

    return IntegerVariable;
}(SingleVariable);

'use strict';

/* exported Variables */

/**
    Model of a list of {Variable}s.
    @class Variables
    @extends Array
*/

var Variables = function (_Array) {
    _inherits(Variables, _Array);

    /**
        @constructor
        @param {String} name The name of the variables.
    */
    function Variables(name) {
        _classCallCheck(this, Variables);

        /**
            The name of the variables.
            @property name
            @type {String}
        */
        var _this91 = _possibleConstructorReturn(this, (Variables.__proto__ || Object.getPrototypeOf(Variables)).call(this));

        _this91.name = name;

        /**
            TODO: Investigate babel update to fix prototypical inheritance https://stackoverflow.com/questions/40325212/how-can-i-extend-the-array-class-in-babel
            Return the {MemoryCell} associated with the given name.
            @method getMemoryCell
            @param {String} _name The name of the memory cell to get.
            @return {MemoryCell} Memory cell associated with the given name.
        */
        _this91.getMemoryCell = function (_name) {
            var memoryCellToFind = null;

            _this91.forEach(function (variable) {

                // Not an array, so check the variable directly.
                if (['IntegerArray', 'FloatArray'].indexOf(variable.getClassName()) === -1) {
                    if (variable.name === _name) {
                        memoryCellToFind = variable.cell;
                    }
                } else {
                    memoryCellToFind = variable.getMemoryCellByName(_name) || memoryCellToFind;
                }
            });

            return memoryCellToFind;
        };

        /**
            Return the variable with the given name.
            @method getVariable
            @param {String} _name The name of the variable to get.
            @return {Variable} The variable with the given name.
        */
        _this91.getVariable = function (_name) {
            return _this91.find(function (variable) {
                return variable.name === _name;
            });
        };

        /**
            Return the list of variable names.
            @method getVariableNames
            @return {Array} of {String} List of variable names.
        */
        _this91.getVariableNames = function () {
            return _this91.map(function (variable) {
                return variable.name;
            });
        };

        /**
            Return a clone of these variables.
            @method clone
            @return {Variables} A clone of these variables.
        */
        _this91.clone = function () {
            var cloned = new Variables(_this91.name);

            _this91.forEach(function (variable) {
                return cloned.push(variable.clone());
            });

            return cloned;
        };

        /**
            Clear whether the variables were written to.
            @method clearWrittenTo
            @return {void}
        */
        _this91.clearWrittenTo = function () {
            _this91.forEach(function (variable) {
                return variable.clearWrittenTo();
            });
        };
        return _this91;
    }

    return Variables;
}(Array);

'use strict';

/* exported MemoryCellRender */

/**
    Abstract model for rendering a memory cell.
    @class MemoryCellRender
*/

var MemoryCellRender =

/**
    @constructor
    @param {MemoryCell} memoryCell The memory cell to render.
    @param {Boolean} isArray Whether this memory cell is part of an array.
*/
function MemoryCellRender(memoryCell, isArray) {
    _classCallCheck(this, MemoryCellRender);

    /**
        The name of the memory cell.
        @property name
        @type {String}
    */
    this.name = memoryCell.name;

    /**
        The value of the memory cell.
        @property value
        @type {String}
    */
    this.value = memoryCell.toString();

    /**
        Whether this memory cell is part of an array.
        @property isArray
        @type {Boolean}
    */
    this.isArray = isArray;

    /**
        Whether the memory cell was written to.
        @property wasWrittenTo
        @type {Boolean}
    */
    this.wasWrittenTo = memoryCell.wasWrittenTo;
};

'use strict';

/* exported ArrayElementRender */
/* global MemoryCellRender */

/**
    Model for rendering an array element.
    @class ArrayElementRender
    @extends MemoryCellRender
*/

var ArrayElementRender = function (_MemoryCellRender) {
    _inherits(ArrayElementRender, _MemoryCellRender);

    /**
        @constructor
        @param {MemoryCell} memoryCell The memory cell to render.
        @param {String} arrayName The name of the array.
        @param {Boolean} [isFirstOfArray=false] Whether this is the first element in the array.
    */
    function ArrayElementRender(memoryCell, arrayName) {
        var isFirstOfArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _classCallCheck(this, ArrayElementRender);

        /**
            Whether this is the first element in the array.
            @property isFirstOfArray
            @type {Boolean}
        */
        var _this92 = _possibleConstructorReturn(this, (ArrayElementRender.__proto__ || Object.getPrototypeOf(ArrayElementRender)).call(this, memoryCell, true));

        _this92.isFirstOfArray = isFirstOfArray;

        // Remove the array variable's name from the cell's name for printing.
        _this92.name = _this92.name.substring(arrayName.length);
        return _this92;
    }

    return ArrayElementRender;
}(MemoryCellRender);

'use strict';

/* exported ArraySizeComment */

/**
    Model for rendering a comment about an array's size.
    @class ArraySizeComment
*/

var ArraySizeComment =

/**
    @constructor
    @param {String} comment The comment on an array's size.
*/
function ArraySizeComment(comment) {
    _classCallCheck(this, ArraySizeComment);

    /**
        Whether this is an array's size comment. It is.
        @property isArraySizeComment
        @type {Boolean}
        @default true
    */
    this.isArraySizeComment = true;

    /**
        The comment on an array's size.
        @property value
        @type {String}
    */
    this.comment = comment;
};

'use strict';

/* exported ArraySizeRender */
/* global ArrayElementRender */

/**
    Model for rendering the array's size.
    @class ArraySizeRender
    @extends ArrayElementRender
*/

var ArraySizeRender = function (_ArrayElementRender) {
    _inherits(ArraySizeRender, _ArrayElementRender);

    /**
        @constructor
        @param {ArrayVariable} array The array of which this memory cell is the first property to be printed.
    */
    function ArraySizeRender(array) {
        _classCallCheck(this, ArraySizeRender);

        /**
            The name of the array.
            @property arrayName
            @type {String}
        */
        var _this93 = _possibleConstructorReturn(this, (ArraySizeRender.__proto__ || Object.getPrototypeOf(ArraySizeRender)).call(this, array.sizeCell, array.name, true));

        _this93.arrayName = array.name;

        /**
            The data type of the array.
            @property type
            @type {String}
        */
        _this93.type = array.type;

        /**
            The number of elements in the array.
            @property numberOfElements
            @type {Integer}
        */
        _this93.numberOfElements = Math.max(2, array.arrayCells.length + 1); // eslint-disable-line no-magic-numbers
        return _this93;
    }

    return ArraySizeRender;
}(ArrayElementRender);

'use strict';

/* exported SingleMemoryCellVariableRender */
/* global MemoryCellRender */

/**
    Model for rendering a single memory cell variable.
    @class SingleMemoryCellVariableRender
    @extends MemoryCellRender
*/

var SingleMemoryCellVariableRender = function (_MemoryCellRender2) {
    _inherits(SingleMemoryCellVariableRender, _MemoryCellRender2);

    /**
        @constructor
        @param {MemoryCell} memoryCell The memory cell to render.
    */
    function SingleMemoryCellVariableRender(memoryCell) {
        _classCallCheck(this, SingleMemoryCellVariableRender);

        /**
            The data type of the memory cell.
            @property type
            @type {String}
        */
        var _this94 = _possibleConstructorReturn(this, (SingleMemoryCellVariableRender.__proto__ || Object.getPrototypeOf(SingleMemoryCellVariableRender)).call(this, memoryCell, false));

        _this94.type = memoryCell.type;
        return _this94;
    }

    return SingleMemoryCellVariableRender;
}(MemoryCellRender);

'use strict';

/* exported builtInFunctions, builtInFunctionNames */
/* global BuiltInProgramFunction, Variables, FloatVariable, Flowchart, StartNode, EndNode, IntegerVariable */

// Dummy flowchart cloned by the built-in functions below.
var startNode = new StartNode();
var endNode = new EndNode();

startNode.setChildNode(endNode);

var flowchart = new Flowchart(startNode);

// Function RaiseToPower accepts two float variables (x and y) and returns one float variable (z).
var raiseToPowerParameters = new Variables('Parameters');
var raiseToPowerReturn = new Variables('Return');

raiseToPowerParameters.push(new FloatVariable('x'), new FloatVariable('y'));
raiseToPowerReturn.push(new FloatVariable('z'));

var raiseToPowerBuiltInFunction = new BuiltInProgramFunction('RaiseToPower', flowchart.clone(), new Variables('Locals'), raiseToPowerParameters, raiseToPowerReturn, function (parameters, returnVariables) {
    var first = parameters.getMemoryCell('x').getValue();
    var second = parameters.getMemoryCell('y').getValue();
    var result = Math.pow(first, second);

    returnVariables.getMemoryCell('z').setValue(result);
});

// Function SquareRoot accepts one float variable (x) and returns one float variable (y).
var squareRootParameters = new Variables('Parameters');
var squareRootReturn = new Variables('Return');

squareRootParameters.push(new FloatVariable('x'));
squareRootReturn.push(new FloatVariable('y'));

var squareRootBuiltInFunction = new BuiltInProgramFunction('SquareRoot', flowchart.clone(), new Variables('Locals'), squareRootParameters, squareRootReturn, function (parameters, returnVariables) {
    var result = Math.sqrt(parameters.getMemoryCell('x').getValue());

    returnVariables.getMemoryCell('y').setValue(result);
});

// Function RandomNumber accepts two integer variables (x and y) and returns one integer variable (z).
var randomNumberParameters = new Variables('Parameters');
var randomNumberReturn = new Variables('Return');

randomNumberParameters.push(new IntegerVariable('x'), new IntegerVariable('y'));
randomNumberReturn.push(new IntegerVariable('z'));

var randomNumberBuiltInFunction = new BuiltInProgramFunction('RandomNumber', flowchart.clone(), new Variables('Locals'), randomNumberParameters, randomNumberReturn, function (parameters, returnVariables, context) {
    var randomNumber = context.randomizer.getNumber();
    var xValue = parameters.getMemoryCell('x').getValue();
    var divisor = parameters.getMemoryCell('y').getValue() - xValue + 1;

    if (divisor <= 0) {
        throw new Error('RandomNumber cannot have second parameter smaller than first parameter');
    }

    var result = randomNumber % divisor + xValue;

    returnVariables.getMemoryCell('z').setValue(result);
});

// Function SeedRandomNumbers accepts one integer variable and returns nothing.
var seedRandomNumbersParameters = new Variables('Parameters');

seedRandomNumbersParameters.push(new IntegerVariable('x'));

var seedRandomNumbersBuiltInFunction = new BuiltInProgramFunction('SeedRandomNumbers', flowchart.clone(), new Variables('Locals'), seedRandomNumbersParameters, new Variables('Return'), function (parameters, returnVariables, context) {
    context.randomizer.setSeed(parameters.getMemoryCell('x').getValue());
});

// Function AbsoluteValue accepts a float variable and returns a float variable.
var absoluteValueParameters = new Variables('Parameters');
var absoluteValueReturn = new Variables('Return');

absoluteValueParameters.push(new FloatVariable('x'));
absoluteValueReturn.push(new FloatVariable('y'));

var absoluteValueBuiltInFunction = new BuiltInProgramFunction('AbsoluteValue', flowchart.clone(), new Variables('Locals'), absoluteValueParameters, absoluteValueReturn, function (parameters, returnVariables) {
    var absoluteValue = Math.abs(parameters.getMemoryCell('x').getValue());

    returnVariables.getMemoryCell('y').setValue(absoluteValue);
});

var builtInFunctions = [raiseToPowerBuiltInFunction, squareRootBuiltInFunction, randomNumberBuiltInFunction, seedRandomNumbersBuiltInFunction, absoluteValueBuiltInFunction];

var builtInFunctionNames = builtInFunctions.map(function (builtInFunction) {
    return builtInFunction.name;
});

'use strict';

/* exported globalConstants */

var globalConstants = {
    spaceBetweenColumns: 23,
    spaceBetweenRows: 15,

    // Gets set by zyFlowchartSDK's constructor.
    templates: null
};

'use strict';

/* exported evaluateAbstractSyntaxTree */
/* global FloatVariable, IntegerVariable, BooleanVariable, lookupMemoryCellFromVariableLists */

var evaluatorGeneratedVariableName = 'evaluatorGeneratedVariable';

/**
    Return whether the given variable is an IntegerVariable, or MemoryCell of type 'integer'.
    @method isIntegerVariable
    @param {Variable} variable The variable to check.
    @return {Boolean} Whether the variable is an integer.
*/
function isIntegerVariable(variable) {
    return variable.getClassName() === 'IntegerVariable' || variable.getClassName() === 'MemoryCell' && variable.type === 'integer';
}

/**
    Make a variable for the result of an arithmetic operation on |first| and |second|.
    @method makeArithmeticVariable
    @param {Variable} first The first parameter.
    @param {Variable} second The second parameter.
    @return {Variable} The variable type that is the data type of the operation.
*/
function makeArithmeticVariable(first, second) {
    var variable = new FloatVariable(evaluatorGeneratedVariableName);

    // If both variables are integer, then the result is integer. Otherwise, the result is a float.
    if (isIntegerVariable(first) && isIntegerVariable(second)) {
        variable = new IntegerVariable(evaluatorGeneratedVariableName);
    }

    return variable;
}

/**
    Make a result for the calculation "first O second", where "first" is the first parameter, "O" is the operator and "second" is the second parameter.
    @method makeBinaryOperatorResult
    @param {TreeSymbol} symbol The root symbol from which to evaluate.
    @param {ExecutionContext} context The relevant flowchart properties for execution.
    @return {Variable} The result of the binary operation.
*/
function makeBinaryOperatorResult(symbol, context) {
    // eslint-disable-line complexity
    var arrayOfVariables = context.arrayOfVariables;
    var result = null;
    var first = null;
    var second = null;

    // AND and OR will short circuit the evaluation. Ex: For AND, if the first child is false, then the second child will not be evaluated.
    if (['and', 'or'].indexOf(symbol.operator) === -1) {
        first = evaluateAbstractSyntaxTree(symbol.children[0], context); // eslint-disable-line no-use-before-define
        second = evaluateAbstractSyntaxTree(symbol.children[1], context); // eslint-disable-line no-use-before-define
    }

    switch (symbol.operator) {
        case '+':
            result = makeArithmeticVariable(first, second);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) + second.getValue(arrayOfVariables));
            break;
        case '-':
            result = makeArithmeticVariable(first, second);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) - second.getValue(arrayOfVariables));
            break;
        case '*':
            result = makeArithmeticVariable(first, second);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) * second.getValue(arrayOfVariables));
            break;
        case '/':
            result = makeArithmeticVariable(first, second);

            // Catch divide by 0 error for integers.
            if (result.getClassName() === 'IntegerVariable' && second.getValue() === 0) {
                throw new Error('Cannot divide by zero with integer division');
            }

            result.setValueDuringExecution(first.getValue(arrayOfVariables) / second.getValue(arrayOfVariables));
            break;
        case '%':
            result = makeArithmeticVariable(first, second);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) % second.getValue(arrayOfVariables));
            break;
        case '>':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) > second.getValue(arrayOfVariables));
            break;
        case '<':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) < second.getValue(arrayOfVariables));
            break;
        case '>=':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) >= second.getValue(arrayOfVariables));
            break;
        case '<=':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) <= second.getValue(arrayOfVariables));
            break;
        case '==':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) === second.getValue(arrayOfVariables));
            break;
        case '!=':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(first.getValue(arrayOfVariables) !== second.getValue(arrayOfVariables));
            break;

        // Use short circuit evaluation. If first child is false, then don't execute second child.
        case 'and':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(evaluateAbstractSyntaxTree(symbol.children[0], context).getValue(arrayOfVariables) && // eslint-disable-line no-use-before-define
            evaluateAbstractSyntaxTree(symbol.children[1], context).getValue(arrayOfVariables) // eslint-disable-line no-use-before-define
            );
            break;

        // Use short circuit evaluation. If first child is true, then don't execute second child.
        case 'or':
            result = new BooleanVariable(evaluatorGeneratedVariableName);
            result.setValueDuringExecution(evaluateAbstractSyntaxTree(symbol.children[0], context).getValue(arrayOfVariables) || // eslint-disable-line no-use-before-define
            evaluateAbstractSyntaxTree(symbol.children[1], context).getValue(arrayOfVariables) // eslint-disable-line no-use-before-define
            );
            break;
        default:
            throw new Error('Unrecognized binary operator ' + symbol.operator);
    }

    return result;
}

/**
    Make a result of a unary operation. Ex: -100 or !x
    @method makeUnaryOperatorResult
    @param {String} operator The operator to make a result for.
    @param {Variable} child The child of the operator.
    @param {Array} arrayOfVariables Array of {Variables}. List of variables in the current function.
    @return {Variable} The result of the unary operation.
*/
function makeUnaryOperatorResult(operator, child, arrayOfVariables) {
    var result = child.clone();

    result.name = evaluatorGeneratedVariableName;

    switch (operator) {
        case '+':

            // Do nothing.
            break;
        case '-':
            result.setValueDuringExecution(-child.getValue(arrayOfVariables));
            break;
        case 'not':
            result.setValueDuringExecution(!child.getValue(arrayOfVariables));
            break;
        default:
            throw new Error('Unrecognized unary operator ' + operator);
    }

    return result;
}

/**
    Evaluate the given abstract syntax tree.
    @method evaluateAbstractSyntaxTree
    @param {TreeSymbol} symbol The current symbol in the tree to evaluate.
    @param {ExecutionContext} context The relevant flowchart properties for execution.
    @return {Variable} The result of the abstract syntax tree.
*/
function evaluateAbstractSyntaxTree(symbol, context) {
    var result = null;

    switch (symbol.getClassName()) {
        case 'VariableSymbol':
            result = symbol.variable;
            break;
        case 'MemoryCellSymbol':
            result = symbol.memoryCell;
            break;

        // These are only the built-in functions. User-defined functions are handled by the Executor.
        case 'FunctionCallSymbol':
            {
                var argumentList = symbol.children.map(function (child) {
                    return evaluateAbstractSyntaxTree(child, context);
                });

                // Copy arguments to parameters.
                symbol.function.parameters.forEach(function (parameter, index) {
                    var argument = argumentList[index];

                    parameter.setValueDuringExecution(argument.getValue(context.arrayOfVariables));
                });

                // Execute the built-in function.
                symbol.function.execute(context);

                // Store the return value to result.
                if (symbol.function.return.length) {
                    result = symbol.function.return[0].clone();
                    result.name = evaluatorGeneratedVariableName;
                }
                break;
            }
        case 'BinaryOperatorSymbol':
            {
                result = makeBinaryOperatorResult(symbol, context);
                break;
            }
        case 'UnaryOperatorSymbol':
            {
                var child = evaluateAbstractSyntaxTree(symbol.children[0], context);

                result = makeUnaryOperatorResult(symbol.operator, child, context.arrayOfVariables);
                break;
            }
        case 'SubscriptOperatorSymbol':
            {
                var array = symbol.children[0].variable;
                var arrayIndex = evaluateAbstractSyntaxTree(symbol.children[1], context).getValue(context.arrayOfVariables);
                var maxIndexAllowed = array.arrayCells.length - 1;

                // Verify no out-of-bounds array access.
                var smallOrLarge = '';

                if (arrayIndex < 0) {
                    smallOrLarge = 'small';
                } else if (arrayIndex > maxIndexAllowed) {
                    smallOrLarge = 'large';
                }

                if (smallOrLarge) {
                    throw new Error('An array index of ' + arrayIndex + ' is too ' + smallOrLarge + '; valid range of ' + array.name + ': 0 - ' + maxIndexAllowed);
                }

                result = lookupMemoryCellFromVariableLists(array.name + '[' + arrayIndex + ']', context.arrayOfVariables);
                break;
            }
        default:
            throw new Error('Unsupported tree symbol. Please report this error to a developer.');
    }

    return result;
}

'use strict';

/* exported renderSuiteOfVariablesForTesting, renderSuiteOfFlowchartsForTesting */
/* global FlowchartController, VariablesController, IntegerArray, IntegerVariable, FloatVariable, Variables, FloatArray,
          TextualCodeParser */

/**
    Render a suite of variables for testing.
    @method renderSuiteOfVariablesForTesting
    @param {String} id The unique identifier given to this module.
    @return {void}
*/
function renderSuiteOfVariablesForTesting(id) {
    var variablesToRender = [];

    // Integer, integer, float
    {
        var variables = new Variables('Variables');

        variables.push(new IntegerVariable('x'), new IntegerVariable('y'), new FloatVariable('average'));
        variablesToRender.push(variables);
    }

    // Integer array, integer, integer, float
    {
        var _variables = new Variables('Variables');

        _variables.push(new IntegerArray('userWeights', 3), // eslint-disable-line no-magic-numbers
        new IntegerVariable('x'), new IntegerVariable('y'), new FloatVariable('average'));
        variablesToRender.push(_variables);
    }

    // Integer array with 0 elements and float array with unknown elements
    {
        var _variables2 = new Variables('Variables');

        _variables2.push(new IntegerArray('userWeights', 0), new FloatArray('userPercents', '?'));
        variablesToRender.push(_variables2);
    }

    variablesToRender.forEach(function (variables) {
        $('#' + id).append('<div></div>');

        var variablesController = new VariablesController(variables, $('#' + id + ' div:last'));

        variablesController.render();
    });
}

/**
    Render a suite of flowcharts.
    @method renderSuiteOfFlowchartsForTesting
    @param {String} id The unique identifier given to this module.
    @return {void}
*/
function renderSuiteOfFlowchartsForTesting(id) {
    var parser = new TextualCodeParser();
    var codes = ['if 1==1\n   Put "a" to output\nelse\n   while 2==2\n      Put "b" to output\n      while 3==3\n         Put "c" to output\n         Put "d" to output', 'if 1==1\n   Put "a" to output\nelse\n   while 2==2\n      Put "b" to output\n      Put "c" to output', 'if 1==1\n   Put "a" to output\nelse\n   while 2==2\n      Put "b" to output\n      if 3==3\n         Put "c" to output', 'while 1<1\n   if 2<2\n      Put "a" to output\nPut "b" to output', 'while 1 < 1\n   if 2 < 2\n      if 3 < 3\n         Put "a" to output', 'integer x\ninteger y\nif x < 1\n   x = 0\nelseif x > 1\n   x = 2\n   y = 3\nelse\n   while y > 3\n      x = 1', 'if 1==1\n   Put "a" to output\nelse\n   if 2==2\n      Put "b" to output\n   Put "c" to output', 'integer x\nif x < 1\n   Put "a" to output\nelseif x > 1\n   Put "b" to output', 'if 1==1\n   Put "a" to output\nif 2==2\n   Put "b" to output', 'integer x\ninteger y\nwhile x > 1\n   if y > 4\n      x = x + 1\n   else\n      x = x + 2', 'integer x\nif x > 1\n   while x > 2\n      x = x + 1\nelse\n   while x > 3\n      x = x + 1', 'integer x\nif x > 1\n   if x > 2\n      Put "a" to output\n   else\n      Put "b" to output\nelse\n   if x < 3\n      Put "c" to output\n   else\n      Put "d" to output', 'if 1 > 1\n   if 2 > 2\n      Put "a" to output\n   else\n      while 3 > 3\n         Put "b" to output', 'integer x\ninteger y\nif x > 5\n   y = 1\nelse\n   y = 2', 'integer x\nif x > 5\n   Put "a" to output\nelse\n   Put "b" to output', 'integer x\ninteger y\nwhile x < 5\n   while y < 4\n      Put "a" to output', 'integer x\nwhile x < 5\n   x = x + 1', 'integer x\nPut "a" to output\nx = Get next input\nPut x to output', 'integer x\ninteger a\ninteger y\ninteger z\nx = 5\na = 4 + (y * y) + (x * x) + (z * z)'];

    codes.forEach(function (code) {
        $('#' + id).append('<div></div>');

        var program = parser.parse(code);
        var flowchartController = new FlowchartController(program.functions[0].flowchart, $('#' + id + ' div:last'));

        flowchartController.render();
    });
}

'use strict';

/* exported isValidIdentifier, lookupMemoryCellFromVariableLists, isGivenSymbolInAbstractSyntaxTree,
            findNonBuiltInFunctionCalls, makeRandomInteger, makeSuggestionForInvalidWordFromSimilarWords, makeSuggestionForInvalidDataType,
            combineWordsIntoSuggestion */

var reservedWords = ['Get', 'Put', 'to', 'output', 'from', 'input', 'or', 'and', 'not', 'returns', 'Function', 'while', 'if', 'else', 'for', 'elseif', 'float', 'integer', 'array', 'nothing'];

// Map words in other languages to Coral words with same meaning.
var similarDataTypesInOtherLanguages = {
    int: 'integer',
    double: 'float',
    void: 'nothing'
};
var similarWordsInOtherLanguage = Object.assign({}, similarDataTypesInOtherLanguages, {
    print: 'Put',
    cout: 'Put',
    printf: 'Put',
    println: 'Put',
    def: 'Function',
    function: 'Function',
    return: 'returns'
});

/**
   Returns the distance between the two strings based on a Levenschtein table.
   @method distanceBetweenStrings
   @param {String} alpha First string.
   @param {String} beta  Second String.
   @return {Integer} The distance between the two strings based on a Levenschtein table.
*/
function distanceBetweenStrings(alpha, beta) {
    if (alpha.length === 0) {
        return beta.length;
    }
    if (beta.length === 0) {
        return alpha.length;
    }

    var matrix = [];

    // Increment along the first column of each row.
    for (var i = 0; i <= beta.length; i++) {
        // eslint-disable-line id-length
        matrix[i] = [i];
    }

    // Increment each column in the first row.
    for (var j = 0; j <= alpha.length; j++) {
        // eslint-disable-line id-length
        matrix[0][j] = j;
    }

    var SUBSTITUTION_COST = 1;
    var INSERTION_COST = 1;
    var DELETION_COST = 1;

    // Fill in the rest of the matrix.
    for (var _i = 1; _i <= beta.length; _i++) {
        // eslint-disable-line id-length
        for (var _j = 1; _j <= alpha.length; _j++) {
            // eslint-disable-line id-length
            if (beta.charAt(_i - 1) === alpha.charAt(_j - 1)) {
                matrix[_i][_j] = matrix[_i - 1][_j - 1];
            } else {
                matrix[_i][_j] = Math.min(matrix[_i - 1][_j - 1] + SUBSTITUTION_COST, Math.min(matrix[_i][_j - 1] + INSERTION_COST, matrix[_i - 1][_j] + DELETION_COST));
            }
        }
    }

    // Return the distance.
    return matrix[matrix.length - 1][matrix[0].length - 1];
}

/**
    Combine suggested words into a string suggestion.
    @method combineWordsIntoSuggestion
    @param {Array} suggestedWords Array of {String}.
    @param {String} [actualWord=null] The actual word. If supplied, check if only off by case.
    @return {String} Suggestion of words to use.
*/
function combineWordsIntoSuggestion(suggestedWords) {
    var actualWord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;


    // Combine the similar words into a list.
    var wordsJoined = '';

    if (suggestedWords.length) {
        var wordsWithQuotes = suggestedWords.map(function (similarWord) {
            return '\'' + similarWord + '\'';
        });
        var wordsListed = wordsWithQuotes.join(', ');
        var commaOrNot = wordsWithQuotes.length > 1 ? ',' : '';

        wordsJoined = '' + wordsListed + commaOrNot + ' or something different';
    }

    var wordsJoinMessage = wordsJoined ? 'Maybe you meant ' + wordsJoined + '?' : '';

    // If there is only 1 suggested word and that word is different by capitalization only, then remind that case matters.
    var caseDifferenceMessage = '\nNote: Capitalization matters';
    var useCaseDifferenceMessage = actualWord && suggestedWords.length === 1 && suggestedWords[0].toUpperCase() === actualWord.toUpperCase();

    return '' + wordsJoinMessage + (useCaseDifferenceMessage ? caseDifferenceMessage : '');
}

/**
    Return a suggestion for the given word from a list of candidates.
    @method makeSuggestionFromWordAndCandidates
    @param {String} word The word to compare to.
    @param {Array} candidates Array of {String}. The candidate words.
    @param {Object} otherProgrammingLanguageWords Dictionary of words from other languages that map to Coral words.
    @return {String} The suggestion.
*/
function makeSuggestionFromWordAndCandidates(word, candidates, otherProgrammingLanguageWords) {
    var distances = candidates.map(function (candidateWord) {
        return distanceBetweenStrings(word, candidateWord);
    });
    var shortestDistance = Math.min.apply(Math, _toConsumableArray(distances));
    var suggestDistance = Math.min(5, Math.floor(word.length / 2)); // eslint-disable-line no-magic-numbers
    var similarWordsSet = new Set();

    // A similar word was found.
    if (shortestDistance > 0 && shortestDistance <= suggestDistance) {

        // Find the indices that share the |shortestDistance|.
        var indexOfShortestDistances = distances.reduce(function (array, distance, index) {
            var newArray = array;

            if (distance === shortestDistance) {
                newArray = array.concat(index);
            }

            return newArray;
        }, []);

        var similarWordsList = indexOfShortestDistances.map(function (indexOfShortestDistance) {
            return candidates[indexOfShortestDistance];
        });

        similarWordsList.forEach(function (similarWord) {
            return similarWordsSet.add(similarWord);
        });
    }

    // Add words with similar meanings in other programming languages.
    if (word in otherProgrammingLanguageWords) {
        similarWordsSet.add(otherProgrammingLanguageWords[word]);
    }

    return combineWordsIntoSuggestion(Array.from(similarWordsSet).sort(), word);
}

/**
    Return similar words to the given word from the reserved words, variable names, and function names.
    @method makeSuggestionForInvalidWordFromSimilarWords
    @param {String} word The word to compare to.
    @param {Array} arrayOfVariables Array of {Variables}. The variables in this expression's function.
    @param {Array} functions Array of {ProgramFunction}. The functions in this expression's program.
    @return {String} The suggestion.
*/
function makeSuggestionForInvalidWordFromSimilarWords(word, arrayOfVariables, functions) {
    var variableNames = arrayOfVariables[0].concat(arrayOfVariables[1]).concat(arrayOfVariables[2]).map(function (variable) {
        return variable.name;
    });
    var functionNames = functions.map(function (programFunction) {
        return programFunction.name;
    });
    var candidateWords = reservedWords.concat(functionNames).concat(variableNames);

    return makeSuggestionFromWordAndCandidates(word, candidateWords, similarWordsInOtherLanguage);
}

/**
    Return similar data types to the given data type.
    @method makeSuggestionForDataType
    @param {String} dataType The data type from which to make a suggestion.
    @return {String} The suggestion.
*/
function makeSuggestionForInvalidDataType(dataType) {
    var candidateDataTypes = ['integer', 'float', 'integer array', 'float array'];

    return makeSuggestionFromWordAndCandidates(dataType, candidateDataTypes, similarDataTypesInOtherLanguages);
}

/**
    Return whether the given identifier is valid.
    Valid identifier cannot be a reserved word.
    Valid idenitifier must start with a letter or underscore, then may be followed by letters, underscores, or numbers.
    @method isValidIdentifier
    @param {String} identifier The identifier to check.
    @return {Boolean} Whether the given identifier is valid.
*/
function isValidIdentifier(identifier) {
    return !(reservedWords || []).includes(identifier) && /^[a-z,A-Z]\w*$/.test(identifier);
}

/**
    Given a variable name and the list of variables, find the associated memory cell.
    @method lookupMemoryCellFromVariableLists
    @param {String} variableName The name of the variable to find.
    @param {Array} arrayOfVariables Array of {Variables}. List of variables to search.
    @return {MemoryCell} The memory cell with the given variable name.
*/
function lookupMemoryCellFromVariableLists(variableName, arrayOfVariables) {
    return arrayOfVariables.map(function (variables) {
        return variables.getMemoryCell(variableName);
    }).find(function (memoryCell) {
        return memoryCell;
    });
}

/**
    Recursively find the non-builtin function calls in the tree, in post-fix order.
    @method findNonBuiltInFunctionCalls
    @param {TreeSymbol} symbol The currently traversed symbol.
    @param {Array} nonBuiltInFunctionCalls Array of {FunctionCallSymbol}. The non-builtin function calls.
    @return {void}
*/
function findNonBuiltInFunctionCalls(symbol, nonBuiltInFunctionCalls) {
    symbol.children.forEach(function (child) {
        return findNonBuiltInFunctionCalls(child, nonBuiltInFunctionCalls);
    });

    if (symbol.getClassName() === 'FunctionCallSymbol' && !symbol.function.isBuiltIn()) {
        nonBuiltInFunctionCalls.push(symbol);
    }
}

/**
    Return whether the given symbol is in the given tree.
    @method isGivenSymbolInAbstractSyntaxTree
    @param {Symbol} symbol The symbol to find.
    @param {Symbol} currentSymbol The current symbol in the tree being traversed.
    @return {Boolean} Whether the given symbol is in the given tree.
*/
function isGivenSymbolInAbstractSyntaxTree(symbol, currentSymbol) {
    var wasChildFound = true;

    if (symbol !== currentSymbol) {
        wasChildFound = currentSymbol.children.some(function (child) {
            return isGivenSymbolInAbstractSyntaxTree(symbol, child);
        });
    }

    return wasChildFound;
}

/**
    Generate a random integer.
    @method makeRandomInteger
    @return {Integer} A random integer.
*/
function makeRandomInteger() {
    var largeNumber = 1000000000000000;

    return Math.ceil(Math.random() * largeNumber);
}

'use strict';

/* global renderSuiteOfVariablesForTesting, renderSuiteOfFlowchartsForTesting, ExecutorController, Executor, globalConstants */

/**
    Models and components used for flowcharts.
    @module zyFlowchartSDK
    @return {void}
*/

var zyFlowchartSDK = function () {

    /**
        @constructor
    */
    function zyFlowchartSDK() {
        _classCallCheck(this, zyFlowchartSDK);

        this["zyFlowchartSDK"] = this["zyFlowchartSDK"] || {};

        this["zyFlowchartSDK"]["executor"] = Handlebars.template({ "1": function _(container, depth0, helpers, partials, data) {
                return " use-border";
            }, "3": function _(container, depth0, helpers, partials, data) {
                var helper;

                return "            <div id='" + container.escapeExpression((helper = (helper = helpers.segmentedFunctionControlId || (depth0 != null ? depth0.segmentedFunctionControlId : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "segmentedFunctionControlId", "hash": {}, "data": data }) : helper)) + "' class='segmented-function-control'></div>\n";
            }, "5": function _(container, depth0, helpers, partials, data) {
                return "            <div class='function-container'></div>\n";
            }, "7": function _(container, depth0, helpers, partials, data) {
                var helper;

                return "        <div id='" + container.escapeExpression((helper = (helper = helpers.segmentedLanguageControlId || (depth0 != null ? depth0.segmentedLanguageControlId : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "segmentedLanguageControlId", "hash": {}, "data": data }) : helper)) + "' class='segmented-language-control'></div>\n";
            }, "9": function _(container, depth0, helpers, partials, data) {
                var helper;

                return "        <div class='error-message'>" + container.escapeExpression((helper = (helper = helpers.errorMessage || (depth0 != null ? depth0.errorMessage : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "errorMessage", "hash": {}, "data": data }) : helper)) + "</div>\n";
            }, "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
                var stack1,
                    alias1 = depth0 != null ? depth0 : container.nullContext || {};

                return "<div class='flowchart-program-container'>\n    <div class='flowchart-program" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isUsingBothLanguages : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "'>\n" + ((stack1 = helpers["if"].call(alias1, (stack1 = depth0 != null ? depth0.functions : depth0) != null ? stack1.length : stack1, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.functions : depth0, { "name": "each", "hash": {}, "fn": container.program(5, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isUsingBothLanguages : depth0, { "name": "if", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.errorMessage : depth0, { "name": "if", "hash": {}, "fn": container.program(9, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "</div>";
            }, "useData": true });

        this["zyFlowchartSDK"]["flowchart"] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
                return "<div class='flowchart-canvas zb-scrollbar'></div>";
            }, "useData": true });

        this["zyFlowchartSDK"]["function"] = Handlebars.template({ "1": function _(container, depth0, helpers, partials, data) {
                var helper;

                return "            <div class='function-name'>" + container.escapeExpression((helper = (helper = helpers.functionName || (depth0 != null ? depth0.functionName : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "functionName", "hash": {}, "data": data }) : helper)) + "</div>\n";
            }, "3": function _(container, depth0, helpers, partials, data) {
                return "pseudocode-container";
            }, "5": function _(container, depth0, helpers, partials, data) {
                return "flowchart-container";
            }, "7": function _(container, depth0, helpers, partials, data) {
                return "                <div class='parameter-variables-container'></div>\n                <div class='local-variables-container'></div>\n                <div class='return-variable-container'></div>\n";
            }, "9": function _(container, depth0, helpers, partials, data) {
                var stack1;

                return "                <div class='variable-or-IO-label'>\n                    <p>Variables</p>\n                    <em>" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.showVariablesNotShownMessage : depth0, { "name": "if", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.program(12, data, 0), "data": data })) != null ? stack1 : "") + "</em>\n                </div>\n";
            }, "10": function _(container, depth0, helpers, partials, data) {
                return "Not shown when editing";
            }, "12": function _(container, depth0, helpers, partials, data) {
                return "None";
            }, "14": function _(container, depth0, helpers, partials, data) {
                return "            <div class='input-output-container'>\n                <div class='input-container'></div>\n                <div class='output-container'></div>\n            </div>\n";
            }, "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
                var stack1,
                    alias1 = depth0 != null ? depth0 : container.nullContext || {};

                return "<div class='program-function'>\n    <div>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.showFunctionName : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        <div class='function-container " + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isPseudocodeCurrentlyShown : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.program(5, data, 0), "data": data })) != null ? stack1 : "") + "'></div>\n    </div>\n    <div class='variables-and-IO-container'>\n        <div class='function-variables-container'>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.hasVariables : depth0, { "name": "if", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.program(9, data, 0), "data": data })) != null ? stack1 : "") + "        </div>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.hasInputOrOutput : depth0, { "name": "if", "hash": {}, "fn": container.program(14, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n</div>\n";
            }, "useData": true });

        this["zyFlowchartSDK"]["input"] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
                var helper;

                return "<div class='variable-or-IO-label'>Input</div>\n<div class='numerical-input' contenteditable='" + container.escapeExpression((helper = (helper = helpers.isEditable || (depth0 != null ? depth0.isEditable : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "isEditable", "hash": {}, "data": data }) : helper)) + "'></div>";
            }, "useData": true });

        this["zyFlowchartSDK"]["output"] = Handlebars.template({ "1": function _(container, depth0, helpers, partials, data) {
                return "    <div class='textarea-console-container'>\n        <textarea class='console' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false'></textarea>\n    </div>\n";
            }, "3": function _(container, depth0, helpers, partials, data) {
                return "    <div class='console'><pre class='numerical-output'></pre></div>\n";
            }, "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
                var stack1;

                return "<div class='variable-or-IO-label'>Output</div>\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.isEditable : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.program(3, data, 0), "data": data })) != null ? stack1 : "");
            }, "useData": true });

        this["zyFlowchartSDK"]["pseudocode"] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
                var helper;

                return "<div id='" + container.escapeExpression((helper = (helper = helpers.codeEditorID || (depth0 != null ? depth0.codeEditorID : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "codeEditorID", "hash": {}, "data": data }) : helper)) + "'></div>";
            }, "useData": true });

        this["zyFlowchartSDK"]["variables"] = Handlebars.template({ "1": function _(container, depth0, helpers, partials, data) {
                return " no-arrays";
            }, "3": function _(container, depth0, helpers, partials, data) {
                var stack1;

                return "            <tr>\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.isArraySizeComment : depth0, { "name": "if", "hash": {}, "fn": container.program(4, data, 0), "inverse": container.program(6, data, 0), "data": data })) != null ? stack1 : "") + "            </tr>\n";
            }, "4": function _(container, depth0, helpers, partials, data) {
                var helper;

                return "                    <td class='variable-size-comment'><span>" + container.escapeExpression((helper = (helper = helpers.comment || (depth0 != null ? depth0.comment : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "comment", "hash": {}, "data": data }) : helper)) + "</span></td>\n                    <td></td>\n";
            }, "6": function _(container, depth0, helpers, partials, data) {
                var stack1,
                    helper,
                    alias1 = depth0 != null ? depth0 : container.nullContext || {},
                    alias2 = helpers.helperMissing,
                    alias3 = "function",
                    alias4 = container.escapeExpression;

                return "                    <td class='variable-value" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.wasWrittenTo : depth0, { "name": "if", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "'>" + alias4((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof(helper)) === alias3 ? helper.call(alias1, { "name": "value", "hash": {}, "data": data }) : helper)) + "</td>\n                    <td class='variable-name'>" + alias4((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof(helper)) === alias3 ? helper.call(alias1, { "name": "name", "hash": {}, "data": data }) : helper)) + "</td>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isArray : depth0, { "name": "if", "hash": {}, "fn": container.program(9, data, 0), "inverse": container.program(12, data, 0), "data": data })) != null ? stack1 : "");
            }, "7": function _(container, depth0, helpers, partials, data) {
                return " highlight";
            }, "9": function _(container, depth0, helpers, partials, data) {
                var stack1;

                return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.isFirstOfArray : depth0, { "name": "if", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
            }, "10": function _(container, depth0, helpers, partials, data) {
                var helper,
                    alias1 = depth0 != null ? depth0 : container.nullContext || {},
                    alias2 = helpers.helperMissing,
                    alias3 = "function",
                    alias4 = container.escapeExpression;

                return "                            <td class='variable-type-container array-divider' rowspan='" + alias4((helper = (helper = helpers.numberOfElements || (depth0 != null ? depth0.numberOfElements : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof(helper)) === alias3 ? helper.call(alias1, { "name": "numberOfElements", "hash": {}, "data": data }) : helper)) + "'>\n                                <span class='array-name'>" + alias4((helper = (helper = helpers.arrayName || (depth0 != null ? depth0.arrayName : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof(helper)) === alias3 ? helper.call(alias1, { "name": "arrayName", "hash": {}, "data": data }) : helper)) + "</span>\n                                <br>\n                                <span class='variable-type'>" + alias4((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : alias2, (typeof helper === 'undefined' ? 'undefined' : _typeof(helper)) === alias3 ? helper.call(alias1, { "name": "type", "hash": {}, "data": data }) : helper)) + " array</span>\n                            </td>\n";
            }, "12": function _(container, depth0, helpers, partials, data) {
                var helper;

                return "                        <td class='variable-type-container variable-type'>" + container.escapeExpression((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "type", "hash": {}, "data": data }) : helper)) + "</td>\n";
            }, "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
                var stack1,
                    helper,
                    alias1 = depth0 != null ? depth0 : container.nullContext || {};

                return "<div class='variables-container" + ((stack1 = helpers.unless.call(alias1, depth0 != null ? depth0.hasArray : depth0, { "name": "unless", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "'>\n    <div class='variable-or-IO-label'>" + container.escapeExpression((helper = (helper = helpers.variablesName || (depth0 != null ? depth0.variablesName : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias1, { "name": "variablesName", "hash": {}, "data": data }) : helper)) + "</div>\n    <table>\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.variableRenderList : depth0, { "name": "each", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </table>\n</div>";
            }, "useData": true });

        globalConstants.templates = this['zyFlowchartSDK'];

        /**
            The CSS styles of the SDK.
            @property style
            @type {String}
        */
        this.css = '<style>.zyante-bold{font-family:HelveticaNeue-Light,"Helvetica Neue Light","Helvetica Neue",Helvetica,Arial,"Lucida Grande",sans-serif;font-weight:300}.zyante-section-bold{font-family:Helvetica;font-weight:300}.zyFlowchartSDK div.flowchart-canvas{overflow:auto;padding:1px}.zyFlowchartSDK div.flowchart-canvas svg{display:block;padding:2px}.zyFlowchartSDK div.flowchart-canvas svg text{white-space:pre}.zyFlowchartSDK div.flowchart-canvas svg text.edge-label{font-variant:small-caps}.zyFlowchartSDK div.variables-container td:first-child{text-align:center;width:80px}.zyFlowchartSDK div.variables-container:not(.no-arrays) td.variable-type-container{border-left:3px solid transparent;padding-left:8px}.zyFlowchartSDK div.variables-container:not(.no-arrays) td.variable-type-container.array-divider{border-left-color:#6685a8}.zyFlowchartSDK div.variables-container td.variable-value{border:2px solid #d98550;background-color:#f4d9bf}.zyFlowchartSDK div.variables-container td.variable-value.highlight{background-color:#efefef}.zyFlowchartSDK div.variables-container td.variable-name{padding:0 8px}.zyFlowchartSDK div.variables-container td.variable-size-comment{color:#ccc}.zyFlowchartSDK div.variables-container td.variable-size-comment span{position:relative;top:-1px}.zyFlowchartSDK div.variables-container .variable-type{color:#ccc}.zyFlowchartSDK div.variables-container span.array-name{color:#6685a8}.zyFlowchartSDK div.program-function{display:flex;flex-direction:row}.zyFlowchartSDK div.program-function div.function-name{color:#5780a6;margin-bottom:5px;text-align:center}.zyFlowchartSDK div.program-function div.flowchart-container{display:flex;padding:1px}.zyFlowchartSDK div.program-function div.pseudocode-container{border:1px solid #ccc;min-height:300px;text-align:left}.zyFlowchartSDK div.program-function div.pseudocode-container.disabled{opacity:.75;pointer-events:none}.zyFlowchartSDK div.program-function div.pseudocode-container.disabled .ace_editor{background-color:#eee}.zyFlowchartSDK div.program-function div.pseudocode-container div.ace_editor{height:100%}.zyFlowchartSDK div.program-function div.pseudocode-container div.ace_editor .ace_gutter{border-right:1px solid #ccc}.zyFlowchartSDK div.program-function div.pseudocode-container div.ace_editor .ace_breakpoint{background:#cbd8e4;border-radius:0 20px 20px 0;box-shadow:0 0 1px 1px #5780a6 inset}.zyFlowchartSDK div.program-function div.variables-and-IO-container{margin-left:15px}.zyFlowchartSDK div.program-function div.variables-and-IO-container div.function-variables-container,.zyFlowchartSDK div.program-function div.variables-and-IO-container div.input-output-container{padding-left:15px}.zyFlowchartSDK div.program-function div.variables-and-IO-container div.function-variables-container>div:not(:empty),.zyFlowchartSDK div.program-function div.variables-and-IO-container div.input-output-container>div:not(:empty){margin-bottom:15px}.zyFlowchartSDK div.program-function div.variables-and-IO-container div.function-variables-container{border-left:1px solid transparent;margin-bottom:30px}.zyFlowchartSDK div.program-function div.variables-and-IO-container div.input-output-container{border-left:1px solid #ccc;border-top:1px solid #ccc;padding-top:15px}.zyFlowchartSDK div.variable-or-IO-label{margin-bottom:2px;text-align:left}.zyFlowchartSDK div.variable-or-IO-label em{font-size:12px}.zyFlowchartSDK div.numerical-input{-moz-appearance:textfield-multiline;-webkit-appearance:textarea;-webkit-box-shadow:inset 1px 1px 1px 0 #ccc;-moz-box-shadow:inset 1px 1px 1px 0 #ccc;background-color:#fff;border:1px solid #ccc;box-shadow:inset 1px 1px 1px 0 #ccc;height:50px;overflow-y:scroll;padding:2px;width:inherit}.zyFlowchartSDK div.numerical-input[contenteditable=false]{background-color:#efefef;color:#8424ac}.zyFlowchartSDK div.numerical-input[contenteditable=false] span.consumed{color:#999}.zyFlowchartSDK div.numerical-input:focus{border-color:#5780a6;box-shadow:inset 0 1px 2px rgba(0,0,0,.075),0 0 5px rgba(87,128,166,.5);outline:0}.zyFlowchartSDK pre.numerical-output{color:#1ec81e}.zyFlowchartSDK div.output-container div.textarea-console-container{display:flex}.zyFlowchartSDK div.output-container div.console{box-sizing:border-box;display:block;max-height:100px;min-height:50px;overflow-y:scroll;width:100%}.zyFlowchartSDK div.output-container div.console::-webkit-scrollbar{background:transparent;width:8px}.zyFlowchartSDK div.output-container div.console::-webkit-scrollbar-thumb{background:#bdbdbd}.zyFlowchartSDK div.segmented-function-control:not(:empty){margin-bottom:8px}.zyFlowchartSDK div.segmented-language-control ul{margin-bottom:0;padding:0}.zyFlowchartSDK div.flowchart-program-container{align-items:flex-start;display:flex;flex-direction:column}.zyFlowchartSDK div.flowchart-program-container div.flowchart-program.use-border{border:1px solid #888;padding:6px}.zyFlowchartSDK div.flowchart-program-container div.error-message{background:#fff2f2;border:1px solid #bb0404;border-radius:3px;color:#bb0404;padding:3px;white-space:pre}</style>';
    }

    /**
        Render some flowcharts!
        @method init
        @param {String} id The unique identifier given to this module.
        @return {void}
    */


    _createClass(zyFlowchartSDK, [{
        key: 'init',
        value: function init(id) {
            $('#' + id).html(this.css);

            renderSuiteOfVariablesForTesting(id);
            renderSuiteOfFlowchartsForTesting(id);
        }

        /**
            Make an {Executor} from the given code and input.
            @method makeExecutor
            @param {String} code The code to convert into a program.
            @param {String} [input=null] The initial input for the executor.
            @param {Boolean} [isExecutable=false] Whether the program should be executable.
            @return {Executor} The executor made from the given code and input.
        */

    }, {
        key: 'makeExecutor',
        value: function makeExecutor(code) {
            var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var isExecutable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            return new Executor(code, input, isExecutable);
        }

        /**
            Make an executor controller for the given executor.
            @method makeExecutorController
            @param {Executor} executor The executor for which to make a controller.
            @param {Object} $container Reference to a jQuery object of the container for the controller.
            @return {ExecutorController} The controller made for the given executor.
        */

    }, {
        key: 'makeExecutorController',
        value: function makeExecutorController(executor, $container) {
            return new ExecutorController(executor, $container);
        }
    }]);

    return zyFlowchartSDK;
}();

module.exports = {
    create: function create() {
        if (!this.zyFlowchartSDK) {
            this.zyFlowchartSDK = new zyFlowchartSDK(); // eslint-disable-line new-cap
        }
        return this.zyFlowchartSDK;
    },
    dependencies: {
        "tools": ["utilities", "segmentedControl", "restrictedEditor"],
        "vendorJS": ["raphael.min.js", "alea.min.js"]
    },
    runTests: function runTests() {}
};


exports.default = module.exports;
});